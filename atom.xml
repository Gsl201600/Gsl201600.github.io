<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gsl&#39;s Library</title>
  
  <subtitle>如颖随行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gsl201600.github.io/"/>
  <updated>2020-12-30T11:47:09.965Z</updated>
  <id>https://gsl201600.github.io/</id>
  
  <author>
    <name>Gsl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>适配iPhoneX、iPhoneXs、iPhoneXs Max、iPhoneXr屏幕尺寸及安全区域</title>
    <link href="https://gsl201600.github.io/2020/12/30/%E9%80%82%E9%85%8DiPhoneXiPhoneXsiPhoneXsMaxiPhoneXr%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E5%8F%8A%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F/"/>
    <id>https://gsl201600.github.io/2020/12/30/适配iPhoneXiPhoneXsiPhoneXsMaxiPhoneXr屏幕尺寸及安全区域/</id>
    <published>2020-12-30T11:46:00.000Z</published>
    <updated>2020-12-30T11:47:09.965Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>先来认识<code>px</code>与<code>pt</code>区别<br><code>px</code>就是表示<code>pixel</code>像素，是屏幕上显示数据的最基本的点，它不是自然界的长度单位，点的大小是会变的，也称为<code>相对长度</code>；<br><code>pt</code>就是<code>point</code>，是印刷行业常用单位<code>磅</code>，等于1/72英寸，所以它是一个自然界标准的长度单位，也称为<code>绝对长度</code>。</p></li><li><p>我们再来了解缩放因子<code>(scale factor between logic point and device pixel)</code><br>早期的<code>iPhone3GS</code>的屏幕分辨率是<code>320*480(PPI=163)</code>，<code>iOS</code>绘制图形<code>(CGPoint/CGSize/CGRect)</code>均以<code>point</code>为单位：<code>1 point = 1 pixel</code><br>后来在<code>iPhone4</code>中，同样大小<code>3.5 inch</code>的屏幕采用了<code>Retina显示技术</code>，横、纵向方向像素密度都被<code>放大到2倍</code>，像素分辨率提高到<code>(320x2)x(480x2)= 960x640(PPI=326)</code>显像分辨率提升至<code>iPhone3GS</code>的<code>4倍</code>（<code>1个Point</code>被渲染成<code>1个2x2的像素矩阵</code>）<br>但是对于开发者来说，<code>iOS</code>绘制图形的<code>API</code>依然沿袭<code>point</code>为单位。在同样的逻辑坐标系下：<code>1 point = scale*pixel</code>（在<code>iPhone4~6</code>中，缩放因子<code>scale=2</code>；在<code>iPhone6+</code>中，缩放因子<code>scale=3</code>）</p></li><li><p>iPhone 各种机型尺寸信息列表入下表：</p></li></ol><table><thead><tr><th>机型</th><th>尺寸</th><th>逻辑缩放因子(UIKit Scale factor)</th><th>实际缩放因子(Native Scale factor)</th><th>屏幕宽高(开发尺寸)</th><th>屏幕分辨率</th><th>是否全面屏</th><th>有无刘海</th></tr></thead><tbody><tr><td>3GS</td><td>3.5寸</td><td>1.0</td><td>1.0</td><td>320x480</td><td>320x480</td><td>非全面屏</td><td>无</td></tr><tr><td>4(S)</td><td>3.5寸</td><td>2.0</td><td>2.0</td><td>320x480</td><td>640x960</td><td>非全面屏</td><td>无</td></tr><tr><td>5(C)／5(S)/SE</td><td>4寸</td><td>2.0</td><td>2.0</td><td>320x568</td><td>640x1136</td><td>非全面屏</td><td>无</td></tr><tr><td>6(S)／7／8</td><td>4.7寸</td><td>2.0</td><td>2.0</td><td>375x667</td><td>750x1334</td><td>非全面屏</td><td>无</td></tr><tr><td>6(S)+／7+／8+</td><td>5.5寸</td><td>3.0</td><td>2.608</td><td>414x736</td><td>1080x1920</td><td>非全面屏</td><td>无</td></tr><tr><td>X/XS</td><td>5.8寸</td><td>3.0</td><td>3.0</td><td>375x812</td><td>1125x2436</td><td>全面屏</td><td>有</td></tr><tr><td>XR</td><td>6.1寸</td><td>2.0</td><td>2.0</td><td>414×896</td><td>828 x1792</td><td>全面屏</td><td>有</td></tr><tr><td>XS Max</td><td>6.5寸</td><td>3.0</td><td>3.0</td><td>414×896</td><td>1242x2688</td><td>全面屏</td><td>有</td></tr></tbody></table><p>需要注意的地方是<code>6(S)+／7+／8+</code>的时候，实际的缩放因子并<code>不等于</code>逻辑上的缩放因子。所以，他的屏幕分辨率是<code>1080x1920</code>而不是<code>1242x2208</code><br>上述数据，可以通过代码获取逻辑缩放因子、逻辑屏幕宽度；实际缩放/物理因子、实际/物理屏幕宽度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;逻辑缩放因子</span><br><span class="line">[UIScreen mainScreen].scale</span><br><span class="line">&#x2F;&#x2F;逻辑屏幕宽度</span><br><span class="line">[UIScreen mainScreen].bounds</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;实际&#x2F;物理缩放因子</span><br><span class="line">[UIScreen mainScreen].nativeScale</span><br><span class="line">&#x2F;&#x2F;实际&#x2F;物理屏幕宽度</span><br><span class="line">[UIScreen mainScreen].nativeBounds</span><br></pre></td></tr></table></figure></p><ol start="4"><li>适配常用宏<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获得屏幕的宽高</span><br><span class="line">#define kScreenWidth [UIScreen mainScreen].bounds.size.width</span><br><span class="line">#define kScreenHeight [UIScreen mainScreen].bounds.size.height</span><br><span class="line">&#x2F;&#x2F;iPhoneX &#x2F; iPhoneXS</span><br><span class="line">#define  isIphoneX_XS     kScreenWidth &#x3D;&#x3D; 375.f &amp;&amp; kScreenHeight &#x3D;&#x3D; 812.f ? YES : NO</span><br><span class="line">&#x2F;&#x2F;iPhoneXR &#x2F; iPhoneXSMax</span><br><span class="line">#define  isIphoneXR_XSMax    kScreenWidth &#x3D;&#x3D; 414.f &amp;&amp; kScreenHeight &#x3D;&#x3D; 896.f ? YES : NO</span><br><span class="line">&#x2F;&#x2F;异性全面屏</span><br><span class="line">#define   isFullScreen    isIphoneX_XS || isIphoneXR_XSMax</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Status bar height.</span><br><span class="line">#define  StatusBarHeight     isFullScreen ? 44.f : 20.f</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Navigation bar height.</span><br><span class="line">#define  NavigationBarHeight  44.f</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Tabbar height.</span><br><span class="line">#define  TabbarHeight         isFullScreen ? (49.f+34.f) : 49.f</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Tabbar safe bottom margin.</span><br><span class="line">#define  TabbarSafeBottomMargin         isFullScreen ? 34.f : 0.f</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Status bar &amp; navigation bar height.</span><br><span class="line">#define  StatusBarAndNavigationBarHeight  isFullScreen ? 88.f : 64.f</span><br></pre></td></tr></table></figure></li><li>获取安全区域<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+ (CGRect)GetSafeAreaImpl&#123;</span><br><span class="line">    UIView *view &#x3D; UIApplication.sharedApplication.windows.lastObject;</span><br><span class="line">&#x2F;&#x2F;    UIView *view &#x3D; (UIView *)GetAppController().unityView;</span><br><span class="line">    CGRect area &#x3D; [self CustomComputeSafeArea:view];</span><br><span class="line">    &#x2F;&#x2F;    x &#x3D; area.origin.x;</span><br><span class="line">    &#x2F;&#x2F;    y &#x3D; area.origin.y;</span><br><span class="line">    &#x2F;&#x2F;    w &#x3D; area.size.width;</span><br><span class="line">    &#x2F;&#x2F;    h &#x3D; area.size.height;</span><br><span class="line">    return area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CGRect)CustomComputeSafeArea:(UIView *)view&#123;</span><br><span class="line">    CGSize screenSize &#x3D; view.bounds.size;</span><br><span class="line">    CGRect screenRect &#x3D; CGRectMake(0, 0, screenSize.width, screenSize.height);</span><br><span class="line">    </span><br><span class="line">    UIEdgeInsets insets &#x3D; UIEdgeInsetsMake(0, 0, 0, 0);</span><br><span class="line">    if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">        insets &#x3D; [view safeAreaInsets];</span><br><span class="line">    &#125;</span><br><span class="line">    screenRect.origin.x &#x3D; screenRect.origin.x + insets.left;</span><br><span class="line">    screenRect.origin.y &#x3D; screenRect.origin.y + insets.top;</span><br><span class="line">&#x2F;&#x2F;    screenRect.size.width -&#x3D; insets.left + insets.right;</span><br><span class="line">    screenRect.size.width &#x3D; screenRect.size.width - (insets.left + insets.right);</span><br><span class="line">    screenRect.size.height &#x3D; screenRect.size.height - (insets.top + insets.bottom);</span><br><span class="line">    &#x2F;&#x2F; 乘以缩放因子，根据需求可以省略</span><br><span class="line">    float scale &#x3D; view.contentScaleFactor;</span><br><span class="line">    screenRect.origin.x &#x3D; screenRect.origin.x * scale;</span><br><span class="line">    screenRect.origin.y &#x3D; screenRect.origin.y * scale;</span><br><span class="line">    screenRect.size.width &#x3D; screenRect.size.width * scale;</span><br><span class="line">    screenRect.size.height &#x3D; screenRect.size.height * scale;</span><br><span class="line">    return screenRect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动图数据<br><img src="https://upload-images.jianshu.io/upload_images/1948913-aae05ade339fa12f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>有刘海机型安全区域，有无刘海机型开发尺寸对比图<br><img src="https://upload-images.jianshu.io/upload_images/1948913-9ecc84eb5651f604.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="刘海机型安全区域"><br><img src="https://upload-images.jianshu.io/upload_images/1948913-c49f6bcfc715714e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="刘海机型开发尺寸"><br><img src="https://upload-images.jianshu.io/upload_images/1948913-78a1a153f3be10c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非刘海机型开发尺寸"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;先来认识&lt;code&gt;px&lt;/code&gt;与&lt;code&gt;pt&lt;/code&gt;区别&lt;br&gt;&lt;code&gt;px&lt;/code&gt;就是表示&lt;code&gt;pixel&lt;/code&gt;像素，是屏幕上显示数据的最基本的点，它不是自然界的长度单位，点的大小是会变的，也称为&lt;code&gt;相对
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 初探 AFNetworking</title>
    <link href="https://gsl201600.github.io/2020/07/08/iOS%E5%88%9D%E6%8E%A2AFNetworking/"/>
    <id>https://gsl201600.github.io/2020/07/08/iOS初探AFNetworking/</id>
    <published>2020-07-08T10:06:00.000Z</published>
    <updated>2020-07-15T10:36:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文不对<code>AFNetworking</code>作全面的解析，仅对比解析一下<code>2.x</code>和<code>3.x</code>的差异。</p><ol><li><code>AFNetworking</code>分为如下<code>5个功能模块</code>：</li></ol><ul><li>网络通信模块(<code>AFURLSessionManager、AFHTTPSessionManger</code>)</li><li>网络状态监听模块(<code>Reachability</code>)</li><li>网络通信安全策略模块(<code>Security</code>)</li><li>网络通信信息序列化/反序列化模块(<code>Serialization</code>)</li><li>对于<code>iOS UIKit</code>库的扩展(<code>UIKit</code>)</li></ul><ol start="2"><li><p><code>AFNetworking 2.x</code>需要常驻线程而<code>3.x</code>不需要常驻线程<br><code>2.x</code>常驻线程用来<code>并发请求和处理数据回调</code>，避免多个网络请求的线程开销(<code>不用开辟一个线程，就保活一条线程</code>)；而<code>3.x</code>不需要常驻线程是因为<code>NSURLSession</code>可以指定回调<code>delegateQueue</code>，<code>NSURLConnection</code>不行；<br><code>NSURLConnection</code>的一大痛点就是：发起请求后，需要一直处于<code>等待回调的状态</code>。而<code>3.x</code>后<code>NSURLSession</code>解决了这个问题；<code>NSURLSession</code>发起的请求，不再需要在当前线程进行回调，可以指定回调的<code>delegateQueue</code>，这样就不用为了等待代理回调方法而保活线程了</p></li><li><p><code>3.x</code>需要设置最大并发数为<code>1</code>(<code>self.operationQueue.maxConcurrentOperationCount = 1</code>)，<code>2.x</code>为什么不需要<br>功能不一样：<code>3.x</code>的<code>operationQueue</code>是用来接收<code>NSURLSessionDelegate</code>回调的，鉴于一些多线程数据访问的安全性考虑，设置了<code>maxConcurrentOperationCount = 1</code>来达到<code>并发的请求串行的进行回调</code>的效果。而<code>2.x</code>的<code>operationQueue</code>是用来添加<code>operation</code>进行<code>并发请求</code>的，所以不要设置为<code>1</code><br><strong>注意：并发数并不等于所开辟的线程数，具体开辟几条线程由系统决定</strong></p></li><li><p><code>3.x</code>为什么要串行回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate &#x3D; nil;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    &#x2F;&#x2F;给所要访问的资源加锁，防止造成数据混乱</span><br><span class="line">    delegate &#x3D; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">    return delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，这边对<code>self.mutableTaskDelegatesKeyedByTaskIdentifier</code>的访问进行了加锁，目的是<code>保证多线程环境下的数据安全</code>。既然加了锁，就算<code>maxConcurrentOperationCount</code>不设为<code>1</code>，当某个请求正在回调时，下一个请求还是得等待一直到上个请求获取完所要的资源后解锁，所以这边并发回调也是没有意义的。相反多<code>task</code>回调导致的多线程并发，还会导致性能的浪费</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文不对&lt;code&gt;AFNetworking&lt;/code&gt;作全面的解析，仅对比解析一下&lt;code&gt;2.x&lt;/code&gt;和&lt;code&gt;3.x&lt;/code&gt;的差异。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;AFNetworking&lt;/code&gt;分为如下&lt;code&gt;5个功能模块&lt;/
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 正则匹配常用方法</title>
    <link href="https://gsl201600.github.io/2020/07/08/iOS%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://gsl201600.github.io/2020/07/08/iOS正则匹配常用方法/</id>
    <published>2020-07-08T10:06:00.000Z</published>
    <updated>2020-07-08T10:06:10.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>验证手机号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 验证手机号</span><br><span class="line">+ (BOOL)isValidatePhone:(NSString *)phone&#123;</span><br><span class="line">    NSString *phoneRegex &#x3D; @&quot;^1([358][0-9]|4[579]|66|7[0135678]|9[89])[0-9]&#123;8&#125;$&quot;;</span><br><span class="line">    NSPredicate *phoneTest &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, phoneRegex];</span><br><span class="line">    return [phoneTest evaluateWithObject:phone];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>邮箱账号有效性判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 邮箱账号的有效性判断</span><br><span class="line">+ (BOOL)isValidateEmail:(NSString *)email&#123;</span><br><span class="line">    NSString * emailRegex &#x3D; @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;&quot;;</span><br><span class="line">    NSPredicate * emailTest &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex];</span><br><span class="line">    return [emailTest evaluateWithObject:email];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>匹配密码格式(长度6~20位，只能是数字、大小写字母)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 匹配密码格式</span><br><span class="line">+ (BOOL)isValidatePassword:(NSString *)password&#123;</span><br><span class="line">    NSString * passwordRegex &#x3D; @&quot;[a-zA-Z0-9]&#123;6,20&#125;&quot;;</span><br><span class="line">    NSPredicate * passwordTest &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, passwordRegex];</span><br><span class="line">    return [passwordTest evaluateWithObject:password];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>车牌号码判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 车牌号码正则表达式</span><br><span class="line">+ (BOOL)isValidateCarID:(NSString *)carID&#123;</span><br><span class="line">    if (carID.length&#x3D;&#x3D;7) &#123;</span><br><span class="line">        &#x2F;&#x2F;普通汽车，7位字符，不包含I和O，避免与数字1和0混淆</span><br><span class="line">        NSString *carRegex &#x3D; @&quot;^[\u4e00-\u9fa5]&#123;1&#125;[a-hj-np-zA-HJ-NP-Z]&#123;1&#125;[a-hj-np-zA-HJ-NP-Z0-9]&#123;4&#125;[a-hj-np-zA-HJ-NP-Z0-9\u4e00-\u9fa5]$&quot;;</span><br><span class="line">        NSPredicate *carTest &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, carRegex];</span><br><span class="line">        return [carTest evaluateWithObject:carID];</span><br><span class="line">    &#125;else if(carID.length&#x3D;&#x3D;8)&#123;</span><br><span class="line">        &#x2F;&#x2F;新能源车,8位字符，第一位：省份简称（1位汉字），第二位：发牌机关代号（1位字母）;</span><br><span class="line">        &#x2F;&#x2F;小型车，第三位：只能用字母D或字母F，第四位：字母或者数字，后四位：必须使用数字;([DF][A-HJ-NP-Z0-9][0-9]&#123;4&#125;)</span><br><span class="line">        &#x2F;&#x2F;大型车3-7位：必须使用数字，后一位：只能用字母D或字母F。([0-9]&#123;5&#125;[DF])</span><br><span class="line">        NSString *carRegex &#x3D; @&quot;^[\u4e00-\u9fa5]&#123;1&#125;[a-hj-np-zA-HJ-NP-Z]&#123;1&#125;([0-9]&#123;5&#125;[d|f|D|F]|[d|f|D|F][a-hj-np-zA-HJ-NP-Z0-9][0-9]&#123;4&#125;)$&quot;;</span><br><span class="line">        NSPredicate *carTest &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, carRegex];</span><br><span class="line">        return [carTest evaluateWithObject:carID];</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>身份证号判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 身份证号段正则表达式</span><br><span class="line">+ (BOOL)isValidateIDCard:(NSString *)identityString&#123;</span><br><span class="line">    if (identityString.length !&#x3D; 18) return NO;</span><br><span class="line">    &#x2F;&#x2F; 正则表达式判断基本 身份证号是否满足格式</span><br><span class="line">    NSString *regex2 &#x3D; @&quot;^(^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$)|(^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d&#123;4&#125;)|\\d&#123;3&#125;[Xx])$)$&quot;;</span><br><span class="line">    NSPredicate *identityStringPredicate &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex2];</span><br><span class="line">    &#x2F;&#x2F;如果通过该验证，说明身份证格式正确，但准确性还需计算</span><br><span class="line">    if(![identityStringPredicate evaluateWithObject:identityString]) return NO;</span><br><span class="line">    &#x2F;&#x2F;** 开始进行校验 *&#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;将前17位加权因子保存在数组里</span><br><span class="line">    NSArray *idCardWiArray &#x3D; @[@&quot;7&quot;, @&quot;9&quot;, @&quot;10&quot;, @&quot;5&quot;, @&quot;8&quot;, @&quot;4&quot;, @&quot;2&quot;, @&quot;1&quot;, @&quot;6&quot;, @&quot;3&quot;, @&quot;7&quot;, @&quot;9&quot;, @&quot;10&quot;, @&quot;5&quot;, @&quot;8&quot;, @&quot;4&quot;, @&quot;2&quot;];</span><br><span class="line">    &#x2F;&#x2F;这是除以11后，可能产生的11位余数、验证码，也保存成数组</span><br><span class="line">    NSArray *idCardYArray &#x3D; @[@&quot;1&quot;, @&quot;0&quot;, @&quot;10&quot;, @&quot;9&quot;, @&quot;8&quot;, @&quot;7&quot;, @&quot;6&quot;, @&quot;5&quot;, @&quot;4&quot;, @&quot;3&quot;, @&quot;2&quot;];</span><br><span class="line">    &#x2F;&#x2F;用来保存前17位各自乖以加权因子后的总和</span><br><span class="line">    NSInteger idCardWiSum &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 17;i++) &#123;</span><br><span class="line">        NSInteger subStrIndex  &#x3D; [[identityString substringWithRange:NSMakeRange(i, 1)] integerValue];</span><br><span class="line">        NSInteger idCardWiIndex &#x3D; [[idCardWiArray objectAtIndex:i] integerValue];</span><br><span class="line">        idCardWiSum +&#x3D; subStrIndex * idCardWiIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;计算出校验码所在数组的位置</span><br><span class="line">    NSInteger idCardMod&#x3D;idCardWiSum%11;</span><br><span class="line">    &#x2F;&#x2F;得到最后一位身份证号码</span><br><span class="line">    NSString *idCardLast&#x3D; [identityString substringWithRange:NSMakeRange(17, 1)];</span><br><span class="line">    &#x2F;&#x2F;如果等于2，则说明校验码是10，身份证号码最后一位应该是X</span><br><span class="line">    if(idCardMod&#x3D;&#x3D;2) &#123;</span><br><span class="line">        if(![idCardLast isEqualToString:@&quot;X&quot;]||[idCardLast isEqualToString:@&quot;x&quot;]) &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;用计算出的验证码与最后一位身份证号码匹配，如果一致，说明通过，否则是无效的身份证号码</span><br><span class="line">        if(![idCardLast isEqualToString: [idCardYArray objectAtIndex:idCardMod]]) &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>随机获取八位字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)obtain8RandomCode &#123;</span><br><span class="line">    NSArray *changeArray &#x3D; [[NSArray alloc] initWithObjects:@&quot;0&quot;,@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;A&quot;,@&quot;B&quot;,@&quot;C&quot;,@&quot;D&quot;,@&quot;E&quot;,@&quot;F&quot;,@&quot;G&quot;,@&quot;H&quot;,@&quot;I&quot;,@&quot;J&quot;,@&quot;K&quot;,@&quot;L&quot;,@&quot;M&quot;,@&quot;N&quot;,@&quot;O&quot;,@&quot;P&quot;,@&quot;Q&quot;,@&quot;R&quot;,@&quot;S&quot;,@&quot;T&quot;,@&quot;U&quot;,@&quot;V&quot;,@&quot;W&quot;,@&quot;X&quot;,@&quot;Y&quot;,@&quot;Z&quot;,@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,@&quot;d&quot;,@&quot;e&quot;,@&quot;f&quot;,@&quot;g&quot;,@&quot;h&quot;,@&quot;i&quot;,@&quot;j&quot;,@&quot;k&quot;,@&quot;l&quot;,@&quot;m&quot;,@&quot;n&quot;,@&quot;o&quot;,@&quot;p&quot;,@&quot;q&quot;,@&quot;r&quot;,@&quot;s&quot;,@&quot;t&quot;,@&quot;u&quot;,@&quot;v&quot;,@&quot;w&quot;,@&quot;x&quot;,@&quot;y&quot;,@&quot;z&quot;,@&quot;!&quot;,@&quot;@&quot;,@&quot;#&quot;,@&quot;$&quot;,@&quot;^&quot;,@&quot;&amp;&quot;,@&quot;*&quot;,@&quot;-&quot;,@&quot;+&quot;,nil];</span><br><span class="line">    NSArray *specailArray &#x3D; [[NSArray alloc] initWithObjects:@&quot;!&quot;,@&quot;@&quot;,@&quot;#&quot;,@&quot;$&quot;,@&quot;^&quot;,@&quot;&amp;&quot;,@&quot;*&quot;,@&quot;-&quot;,@&quot;+&quot;, nil];</span><br><span class="line">    NSMutableString *changeString &#x3D; [[NSMutableString alloc] initWithCapacity:8];</span><br><span class="line">    </span><br><span class="line">    NSInteger specialIndex &#x3D; arc4random()%7;</span><br><span class="line">    NSInteger specialArrayIndex &#x3D; arc4random()%([specailArray count] - 1);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 8; i++)&#123;</span><br><span class="line">        if (i&#x3D;&#x3D;specialIndex) &#123;</span><br><span class="line">            changeString &#x3D; (NSMutableString *)[changeString stringByAppendingString:[specailArray objectAtIndex:specialArrayIndex]];</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        NSInteger index &#x3D; arc4random()%([changeArray count] - 1);</span><br><span class="line">        changeString &#x3D; (NSMutableString *)[changeString stringByAppendingString:[changeArray objectAtIndex:index]];</span><br><span class="line">    &#125;</span><br><span class="line">    return changeString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;验证手机号&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 内购项目的App Store推广</title>
    <link href="https://gsl201600.github.io/2020/05/27/iOS%E5%86%85%E8%B4%AD%E9%A1%B9%E7%9B%AE%E7%9A%84AppStore%E6%8E%A8%E5%B9%BF/"/>
    <id>https://gsl201600.github.io/2020/05/27/iOS内购项目的AppStore推广/</id>
    <published>2020-05-27T08:50:00.000Z</published>
    <updated>2020-05-27T08:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>iOS 11</code>以后的用户可以在<code>App Store</code>内的下载页面内直接购买应用的内购商品，这项功能苹果称作做<code>Promoting In-App Purchases</code>，如果你的<code>App</code>需要在<code>App Store</code>推广自己的内购商品，则需要在<code>App Store</code>推广里上传推广用的图像，另外苹果也在<code>iOS11 SDK</code>里面新增了从<code>App Store</code>购买内购项目跳转到<code>App</code>的新方法</p><ol><li>选择<code>推广App内购买项目</code>的好处</li></ol><ul><li>提高展示促销机会，在产品页面上，开发者可一次性推广多达<code>20个App</code>内购买项目</li><li>提高下载量，<code>App</code>内购买项目的推广还能促进<code>App</code>的下载量。如果用户尚未安装<code>App</code>，在点击购买<code>App内购项目</code>时，会引导其先下载</li></ul><ol start="2"><li>如何推广<code>App内购买项目</code></li></ol><ul><li><p>在<code>App Store Connect</code>中为准备推广的<code>App</code>内购买项目上传宣传图像。该图像不但会显示在<code>App Store</code>产品页面，也可能显示在搜索结果中。如果入选精品推荐，它更可能显示在<code>Today、游戏今日亮点、App今日亮点</code>中。当<code>App</code>内购买项目显示在<code>App Store</code>产品页面以外的地方（如搜索结果中），<code>App</code>图标会显示在外框的左下方，所以要确保设计的宣传图像不会被外框遮盖，注意重要细节不要放在左下角，不建议在图像上叠加文字</p></li><li><p><code>App Store</code>后台内购项目的配置，默认情况下，推广的<code>App</code>内购买项目将面向所有设备显示，即使它们没有安装<code>App</code>。①在工具栏中，点按<code>功能</code>，然后在左列中点按<code>App 内购买项目</code>。②点需要修改的<code>App内购买项目</code>，然后前往<code>App Store 推广</code>部分。③配置<code>面向所有 App Store 用户显示，即使是没有安装该 App 的用户</code>复选框设置。④点按<code>存储</code>。⑤在左列中点按<code>App Store 推广</code>，勾选需要推广的项目<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.05.27.01.png" alt=""></p></li></ul><ol start="3"><li>开发者需注意</li></ol><ul><li><code>iOS11以上</code>用户可见，所以产品需要针对<code>iOS11以上</code>系统兼容</li><li>开发者显示<code>App</code>内购买项目推广后，不一定被显示在苹果搜索结果中，只是可能</li><li>苹果明确规定只有<code>除消耗型 App 内购买项目</code>会显示在搜索结果中</li><li>产品提供订阅获取收益十分可观，从而苹果针对<code>自动续期订阅</code>也十分看重，并且为其提供了相关设置方法及运营手段的介绍，所以开发者们可重点尝试<code>App</code>内购买项目中<code>自动续期订阅</code>形式展示，能够得到苹果更多认可及展示</li><li>游戏开发者可考虑利用关卡设置<code>App 内购买项目</code>的形式吸引苹果关注，不同关卡有不同的<code>App 内购买项目（非消耗型）</code>或完整体验需付费的形式，类似这类<code>App</code>苹果是给予鼓励的</li><li>用户直接在<code>App</code>下载页面购买内购商品，这就涉及到从<code>App Store</code>跳转到自己<code>App</code>，所以苹果在<code>SKPaymentTransactionObserver</code>新增了一个代理方法：<br><code>- (BOOL)paymentQueue:(SKPaymentQueue *)queue shouldAddStorePayment:(SKPayment *)payment forProduct:(SKProduct *)product</code><br>这个代理函数是在<code>App Store</code>发起购买的时候会有回调，用户如果在<code>App</code>下载页面点击购买你推广的内购商品，如果用户已经安装过你的<code>App</code>则会直接跳转你的<code>App</code>并调用上述代理方法；如果用户还没有安装你的<code>App</code>那么就会去下载你的<code>App</code>，下载完成之后系统会推送一个通知，如果用户点击该通知就会跳转到你的<code>App</code>并且调用上面的代理方法<br>上面的代理方法返回<code>YES</code>则表示跳转到你的<code>App</code>，<code>IAP</code>继续完成交易，如果返回<code>NO</code>则表示推迟或者取消购买，实际开发中因为可能还需要用户登录自己的账号、生成订单等，一般都是返回<code>NO</code>，之后自己手动把代理方法里面返回的<code>SKPayment</code>加入支付队列，然后在按照自己的支付、验证逻辑完成支付</li></ul><ol start="4"><li>测试<br>苹果提了测试方法，就是修改下面的链接地址，然后在<code>safari</code>浏览器打开，就可以测试从<code>App Store</code>发起购买了。其中链接中的<code>bundleId</code>修改为你自己应用的<code>bundleId</code>，<code>productId</code>修改为你创建的商品的<code>id</code>，如：<code>itms-services://?action=purchaseIntent&amp;bundleId=bundleId&amp;productIdentifier=productId</code></li></ol><p><a href="https://xiaovv.me/2018/05/03/My-iOS-In-App-Purchase-Summarize">附：iOS 内购总结</a><br><a href="https://developer.apple.com/videos/play/wwdc2017/303">附：[官方文档] What’s New in StoreKit</a><br><a href="https://help.apple.com/app-store-connect">附：[官方文档] App Store Connect 帮助</a><br><a href="https://developer.apple.com/cn/app-store/promoting-in-app-purchases">附：[官方文档] 推广您的 App 内购买项目</a><br><a href="https://developer.apple.com/documentation/storekit/in-app_purchase/testing_promoted_in-app_purchases">附：[官方文档] Testing Promoted In-App Purchases</a><br><a href="https://github.com/Gsl201600/Promoting-In-App-PurchasesDemo.git">附：Promoting-In-App-PurchasesDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;iOS 11&lt;/code&gt;以后的用户可以在&lt;code&gt;App Store&lt;/code&gt;内的下载页面内直接购买应用的内购商品，这项功能苹果称作做&lt;code&gt;Promoting In-App Purchases&lt;/code&gt;，如果你的&lt;code&gt;App&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS block原理详解</title>
    <link href="https://gsl201600.github.io/2020/05/13/iOSblock%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://gsl201600.github.io/2020/05/13/iOSblock原理详解/</id>
    <published>2020-05-13T08:18:00.000Z</published>
    <updated>2020-06-29T09:28:08.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>block本质</li></ol><ul><li><code>block</code>底层就是一个<code>struct __main_block_impl_0</code>类型的<code>结构体</code>，这个结构体中包含一个<code>isa</code>指针，本质上是一个<code>OC</code>对象</li><li><code>block</code>是封装了<code>函数调用</code>以及<code>函数调用环境</code>的<code>OC</code>对象</li></ul><ol start="2"><li><p>block底层结构<br><code>block</code>底层结构就是<code>__main_block_impl_0</code>结构体，内部包含了<code>impl结构体</code>和<code>Desc结构体</code>以及外部需要访问的<code>变量</code>，<code>block</code>将需要执行的代码放到一个函数里，<code>impl</code>内部的<code>FuncPtr</code>指向这个函数的地址，通过地址调用这个函数，就可以执行<code>block</code>里面的代码了。<code>Desc</code>用来描述<code>block</code>，内部的<code>reserved</code>作保留，<code>Block_size</code>描述<code>block</code>占用内存<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.05.13.01.png" alt=""></p></li><li><p>block的变量捕获<br><code>局部变量block</code>访问方式是<code>值传递</code>，<code>auto自动变量</code>可能会销毁，内存可能会消失，不采用指针访问；<br><code>局部静态变量block</code>访问方式是<code>指针传递</code>，<code>static变量</code>一直保存在内存中，指针访问即可;<br><code>全局变量、静态全局变量block</code>不需要对变量捕获，直接取值<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.05.13.02.png" alt=""></p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; block的变量捕获代码解析如下</span><br><span class="line">auto int age &#x3D; 10;</span><br><span class="line">static int height &#x3D; 10;    </span><br><span class="line">void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;age is %d,height is %d&quot;,age,height);</span><br><span class="line">&#125;;        </span><br><span class="line">age &#x3D; 20;</span><br><span class="line">height &#x3D; 20;        </span><br><span class="line">block();</span><br><span class="line">-------------------------------------------------</span><br><span class="line">output: age is 10,height is 20</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int age; &#x2F;&#x2F; 值传递</span><br><span class="line">  int *height; &#x2F;&#x2F; 指针传递</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>block的类型</li></ol><table><thead><tr><th>block类型</th><th>环境</th><th>存储域</th><th>copy操作后</th></tr></thead><tbody><tr><td><code>__NSGlobalBlock__</code></td><td>没有访问<code>auto变量</code></td><td>数据区</td><td>什么也不做，类型不改变</td></tr><tr><td><code>__NSStackBlock__</code></td><td>访问了<code>auto变量</code></td><td>栈区</td><td>从栈复制到堆，类型改变为<code>__NSMallocBlock__</code></td></tr><tr><td><code>__NSMallocBlock__</code></td><td><code>__NSStackBlock__</code>调用了<code>copy</code></td><td>堆区</td><td>引用计数<code>+1</code>，类型不改变</td></tr></tbody></table><p>在<code>ARC</code>下<code>Block</code>访问<code>auto变量</code>时系统默认帮我们进行了<code>copy</code>操作，<code>NSGlobalBlock</code>访问了<code>auto变量</code>时会变成<code>NSStackBlock</code>，当<code>NSStackBlock</code>进行<code>copy</code>操作后会变成<code>NSMallocBlock</code></p><ul><li>在<code>ARC</code>环境下，编译器会根据以下几种情况自动将<code>栈上的block</code>复制到<code>堆上</code>:<br>1、<code>block</code>作为函数返回值时，比如使用<code>=</code><br>2、将<code>block</code>赋值给<code>__strong</code>指针时<br>3、<code>block</code>作为<code>Cocoa API</code>中方法名含有<code>usingBlock</code>的方法参数时<br>4、<code>block</code>作为<code>GCD API</code>的方法参数时</li></ul><ol start="5"><li>对象类型的auto变量</li></ol><ul><li>当<code>block</code>内部访问了对象类型的<code>auto变量</code>时:<br>如果<code>block在栈空间</code>，不论是<code>ARC还是MRC</code>环境，不管<code>外部变量</code>是<code>强引用还是弱引用</code>，<code>block</code>都会<code>弱引用</code>访问对象<br>如果<code>block在堆空间</code>，如果外部<code>强引用</code>，<code>block</code>内部也是<code>强引用</code>；如果外部<code>弱引用</code>，<code>block</code>内部也是<code>弱引用</code></li><li>栈block：<br>a) 如果<code>block</code>是在<code>栈上</code>，将不会对<code>auto变量</code>产生<code>强引用</code><br>b) <code>栈上的block</code>随时会被销毁，也没必要去强引用其他对象</li><li>堆block：<br><strong>1、如果block被拷贝到堆上</strong><br>a) 会调用<code>block</code>内部的<code>copy</code>函数<br>b) <code>copy</code>函数内部会调用<code>_Block_object_assign</code>函数<br>c) <code>_Block_object_assign</code>函数会根据<code>auto变量</code>的修饰符<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>做出相应的操作，形成<code>强引用</code>或者<code>弱引用</code><br><strong>2、如果block从堆上移除</strong><br>a) 会调用<code>block</code>内部的<code>dispose</code>函数<br>b) <code>dispose</code>函数内部会调用<code>_Block_object_dispose</code>函数<br>c) <code>_Block_object_dispose</code>函数会自动释放引用的<code>auto变量</code>(<code>release</code>，引用计数<code>-1</code>，若为<code>0</code>，则销毁)</li></ul><ol start="6"><li>__block</li></ol><ul><li><code>__block</code>修饰符作用：<br><code>__block</code>可以用于解决<code>block</code>内部无法修改<code>auto变量值</code>的问题<br><code>__block</code>不能修饰全局变量、静态变量<code>static</code></li><li><code>__block</code>修饰符原理：<br>编译器会将<code>__block</code>变量包装成一个结构体<code>__Block_byref_age_0</code>，结构体内部<code>*__forwarding</code>是指向自身的指针，内部还存储着外部<code>auto变量</code>的值<br><code>__block</code>的<code>forwarding</code>指针如下图：<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.05.13.03.png" alt=""></li></ul><p><code>栈上</code>，<code>__block</code>结构体中的<code>__forwarding</code>指针<code>指向自己</code>，一旦复制到<code>堆上</code>，<code>栈上的__block</code>结构体中的<code>__forwarding</code>指针会指向<code>堆上的__block</code>结构体，<code>堆上__block</code>结构体中的<code>__forwarding</code>还是<code>指向自己</code>。假设<code>age</code>是<code>栈上</code>的变量，<code>age-&gt;__forwarding</code>会拿到<code>堆上的__block</code>结构体，<code>age-&gt;__forwarding-&gt;age</code>会把<code>20</code>赋值到<code>堆上</code>，不论是<code>栈上还是堆上的__block</code>结构体，都能保证<code>20</code>赋值到<code>堆的结构体</code>里</p><ol start="7"><li>思考题：block修改NSMutableString、NSMutableArray、NSMutableDictionary，需不需要添加__block<br>题目如下：以下代码是否可以正确执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSMutableArray *array &#x3D; [NSMutableArray array];</span><br><span class="line">        void (^block)(void) &#x3D; ^&#123;</span><br><span class="line">            [array addObject: @&quot;5&quot;];</span><br><span class="line">            [array addObject: @&quot;5&quot;];</span><br><span class="line">            NSLog(@&quot;%@&quot;,array);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>分析：可以正确执行，因为在<code>block</code>块中仅仅是使用了<code>array的内存地址</code>，往<code>内存地址</code>中<code>添加内容</code>，并没有修改<code>arry的内存地址</code>，因此<code>array</code>不需要使用<code>__block修饰</code>也可以正确编译。当仅仅是使用<code>局部变量的内存地址</code>，而不是<code>修改</code>的时候，尽量不要添加<code>__block</code>，通过上述分析我们知道一旦添加了<code>__block</code>修饰符，系统会自动创建相应的结构体，占用不必要的内存空间</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;block本质&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;block&lt;/code&gt;底层就是一个&lt;code&gt;struct __main_block_impl_0&lt;/code&gt;类型的&lt;code&gt;结构体&lt;/code&gt;，这个结构体中包含一个&lt;code&gt;isa&lt;
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 数据结构</title>
    <link href="https://gsl201600.github.io/2020/05/06/iOS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://gsl201600.github.io/2020/05/06/iOS数据结构/</id>
    <published>2020-05-06T08:34:00.000Z</published>
    <updated>2020-05-06T08:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>数组和链表的区别</li></ol><ul><li>数组<br>地址连续，查找速度快，操作效率低<br>存储单元在定义时分配，元素个数固定，内存空间要求高</li><li>链表<br>地址不连续，查找速度慢，操作效率高<br>存储单元在程序执行时动态申请，可按需动态增减</li></ul><ol start="2"><li>iOS内存分区的情况，五大区域</li></ol><ul><li>栈区<code>Stack</code><br>先进后出<code>FILO</code><br>由编译器自动分配和释放<br>栈空间多线程不共享<br>连续的内存地址，由高向低分配，不会产生碎片<br>空间较小，运行速度较快，效率高<br>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高</li><li>堆区<code>Heap</code><br>分配方式类似链表，先进先出<code>FIFO</code><br>一般需要手动分配和释放<br>堆内存多线程共享<br>不连续的内存地址，由低向高分配，容易产生碎片<br>空间较大，运行速度较慢，效率不如栈<br>计算机底层并没有对堆的支持，堆是有<code>C/C++</code>函数库提供的，加上碎片问题，导致堆的效率比栈低</li><li>全局区<br>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域<code>.data段</code>，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域<code>.bss段</code><br>程序结束后由系统释放</li><li>常量区<br>常量字符串就是放在这里的<br>程序结束后由系统释放</li><li>代码区<br>存放函数体的二进制代码</li></ul><p><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.05.06.01.png" alt="内存分区"></p><ul><li>当一个app启动后，代码区、常量区、全局区大小就已经固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错）</li></ul><ol start="3"><li><p><code>Hash</code>表<br>哈希表(<code>Hash table</code>，也叫<code>散列表</code>)是根据<code>键Key</code>直接访问在内存中存储位置的数据结构。也就是说，它通过计算一个关于<code>键值的函数</code>，将所需<code>查询的数据</code>映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数叫做<code>散列函数</code>，存放记录的数组叫做<code>散列表</code>。通俗讲就是把<code>Key</code>通过一个固定的<code>算法函数(hash函数)</code>转换成一个<code>整型数字</code>，然后就对该<code>数字用数组的长度进行取余</code>，取余结果就当作<code>数组的下标</code>，将<code>value</code>存储在以该数字为<code>下标的数组</code>空间里。当使用<code>hash</code>表查询时，就是使用<code>hash</code>函数将<code>key</code>转换成对应的<code>数组下标</code>，并定位到该下标的数组空间里获取<code>value</code>，这样就充分利用到数组的定位性能进行数据定位</p></li><li><p><code>iOS</code>里有哪些地方用到了<code>Hash</code>表<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.05.06.02.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;数组和链表的区别&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;数组&lt;br&gt;地址连续，查找速度快，操作效率低&lt;br&gt;存储单元在定义时分配，元素个数固定，内存空间要求高&lt;/li&gt;
&lt;li&gt;链表&lt;br&gt;地址不连续，查找速度慢，操作效率高&lt;br&gt;存储单元在程序执行时动态申请
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS Crash文件获取及符号化</title>
    <link href="https://gsl201600.github.io/2020/04/29/iOSCrash%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%8F%8A%E7%AC%A6%E5%8F%B7%E5%8C%96/"/>
    <id>https://gsl201600.github.io/2020/04/29/iOSCrash文件获取及符号化/</id>
    <published>2020-04-29T07:46:00.000Z</published>
    <updated>2020-04-29T08:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>Crash</code>文件获取</li></ol><ul><li>大致可以分为两种方式：远程获取和本地获取；具体可以分为如下四种途径</li></ul><p>1.1. 远程获取；已经上传到<code>iTunes Connect</code>的应用，可以通过<code>iTunes Connect</code>的<code>App分析</code>查看<code>App</code>崩溃情况<code>不会有崩溃日志</code>，如果是<code>TestFlight</code>测试，则可以在<code>iTunes Connect</code>获取到崩溃日志</p><p>1.2. 远程获取；通过<code>Xcode</code>菜单<code>Window -&gt; Organizer -&gt; Crashes</code>获取用户的崩溃日志<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.29.01.png" alt=""></p><ul><li>注意：以上两种途径都需要登录开发者账号，并且需要用户共享<code>iPhone</code>分析，才能够获取到用户的崩溃日志</li><li>注意：官方提供的崩溃信息并不是实时的，只能查看两天之前的崩溃信息，需要实时的可以使用第三方工具</li></ul><p>1.3. 本地获取；在手机上<code>设置 -&gt; 隐私 -&gt; 分析与改进 -&gt; 分析数据</code>中，根据应用名称和日期时间找到你需要的日志，点击进去后，右上角会有个分享按钮，分享给<code>Mac</code></p><p>1.4. 把手机连接到<code>Mac</code>，通过<code>Xcode</code>菜单<code>Window -&gt; Devices and Simulators -&gt; Devices -&gt; View Device Logs</code>获取用户的崩溃日志</p><ul><li>注意某些<code>iOS</code>系统会没有上面提到的分享按钮，这时候可以全选复制，再发送给<code>Mac</code><br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.29.02.png" alt="1.1该图为早期iTunes Connect官网，具体以当前官网为主"></li></ul><ol start="2"><li><code>Crash</code>文件符号化</li></ol><ul><li>大致也是分为两种方式：使用<code>Xcode</code>自动符号化和通过手动命令行工具<code>symbolicatecrash</code>符号化；这两种方式原理一样，都需要<code>dSYM</code>文件，只不过前者是<code>Xcode</code>自动帮我们完成的</li><li>注意：如果你们的应用是通过<code>Xcode</code>上传<code>iTunes Connect</code>的，并同时上传了<code>.xcarchive</code>文件<code>(实际上是一个文件夹，包含.ipa和.dSYM文件)</code>，<code>Xcode</code>会默认帮你勾选该选项，那么从<code>iTunes Connect</code>获取到的日志就已经是符号化过的了</li></ul><p>2.1. 使用<code>Xcode</code>自动符号化<code>Crash</code>文件，<code>Xcode</code>自带的工具非常好用</p><ul><li>如果你用的<code>Mac</code>就是打包的机子，并且得到了发生崩溃的手机，那么手机连接电脑，通过<code>Xcode</code>菜单<code>Window -&gt; Devices and Simulators -&gt; Devices -&gt; View Device Logs</code>找到自己的日志，就是符号化过后的，如果没有符号化，就稍微等待一会儿，或者右击点出菜单选择<code>Re-Symbolicate Log</code></li><li>如果只有<code>Mac</code>出包机，没有手机只有崩溃日志，那么同样可以通过<code>Xcode</code>菜单<code>Window -&gt; Devices and Simulators -&gt; Devices -&gt; View Device Logs</code>把崩溃日志直接拖进去，就是符号化过后的，如果没有符号化，就稍微等待一会儿，或者右击点出菜单选择<code>Re-Symbolicate Log</code></li><li>注意：在有些版本的<code>Xcode</code>是拖不进去的，遇到这种情况可以用下面的手动符号化方式</li><li>注意：上面的方法不一定要是出包机，本质是只要你的电脑上有<code>dSYM</code>文件，<code>Xcode</code>就能自动找到他并为你符号化<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.29.03.png" alt=""></li></ul><p>2.2. 通过终端命令行工具<code>symbolicatecrash</code>符号化<br>大概需要如下三个文件，下面是获取这些文件的方法<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.29.04.png" alt=""></p><ul><li>通过菜单<code>Xcode -&gt; Window -&gt; Organizer -&gt; Archiver</code>找到打包的项目，右键<code>Show In Finder</code>，找到<code>AppName.xcarchive</code>，右键显示包内容，找到<code>AppName.app.dSYM</code></li><li>在桌面创建一个文件夹<code>tmp</code>，将以上两个文件拷贝到<code>tmp</code>文件夹中</li><li>打开终端，用<code>find /Applications/Xcode.app -name symbolicatecrash -type f</code>查找<code>symbolicatecrash</code>，其中<code>/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash</code>路径是需要的<code>symbolicatecrash</code>文件，将<code>symbolicatecrash</code>文件也拷贝到<code>tmp</code>文件夹中</li><li>将需要分析的<code>crash</code>文件也拷贝到<code>tmp</code>文件夹中，<code>crash</code>文件的格式可能是<code>.beta</code>、<code>.crash</code>或<code>.ips</code></li><li>在终端中使用以下命令行，<code>crash</code>文件格式以<code>.crash</code>为例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入到 tmp 文件夹中</span><br><span class="line">cd ~&#x2F;Desktop&#x2F;tmp </span><br><span class="line"></span><br><span class="line"># 分析 crash 文件，会在 &#96;tmp&#96; 文件夹中生成 crash.log 文件</span><br><span class="line">.&#x2F;symbolicatecrash .&#x2F;xxx.crash .&#x2F;AppName.app.dSYM &gt; crash.log</span><br><span class="line">或.&#x2F;symbolicatecrash .&#x2F;xxx.crash .&#x2F;.app.dSYM &gt; crash.log</span><br></pre></td></tr></table></figure></li><li>如果终端报类似这样的错<code>zsh: permission denied: ./symbolicatecrash</code><br>说明是<code>symbolicatecrash</code>文件有问题，可能该文件不是本机获取的，或者是之前获取的、<code>Xcode</code>升级等问题造成的，重新在本机上按上面方法获取即可</li><li>如果终端报类似这样的错<code>Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.</code><br>尝试以下命令后，再重复上面命令，正常情况就可以分析bug了<code>export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</code></li></ul><ol start="3"><li>符号化之前，首先得确保<code>Crash</code>文件和<code>dSYM</code>这两个文件里面的<code>UUID</code>是一致的，如果不一致，就说明不是本次<code>Crash</code>对应的文件，就不能进行符号化；查看<code>dSYM</code>文件里面的<code>UUID</code>命令：<code>dwarfdump --uuid AppName.app.dSYM</code>；查看<code>Crash</code>文件文件的<code>UUID</code>就比较简单了，直接打开，<code>Crash</code>最上面的就是各种信息，不同系统版本给的格式可能会有不同，下图内容为参考<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.29.05.png" alt=""></li></ol><ul><li><code>Xcode</code>在<code>Debug</code>模式下默认关闭生成<code>dSYM</code>文件，<code>Release</code>模式下默认生成<code>dSYM</code>文件的， 要生成<code>dSYM</code>文件需要查看一下项目的<code>Build Settigns -&gt; Build Options -&gt; Debug information Format</code>属性；只有该属性设置为<code>DWARF with dSYM File</code>时，编译才会生成<code>dSYM</code>文件</li><li>该文是在<code>Xcode 11.2</code>和<code>iOS 13.2</code>上写的教程，不同的系统版本的<code>Xcode</code>和手机系统获取路径和符号化方式会有变化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;code&gt;Crash&lt;/code&gt;文件获取&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;大致可以分为两种方式：远程获取和本地获取；具体可以分为如下四种途径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.1. 远程获取；已经上传到&lt;code&gt;iTunes Connect&lt;/cod
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 时间日期总结</title>
    <link href="https://gsl201600.github.io/2020/04/22/iOS%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <id>https://gsl201600.github.io/2020/04/22/iOS时间日期总结/</id>
    <published>2020-04-22T07:12:00.000Z</published>
    <updated>2020-04-22T07:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>获取时间戳 </li></ol><ul><li>单位秒，保留六位有效数字，格式如：<code>1574068247.545103</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDate *datenow &#x3D; [NSDate date];</span><br><span class="line">NSString *timeSp &#x3D; [NSString stringWithFormat:@&quot;%f&quot;, (double)[datenow timeIntervalSince1970]];</span><br></pre></td></tr></table></figure></li><li>单位秒，整数，格式如：<code>1574068265</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDate *datenow &#x3D; [NSDate date];</span><br><span class="line">NSString *timeSp &#x3D; [NSString stringWithFormat:@&quot;%ld&quot;, (long)[datenow timeIntervalSince1970]];</span><br></pre></td></tr></table></figure></li><li>单位毫秒，整数，不精确，后面直接补三个<code>0</code>，格式如：<code>1574068602000</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDate *datenow &#x3D; [NSDate date];</span><br><span class="line">NSString *timeSp &#x3D; [NSString stringWithFormat:@&quot;%ld&quot;, (long)[datenow timeIntervalSince1970]*1000];</span><br></pre></td></tr></table></figure></li><li>单位毫秒，整数，精确，格式如：<code>1574070082387</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取当前时间0秒后的时间</span><br><span class="line">NSDate *date &#x3D; [NSDate dateWithTimeIntervalSinceNow:0];</span><br><span class="line">&#x2F;&#x2F; *1000 是精确到毫秒，不乘就是精确到秒</span><br><span class="line">NSTimeInterval time &#x3D; [date timeIntervalSince1970]*1000;</span><br><span class="line">NSString *timeStr &#x3D; [NSString stringWithFormat:@&quot;%.0f&quot;, time];</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>时间戳转日期<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传入的时间戳timeStr如果是精确到毫秒的记得要&#x2F;1000</span><br><span class="line">NSTimeInterval timeInterval &#x3D; [timeStr doubleValue]&#x2F;1000;</span><br><span class="line">NSDate *detailDate &#x3D; [NSDate dateWithTimeIntervalSince1970:timeInterval];</span><br><span class="line">NSDateFormatter *dateFormatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">&#x2F;&#x2F; 实例化一个NSDateFormatter对象，设定时间格式，这里可以设置成自己需要的格式</span><br><span class="line">[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss SS&quot;];</span><br><span class="line">NSString *dateStr &#x3D; [dateFormatter stringFromDate:detailDate];</span><br></pre></td></tr></table></figure></li><li>两个日期比较<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.将这两个时间戳转换成日期</span><br><span class="line">NSDate *date1 &#x3D; [NSDate dateWithTimeIntervalSince1970:1451047216];</span><br><span class="line">NSDate *date2 &#x3D; [NSDate dateWithTimeIntervalSince1970:1451847216];</span><br><span class="line">&#x2F;&#x2F;2.开始比较</span><br><span class="line">&#x2F;&#x2F; 比较date1是不是比date2早——&gt;会返回一个比较早的日期</span><br><span class="line">NSDate *date3 &#x3D; [date1 earlierDate:date2];</span><br><span class="line">NSLog(@&quot;比较早的日期：%@&quot;,date3);</span><br><span class="line">&#x2F;&#x2F;比较两个日期谁比谁晚</span><br><span class="line">NSDate *date4 &#x3D; [date1 laterDate:date2];</span><br><span class="line">NSLog(@&quot;比较晚的日期：%@&quot;,date4);</span><br><span class="line">&#x2F;&#x2F;  比较两个日期 是不是相同 ——&gt;返回值BOOL类型</span><br><span class="line">BOOL result &#x3D; [date1 isEqualToDate:date2];</span><br><span class="line">NSLog(@&quot;%d&quot;,result);</span><br></pre></td></tr></table></figure></li></ol><ul><li>可以解决跨年、跨月、平闰年时间处理问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 100天后</span><br><span class="line">NSDate *date &#x3D; [NSDate dateWithTimeIntervalSinceNow:60 * 60 * 24 * 100];</span><br><span class="line">NSDate *nowDate &#x3D; [NSDate date];</span><br><span class="line">&#x2F;&#x2F; 日期升序</span><br><span class="line">if ([nowDate compare:date] &#x3D;&#x3D; NSOrderedAscending) &#123;</span><br><span class="line">    NSLog(@&quot;如果打印，nowDate比ndate时间早，如nowDate&#x3D;2019-11-18， ndate&#x3D;2020-02-26&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>日历组件<code>NSCalendar</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSDate *nowDate &#x3D; [NSDate date];</span><br><span class="line">NSCalendar *calendar &#x3D; [NSCalendar currentCalendar];</span><br><span class="line">&#x2F;&#x2F; 初始化日历组件，可以选择需要的组件</span><br><span class="line">NSDateComponents *comps &#x3D; [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitWeekday|NSCalendarUnitWeekdayOrdinal|NSCalendarUnitWeekOfMonth|NSCalendarUnitWeekOfYear|NSCalendarUnitYearForWeekOfYear fromDate:nowDate];</span><br><span class="line">&#x2F;&#x2F; 得到：今天是星期几，返回日期的工作日索引（1 &#x3D;星期日，2 &#x3D;星期一，…，7 &#x3D;星期六）</span><br><span class="line">NSInteger weekDay &#x3D; [comps weekday];</span><br><span class="line">&#x2F;&#x2F; 得到：今天是几号</span><br><span class="line">NSInteger day &#x3D; [comps day];</span><br><span class="line">&#x2F;&#x2F; 得到：一年中的第几周</span><br><span class="line">NSInteger weekOfYear &#x3D; [comps weekOfYear];</span><br></pre></td></tr></table></figure></li><li>常见<code>NSDateFormatter</code>格式<br>可以使用以下<code>dateFormatter</code>符号单独格式化，拿到需要的数据进行处理</li></ol><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>y/yyy/yyyy/Y/YYY/YYYY/u/uu/uuu/uuuu/U/UUU/UUUU</code></td><td>完整的年份</td></tr><tr><td><code>yy/YY/UU</code></td><td>2个数字的年份</td></tr><tr><td><code>M/MM/L/LL</code></td><td>1~12 第几月</td></tr><tr><td><code>MMM/LLL</code></td><td>Jan/Feb/Mar/Apr/May/Jun/Jul/Aug/Sep/Oct/Nov/Dec 月份简写</td></tr><tr><td><code>MMMM/LLLL</code></td><td>January/February/March/April/May/June/July/August/September/October/November/December 月份全称</td></tr><tr><td><code>d</code></td><td>1~31 (月份的第几天，带0)</td></tr><tr><td><code>D</code></td><td>1~366 (年份的第几天，带0)</td></tr><tr><td><code>e/c/cc</code></td><td>1~7 (一周的第几天，周日为1，带0)</td></tr><tr><td><code>E~EEE/eee/ccc</code></td><td>Sun/Mon/Tue/Wed/Thu/Fri/Sat (星期简写)</td></tr><tr><td><code>EEEE/eeee/cccc</code></td><td>Sunday/Monday/Tuesday/Wednesday/Thursday/Friday/Saturday (星期全拼)</td></tr><tr><td><code>H</code></td><td>0~23 带0的时，24小时制</td></tr><tr><td><code>h</code></td><td>1~12 带0的时，12小时制</td></tr><tr><td><code>k</code></td><td>1~24 一天中的小时数，带0的时，24小时制</td></tr><tr><td><code>K</code></td><td>0~11 带0的时，12小时制</td></tr><tr><td><code>m</code></td><td>0~59 分钟</td></tr><tr><td><code>s</code></td><td>0~59 秒数</td></tr><tr><td><code>SSS</code></td><td>毫秒</td></tr><tr><td><code>a</code></td><td>AM/PM (上午/下午)</td></tr><tr><td><code>A</code></td><td>0~86399999 (一天的第几微秒)</td></tr><tr><td><code>F</code></td><td>1~5 每月的第几周</td></tr><tr><td><code>w</code></td><td>1~53 一年的第几周，一周的开始为周日，第一周从去年的最后一个周日起算</td></tr><tr><td><code>W</code></td><td>1~5 一个月的第几周，一周的开始为周日</td></tr><tr><td><code>q/qq/Q/QQ</code></td><td>1~4 第几季度</td></tr><tr><td><code>qqq/QQQ</code></td><td>Q1/Q2/Q3/Q4 季度简写</td></tr><tr><td><code>qqqq/QQQQ</code></td><td>1st quarter/2nd quarter/3rd quarter/4th quarter 季度全拼</td></tr><tr><td><code>z~zzz</code></td><td>指定GMT时区的缩写，GMT+8</td></tr><tr><td><code>zzzz/vvvv</code></td><td>指定GMT时区的名称，China Standard Time</td></tr><tr><td><code>Z~ZZZ</code></td><td>指定GMT时区的缩写，+0800</td></tr><tr><td><code>ZZZZ</code></td><td>指定GMT时区的缩写，GMT+08:00</td></tr><tr><td><code>v/VVVV</code></td><td>指定GMT时区的名称，China mainland Time</td></tr><tr><td><code>VV</code></td><td>指定GMT时区的名称，Asia/Shanghai</td></tr><tr><td><code>VVV</code></td><td>指定GMT时区的名称，Shanghai</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;获取时间戳 &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;单位秒，保留六位有效数字，格式如：&lt;code&gt;1574068247.545103&lt;/code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS + Mac PE + Win PE 三合一 U盘制作教程</title>
    <link href="https://gsl201600.github.io/2020/04/08/MacOS+MacPE+WinPE%E4%B8%89%E5%90%88%E4%B8%80U%E7%9B%98%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B/"/>
    <id>https://gsl201600.github.io/2020/04/08/MacOS+MacPE+WinPE三合一U盘制作教程/</id>
    <published>2020-04-08T07:59:00.000Z</published>
    <updated>2020-04-14T05:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>开始之前需要准备一下工具：</p><ul><li><code>移动硬盘</code>或者<code>U盘</code>一个</li><li><code>Mac OS</code>原版安装文件</li><li><code>Mac PE</code></li><li><code>Win PE</code></li><li><code>DiskGenius</code>分区工具</li></ul><ol><li><p><code>Win PE</code>制作<br>下载好<code>U盘魔术师V5全能版</code>或者<code>通用PE工具箱</code>等<code>Win PE</code>制作软件，安装到电脑打开，然后插入<code>U盘</code>；一般保持默认设置就行，<code>Win PE</code>制作完成。</p></li><li><p><code>Mac OS</code>分区制作<br>打开<code>DiskGenius</code>分区工具，找到刚刚制作好的<code>U盘</code>，然后选中这个<code>U盘分区</code>，右击菜单选中<code>调整分区大小</code>，如图：<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.08.01.png" alt=""></p></li></ol><p>打开调整窗口，把鼠标放在分区的右边，出现拖拉箭头，然后往左拉，或者在下方直接填写你要分的空间大小，如图：<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.08.02.png" alt=""></p><p><code>Mac OS</code>分区的空间一般<code>8.5G</code>，也可以设置更大，看个人。然后点击<code>开始</code>，弹出对话框，选中<code>是</code>；制作完成之后点击<code>完成</code>，就会出现空闲<code>8.5G</code>，如图：<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.08.03.png" alt=""></p><p>右击空闲的分区，选择<code>建立新分区</code>，选中<code>NTFS</code>格式，<code>4K对齐</code>，如图：<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.08.04.png" alt=""></p><p>选择<code>确定</code>，然后点击左上角的<code>保存更改</code>，提示你格式化分区，选择<code>是</code>，格式化完成之后，<code>8.5G</code>的<code>Mac OS</code>分区就制作好了。</p><ol start="3"><li>制作<code>Mac PE</code>分区，分<code>9G</code>以上；方法跟制作<code>Mac OS</code>分区是一样的，这里不再重复，如图：<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.08.05.png" alt=""></li></ol><p>分区基本做好了，现在转到苹果系统去写入系统文件。</p><ol start="4"><li>格式化两个<code>Mac</code>分区</li></ol><p>打开苹果电脑的<code>磁盘工具</code>，找到刚刚分出来的<code>9G</code>容量的分区，然后选择<code>抹掉</code>，名称为<code>Mac PE</code>，只为做区分用，可以随意命名；格式为<code>Mac OS扩展 日志式</code>；然后选择<code>8.5G</code>的<code>Mac OS</code>安装分区，步骤和上面一样，如图：<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.08.06.png" alt=""></p><ol start="5"><li><code>Mac PE</code>系统文件写入，打开下载好的<code>iFen.OS X PE</code>，解压的过程选择<code>跳过</code>，不跳过也行，目的是为了加载进磁盘工具里，回到<code>磁盘工具</code>的界面，会出现解压出来的镜像，然后选中<code>Mac PE</code>分区，选择菜单的<code>恢复</code>按钮，恢复来源选择刚刚解压出来的<code>PE镜像</code>，点击<code>恢复</code>，如图：<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.08.07.png" alt=""></li></ol><p><strong>注意：</strong><code>iFen.OS X PE</code>是基于<code>Mac OS 10.14</code>制作的，所以要用<code>Mac OS 10.14</code>的电脑才能恢复，否则会恢复失败，恢复过程的快慢就要看<code>U盘</code>的速度了，大概<code>5分钟</code>的时间。</p><ol start="6"><li><code>Mac OS</code>系统文件写入，以<code>Mac OS 10.14</code>系统为例，不同的系统制作代码不同，代码中的<code>MyVolume</code>为上面命名的<code>U盘名称</code>，下载好<code>Mac OS 10.14.1</code>系统，并把它放在<code>Mac的应用程序</code>里备用，打开<code>终端</code>，在终端输入代码：<code>sudo /Applications/Install\ macOS\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</code><br>等待制作完成，大概<code>5分钟</code>，完成之后；如图：<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.08.08.png" alt=""></li></ol><p>至此，整个三合一的启动盘制作完成了，三合一U盘电脑启动界面，如图：<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img2020/2020.04.08.09.png" alt=""></p><p><a href="https://www.applex.net/threads/mac-os-x-mac-pe-win-pe-u.92345">附：Mac OS X + Mac PE + Win PE 三合一 U盘制作教程</a><br><a href="https://support.apple.com/zh-cn/HT201372">附：[官方文档] 如何创建可引导的 macOS 安装器</a><br><a href="https://pan.baidu.com/s/1mGgc50GOZAaVsYbbHAjyHw">附：Mac PE下载地址 密码:6jkp</a><br><a href="https://www.applex.net/threads/mac-pe19.93480">附：最新版Mac PE</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开始之前需要准备一下工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;移动硬盘&lt;/code&gt;或者&lt;code&gt;U盘&lt;/code&gt;一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mac OS&lt;/code&gt;原版安装文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mac PE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://gsl201600.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>iOS 如何优化 App 的启动耗时</title>
    <link href="https://gsl201600.github.io/2020/04/01/iOS%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96App%E7%9A%84%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6/"/>
    <id>https://gsl201600.github.io/2020/04/01/iOS如何优化App的启动耗时/</id>
    <published>2020-04-01T08:14:00.000Z</published>
    <updated>2020-04-01T08:15:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS-的-App-启动时长大概可以这样计算："><a href="#iOS-的-App-启动时长大概可以这样计算：" class="headerlink" title="iOS 的 App 启动时长大概可以这样计算："></a>iOS 的 App 启动时长大概可以这样计算：</h3><ul><li>t(<code>App 总启动时间</code>) = t1(<code>main 调用之前的加载时间</code>) + t2(<code>main 调用之后的加载时间</code>)</li><li>t1 = <code>系统 dylib(动态链接库)</code>和<code>自身 App 可执行文件的加载</code></li><li>t2 = <code>main</code>方法执行之后到<code>AppDelegate</code>类中的<code>application:didFinishLaunchingWithOptions:</code>方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示</li></ul><ol><li>在<code>t1</code>阶段加快<code>App</code>启动的建议：</li></ol><ul><li>尽量使用静态库，减少动态库的使用，动态链接比较耗时，如果要用动态库，尽量将多个<code>dylib</code>动态库合并成一个</li><li>尽量避免对系统库使用<code>optional linking</code>，如果<code>App</code>用到的系统库在你所有支持的系统版本上都有，就设置为<code>required</code>，因为<code>optional</code>会有些额外的检查</li><li>减少<code>Objective-C Class、Selector、Category</code>的数量，可以合并或者删减一些<code>OC</code>类</li><li>删减一些无用的静态变量，删减没有被调用到或者已经废弃的方法</li><li>将不必须在<code>+load</code>中做的事情尽量挪到<code>+initialize</code>中，<code>+initialize</code>是在第一次初始化这个类之前被调用，<code>+load</code>在加载类的时候就被调用。尽量将<code>+load</code>里的代码延后调用</li><li>尽量不要用<code>C++</code>虚函数，创建虚函数表有开销</li><li>不要使用<code>__attribute__((constructor))</code>将方法显式标记为初始化器，而是让初始化方法调用时才执行。比如使用<code>dispatch_once()，pthread_once()或 std::once()</code></li><li>在初始化方法中不调用<code>dlopen()，dlopen()</code>有性能和死锁的可能性</li><li>在初始化方法中不创建线程</li></ul><ol start="2"><li>在<code>t2</code>阶段加快<code>App</code>启动的建议：</li></ol><ul><li>尽量不要使用<code>xib/storyboard</code>，而是用纯代码作为首页<code>UI</code>，如果要用<code>xib/storyboard</code>，不要在<code>xib/storyboard</code>中存放太多的视图</li><li>对<code>application:didFinishLaunchingWithOptions:</code>里的任务尽量延迟加载或懒加载</li><li>不要在<code>NSUserDefaults</code>中存放太多的数据，<code>NSUserDefaults</code>是一个<code>plist</code>文件，<code>plist</code>文件会被反序列化一次</li><li>避免在启动时打印过多的<code>log</code>，少用<code>NSLog</code>，因为每一次<code>NSLog</code>的调用都会创建一个新的<code>NSCalendar</code>实例</li><li>为了防止使用<code>GCD</code>创建过多的线程，解决方法是创建串行队列，或者使用带有最大并发数限制的<code>NSOperationQueue</code></li><li>不要在主线程执行<code>磁盘、网络、Lock或者dispatch_sync、发送消息给其他线程</code>等操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iOS-的-App-启动时长大概可以这样计算：&quot;&gt;&lt;a href=&quot;#iOS-的-App-启动时长大概可以这样计算：&quot; class=&quot;headerlink&quot; title=&quot;iOS 的 App 启动时长大概可以这样计算：&quot;&gt;&lt;/a&gt;iOS 的 App 启动时长大概可
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS RunLoop</title>
    <link href="https://gsl201600.github.io/2020/01/17/iOSRunLoop/"/>
    <id>https://gsl201600.github.io/2020/01/17/iOSRunLoop/</id>
    <published>2020-01-17T06:57:00.000Z</published>
    <updated>2020-01-17T06:57:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RunLoop概念"><a href="#RunLoop概念" class="headerlink" title="RunLoop概念"></a>RunLoop概念</h3><ul><li><code>RunLoop</code>是通过内部维护的<code>事件循环(Event Loop)</code>来对<code>事件/消息</code>进行管理的一个对象</li><li>没有消息处理时，休眠以避免资源占用；有消息需要处理时，立刻被唤醒</li></ul><ol><li>为什么<code>main</code>函数不会退出<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>UIApplicationMain</code>内部默认开启了主线程的<code>RunLoop</code>，并执行了一段无限循环的代码（不是简单的<code>for循环</code>或<code>while循环</code>）<code>UIApplicationMain</code>函数一直没有返回，不断地接收处理消息以及等待休眠，所以运行程序之后，会保持持续运行状态</li></ol><h3 id="RunLoop结构体"><a href="#RunLoop结构体" class="headerlink" title="RunLoop结构体"></a>RunLoop结构体</h3><ul><li><code>Source1</code> : 基于<code>Port</code>的线程间通信</li><li><code>Source0</code> : 触摸事件、<code>PerformSelector</code></li><li><code>Timer</code> : 定时器</li><li><code>Observer</code> : 监听器，用于监听<code>RunLoop</code>的状态</li></ul><h3 id="RunLoop和线程"><a href="#RunLoop和线程" class="headerlink" title="RunLoop和线程"></a>RunLoop和线程</h3><ul><li>线程和<code>RunLoop</code>是一一对应的，其映射关系是保存在一个全局的<code>Dictionary</code>里，线程作为<code>key</code>，<code>RunLoop</code>作为<code>value</code></li><li>自己创建的线程默认是没有开启<code>RunLoop</code>的</li><li><code>runloop</code>在第一次获取时被创建，在线程结束时被销毁</li><li>对于主线程来说，<code>runloop</code>在程序一启动就默认创建好了</li><li>对于子线程来说，<code>runloop</code>是懒加载的，只有当我们使用的时候才会创建，所以在子线程用定时器要注意：确保子线程的<code>runloop</code>被创建，不然定时器不会回调</li></ul><ol><li>怎么创建一个常驻线程</li></ol><ul><li>为当前线程开启一个<code>RunLoop</code>（第一次调用<code>[NSRunLoop currentRunLoop]</code>方法时，实际是会先去创建一个<code>RunLoop</code>）</li><li>向当前<code>RunLoop</code>中添加一个<code>Port/Source</code>等维持<code>RunLoop</code>的事件循环（如果<code>RunLoop</code>的<code>mode</code>中一个<code>item</code>都没有，<code>RunLoop</code>会退出）</li><li>启动该<code>RunLoop</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">  NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">  [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">  [runLoop run];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>输出下边代码的执行顺序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;1&quot;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">  NSLog(@&quot;2&quot;);</span><br><span class="line">  [self performSelector:@selector(test) withObject:nil afterDelay:10];</span><br><span class="line">  NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;4&quot;);</span><br><span class="line"></span><br><span class="line">- (void)test&#123;</span><br><span class="line">  NSLog(@&quot;5&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>答案是<code>1423</code>，<code>test</code>方法并不会执行<br>原因是：如果是带<code>afterDelay</code>的延时函数，会在内部创建一个<code>NSTimer</code>，然后添加到当前线程的<code>RunLoop</code>中，也就是如果当前线程没有开启<code>RunLoop</code>，该方法会失效<br>那么我们改成:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">  NSLog(@&quot;2&quot;);</span><br><span class="line">  [[NSRunLoop currentRunLoop] run];</span><br><span class="line">  [self performSelector:@selector(test) withObject:nil afterDelay:10];</span><br><span class="line">  NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><code>test</code>方法依然不执行<br>原因是：如果<code>RunLoop</code>的<code>mode</code>中一个<code>item</code>都没有，<code>RunLoop</code>会退出<br>即在调用<code>RunLoop</code>的<code>run</code>方法后，由于其<code>mode</code>中没有添加任何<code>item</code>去维持<code>RunLoop</code>的事件循环，<code>RunLoop</code>随即还是会退出，所以我们自己启动<code>RunLoop</code>，一定要在添加<code>item</code>后<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">  NSLog(@&quot;2&quot;);</span><br><span class="line">  [self performSelector:@selector(test) withObject:nil afterDelay:10];</span><br><span class="line">  [[NSRunLoop currentRunLoop] run];</span><br><span class="line">  NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;RunLoop概念&quot;&gt;&lt;a href=&quot;#RunLoop概念&quot; class=&quot;headerlink&quot; title=&quot;RunLoop概念&quot;&gt;&lt;/a&gt;RunLoop概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RunLoop&lt;/code&gt;是通过内部维护的&lt;code&gt;事件
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 多线程相关之performSelector、死锁</title>
    <link href="https://gsl201600.github.io/2020/01/08/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%B9%8BperformSelector/"/>
    <id>https://gsl201600.github.io/2020/01/08/iOS多线程相关之performSelector/</id>
    <published>2020-01-08T09:28:00.000Z</published>
    <updated>2020-01-08T09:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>performSelector</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在当前线程延迟1s执行，响应了OC语言的动态性：延迟到运行时才绑定方法</span><br><span class="line">[self performSelector:@selector(aaa) withObject:nil afterDelay:1];</span><br><span class="line">&#x2F;&#x2F; 回到主线程，waitUntilDone:是否将该回调方法执行完再执行后面的代码</span><br><span class="line">&#x2F;&#x2F; 如果为YES：就必须等回调方法执行完成之后才能执行后面的代码，说白了就是阻塞当前的线程</span><br><span class="line">&#x2F;&#x2F; 如果是NO：就是不等回调方法结束，不会阻塞当前线程</span><br><span class="line">[self performSelectorOnMainThread:@selector(aaa) withObject:nil waitUntilDone:YES];</span><br><span class="line">&#x2F;&#x2F; 开辟子线程</span><br><span class="line">[self performSelectorInBackground:@selector(aaa) withObject:nil];</span><br><span class="line">&#x2F;&#x2F;在指定线程执行</span><br><span class="line">[self performSelector:@selector(aaa) onThread:[NSThread currentThread] withObject:nil waitUntilDone:YES];</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>需要注意的是：</strong>如果是带<code>afterDelay</code>的延时函数，会在内部创建一个<code>NSTimer</code>，然后添加到当前线程的<code>Runloop</code>中。也就是如果当前线程没有开启<code>runloop</code>，该方法会失效。在子线程中，需要启动<code>runloop</code>(注意调用顺序)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(aaa) withObject:nil afterDelay:1];</span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br></pre></td></tr></table></figure></li><li><code>performSelector:withObject:</code>只是一个单纯的消息发送，和时间没有一点关系。所以不需要添加到子线程的<code>Runloop</code>中也能执行</li><li>下面代码片段的<code>test</code>方法会去执行吗？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">  [self performSelector:@selector(test:) withObject:nil afterDelay:0];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>这里的<code>test</code>方法是不会去执行的，原因在于<code>- (void)performSelector: withObject: afterDelay:</code>这个方法要创建提交任务到<code>runloop</code>上的，而<code>gcd</code>底层创建的线程是默认没有开启对应<code>runloop</code>的，所有这个方法就会失效。<br>而如果将<code>dispatch_get_global_queue</code>改成主队列，由于主队列所在的主线程是默认开启了<code>runloop</code>的，就会去执行(将<code>dispatch_async</code>改成同步，因为同步是在当前线程执行，那么如果当前线程是主线程，<code>test</code>方法也是会去执行的)</li></ul><ol start="2"><li>死锁</li></ol><ul><li>死锁就是队列引起的循环等待，一个比较常见的死锁例子:主队列同步<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line">  dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;deallock&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在主线程中运用主队列同步，也就是把任务放到了主线程的队列中。同步对于任务是立刻执行的，那么当把任务放进主队列时，它就会立马执行，只有执行完这个任务，<code>viewDidLoad</code>才会继续向下执行。而<code>viewDidLoad</code>和任务都是在主队列上的，由于队列的<code>先进先出</code>原则，任务又需等待<code>viewDidLoad</code>执行完毕后才能继续执行，<code>viewDidLoad</code>和这个任务就形成了相互循环等待，就造成了死锁。<br>想避免这种死锁，可以将同步改成异步<code>dispatch_async</code>或者将<code>dispatch_get_main_queue</code>换成其他串行或并行队列，都可以解决</li><li>同样，下边的代码也会造成死锁：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">  dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;deadlock&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>外面的函数无论是同步还是异步都会造成死锁。这是因为里面的任务和外面的任务都在同一个<code>serialQueue</code>队列内，又是同步，这就和上边主队列同步的例子一样造成了死锁。<br>解决方法也和上边一样，将里面的同步改成异步<code>dispatch_async</code>或者将<code>serialQueue</code>换成其他串行或并行队列，都可以解决</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;code&gt;performSelector&lt;/code&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中事件的响应链和传递链</title>
    <link href="https://gsl201600.github.io/2019/12/25/iOS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94%E9%93%BE%E5%92%8C%E4%BC%A0%E9%80%92%E9%93%BE/"/>
    <id>https://gsl201600.github.io/2019/12/25/iOS中事件的响应链和传递链/</id>
    <published>2019-12-25T08:48:00.000Z</published>
    <updated>2020-04-14T06:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS事件链有两条：事件的响应链；<code>Hit-Testing</code>事件的传递链</p><ul><li>响应链：由离用户最近的<code>view</code>向系统传递。<code>initial view</code> –&gt; <code>super view</code> –&gt; ….. –&gt; <code>view controller</code> –&gt; <code>window</code> –&gt; <code>Application</code> –&gt; <code>AppDelegate</code></li><li>传递链：由系统向离用户最近的view传递。<code>UIKit</code> –&gt; <code>active app&#39;s event queue</code> –&gt; <code>window</code> –&gt; <code>root view</code> –&gt; …… –&gt; <code>lowest view</code> </li></ul><p>在iOS中只有继承<code>UIResponder</code>的对象才能够接收并处理事件，<code>UIResponder</code>是所有响应对象的基类，在<code>UIResponder</code>类中定义了处理上述各种事件的接口。我们熟悉的<code>UIApplication、UIViewController、UIWindow</code>和所有继承自<code>UIView</code>的<code>UIKit</code>类都直接或间接的继承自<code>UIResponder</code>，所以它们的实例都是可以构成响应者链的响应者对象，首先我们通过一张图来简单了解一下事件的传递以及响应<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.12.25.01.png" alt=""></p><ol><li>传递链</li></ol><ul><li>事件传递的两个核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;   &#x2F;&#x2F; recursively calls -pointInside:withEvent:. point is in the receiver&#39;s coordinate system</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;   &#x2F;&#x2F; default returns YES if point is in bounds</span><br></pre></td></tr></table></figure></li><li>第一个方法返回的是一个UIView，是用来寻找最终哪一个视图来响应这个事件</li><li>第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES</li><li>其中UIView不接受事件处理的情况有<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. alpha &lt;0.01</span><br><span class="line">2. userInteractionEnabled &#x3D; NO</span><br><span class="line">3. hidden ＝ YES</span><br></pre></td></tr></table></figure></li><li><p>事件传递的流程图<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.12.25.02.png" alt=""></p></li><li><p>流程描述</p><blockquote><ol><li>我们点击屏幕产生触摸事件，系统将这个事件加入到一个由<code>UIApplication</code>管理的事件队列中，<code>UIApplication</code>会从消息队列里取事件分发下去，首先传给<code>UIWindow</code></li><li>在<code>UIWindow</code>中就会调用<code>hitTest:withEvent:</code>方法去返回一个最终响应的视图</li><li>在<code>hitTest:withEvent:</code>方法中就会去调用<code>pointInside: withEvent:</code>去判断当前点击的<code>point</code>是否在<code>UIWindow</code>范围内，如果是的话，就会去遍历它的子视图来查找最终响应的子视图</li><li>遍历的方式是使用倒序的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都回去调用它的<code>hitTest:withEvent:</code>方法，可以理解为是一个递归调用</li><li>最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将<code>UIWindow</code>作为响应者</li></ol></blockquote></li></ul><ol start="2"><li>响应链</li></ol><ul><li><p>响应者链流程图<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.12.25.03.png" alt=""></p></li><li><p>响应者链的事件传递过程总结如下</p><blockquote><ol><li>如果<code>view</code>的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的父视图</li><li>在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给<code>UIWindow</code>对象进行处理</li><li>如果<code>UIWindow</code>对象也不处理，则将事件传递给<code>UIApplication</code>对象</li><li>如果<code>UIApplication</code>也不能处理该事件，则将该事件丢弃</li></ol></blockquote></li></ul><ol start="3"><li>实例场景</li></ol><ul><li>在一个方形按钮中点击中间的圆形区域有效，而点击四角无效</li><li>核心思想是在<code>pointInside: withEvent:</code>方法中修改对应的区域<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.12.25.04.png" alt=""></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果控件不允许与用用户交互,那么返回nil</span><br><span class="line">    if (!self.userInteractionEnabled || [self isHidden] || self.alpha &lt;&#x3D; 0.01) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断当前视图是否在点击范围内</span><br><span class="line">    if ([self pointInside:point withEvent:event]) &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历当前对象的子视图(倒序)</span><br><span class="line">        __block UIView *hit &#x3D; nil;</span><br><span class="line">        [self.subviews enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            &#x2F;&#x2F;坐标转换，把当前坐标系上的点转换成子控件坐标系上的点</span><br><span class="line">            CGPoint convertPoint &#x3D; [self convertPoint:point toView:obj];</span><br><span class="line">            &#x2F;&#x2F;调用子视图的hitTest方法，判断自己的子控件是不是最适合的View</span><br><span class="line">            hit &#x3D; [obj hitTest:convertPoint withEvent:event];</span><br><span class="line">            &#x2F;&#x2F;如果找到了就停止遍历</span><br><span class="line">            if (hit) *stop &#x3D; YES;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;返回当前的视图对象</span><br><span class="line">        return hit?hit:self;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 该方法判断触摸点是否在控件身上，是则返回YES，否则返回NO，point参数必须是方法调用者的坐标系</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123;   </span><br><span class="line">    CGFloat x1 &#x3D; point.x;</span><br><span class="line">    CGFloat y1 &#x3D; point.y;</span><br><span class="line">    </span><br><span class="line">    CGFloat x2 &#x3D; self.frame.size.width &#x2F; 2;</span><br><span class="line">    CGFloat y2 &#x3D; self.frame.size.height &#x2F; 2;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;判断是否在圆形区域内</span><br><span class="line">    double dis &#x3D; sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">    if (dis &lt;&#x3D; self.frame.size.width &#x2F; 2) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS事件链有两条：事件的响应链；&lt;code&gt;Hit-Testing&lt;/code&gt;事件的传递链&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应链：由离用户最近的&lt;code&gt;view&lt;/code&gt;向系统传递。&lt;code&gt;initial view&lt;/code&gt; –&amp;gt; &lt;code&gt;supe
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>一周年快乐</title>
    <link href="https://gsl201600.github.io/2019/12/25/hello-world1/"/>
    <id>https://gsl201600.github.io/2019/12/25/hello-world1/</id>
    <published>2019-12-24T16:00:00.000Z</published>
    <updated>2019-12-25T09:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年这个时候发布了我的第一篇博文 — Hello World<br>转眼已经写了一年了<br>物是人非，感慨良多<br>不管怎样我还是会继续坚持下去的，加油…<br>圣诞节快乐…<br>我的博客上线运行中…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年这个时候发布了我的第一篇博文 — Hello World&lt;br&gt;转眼已经写了一年了&lt;br&gt;物是人非，感慨良多&lt;br&gt;不管怎样我还是会继续坚持下去的，加油…&lt;br&gt;圣诞节快乐…&lt;br&gt;我的博客上线运行中…&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 面试题-2019.上</title>
    <link href="https://gsl201600.github.io/2019/12/18/iOS%E9%9D%A2%E8%AF%95%E9%A2%982019%E4%B8%8A/"/>
    <id>https://gsl201600.github.io/2019/12/18/iOS面试题2019上/</id>
    <published>2019-12-18T08:04:00.000Z</published>
    <updated>2020-04-14T06:34:47.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><code>UIView</code>和<code>CALayer</code>是什么关系</p><blockquote><ul><li><code>UIView</code>继承自<code>UIResponder</code>类，可以响应事件</li><li><code>CALayer</code>直接继承自<code>NSObject</code>类，不可以响应事件</li><li><code>UIView</code>是<code>CALayer</code>的<code>delegate</code>(<code>CALayerDelegate</code>)</li><li><code>UIView</code>主要处理事件，<code>CALayer</code>负责绘制</li><li>每个<code>UIView</code>内部都有一个<code>CALayer</code>在背后提供内容的绘制和显示，并且<code>UIView</code>的尺寸样式都由内部的<code>Layer</code>所提供。两者都有树状层级结构，<code>Layer</code>内部有<code>SubLayers</code>，<code>View</code>内部有<code>SubViews</code>，但是<code>Layer</code>比<code>View</code>多了个<code>AnchorPoint</code></li></ul></blockquote></li><li><p><code>NSCache</code>和<code>NSMutableDictionary</code>的相同点与区别</p><blockquote><p>相同点：<br><code>NSCache</code>和<code>NSMutableDictionary</code>功能用法基本是相同的<br>区别：<br><code>NSCache</code>是线程安全的，<code>NSMutableDictionary</code>线程不安全，<code>Mutable开发的类</code>一般都是线程不安全的<br>当内存不足时<code>NSCache</code>会自动释放内存(所以从缓存中取数据的时候总要判断是否为空)<br><code>NSCache</code>可以指定缓存的限额，当缓存超出限额自动释放内存<br><code>NSCache</code>的<code>Key</code>只是对对象进行了<code>Strong</code>引用，而非拷贝，所以不需要实现<code>NSCopying</code>协议</p></blockquote></li><li><p><code>atomic</code>的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）</p><blockquote><ul><li><code>atomic</code>会对属性的<code>setter/getter</code>方法进行加锁，这仅仅只能保证在操作<code>setter/getter</code>方法是安全的。不能保证其他线程的安全</li><li>例如：线程1调用了某一属性的<code>setter</code>方法并进行到了一半，线程2调用其<code>getter</code>方法，那么会执行完<code>setter</code>操作后，再执行<code>getter</code>操作，线程2会获取到线程1<code>setter</code>后的完整的值；当几个线程同时调用同一属性的<code>setter、getter</code>方法时，会获取到一个完整的值，但获取到的值不可控</li></ul></blockquote></li><li><p>iOS 中内省的几个方法</p><blockquote><p>对象在运行时获取其类型的能力称为内省。内省可以有多种方法实现<br>OC运行时内省的4个方法：</p></blockquote></li></ol><ul><li>判断对象类型：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL) isKindOfClass:            &#x2F;&#x2F; 判断是否是这个类或者这个类的子类的实例</span><br><span class="line">-(BOOL) isMemberOfClass:      &#x2F;&#x2F; 判断是否是这个类的实例</span><br></pre></td></tr></table></figure></li><li>判断对象/类是否有这个方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL) respondsToSelector:                      &#x2F;&#x2F; 判断实例是否有这样方法</span><br><span class="line">+(BOOL) instancesRespondToSelector:      &#x2F;&#x2F; 判断类是否有这个方法</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><p><code>objc</code>在向一个对象发送消息时，发生了什么</p><blockquote><p>根据对象的isa指针找到该对象所属的类，去objc的对应的类中找方法<br>1.首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行<br>2.如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行<br>3.如果没找到，去父类指针所指向的对象中执行1，2.<br>4.以此类推，如果一直到根类还没找到，转向拦截调用，走消息转发机制<br>5.如果没有重写拦截调用的方法，程序报错</p></blockquote></li><li><p>你是否接触过OC中的反射机制？简单聊一下概念和使用</p></li></ol><ul><li><code>class</code>反射</li><li>通过类名的字符串形式实例化对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class class &#x3D; NSClassFromString(@&quot;student&quot;); </span><br><span class="line">Student *stu &#x3D; [[class alloc] init];</span><br></pre></td></tr></table></figure></li><li>将类名变为字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class class &#x3D; [Student class];</span><br><span class="line">NSString *className &#x3D; NSStringFromClass(class);</span><br></pre></td></tr></table></figure></li><li><code>SEL</code>的反射</li><li>通过方法的字符串形式实例化方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEL selector &#x3D; NSSelectorFromString(@&quot;setName&quot;);</span><br><span class="line">[stu performSelector:selector withObject:@&quot;Mike&quot;];</span><br></pre></td></tr></table></figure></li><li>将方法变成字符串<br><code>NSStringFromSelector(@selector(setName:));</code></li></ul><ol start="7"><li><p>这个写法会出什么问题<code>@property (nonatomic, copy) NSMutableArray *arr;</code></p><blockquote><p>添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。原因：是因为<code>copy</code>就是复制一个不可变<code>NSArray</code>的对象，不能对<code>NSArray</code>对象进行添加/修改</p></blockquote></li><li><p>如何让自己的类用<code>copy</code>修饰符</p><blockquote><p>若想令自己所写的对象具有拷贝功能，则需实现<code>NSCopying</code>协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现<code>NSCopying</code>与<code>NSMutableCopying</code>协议。<br>具体步骤：<br>1.需声明该类遵从<code>NSCopying</code>协议<br>2.实现<code>NSCopying</code>协议的方法，具体区别<a href="http://www.jianshu.com/p/f84803356cbb">戳这里</a></p></blockquote></li></ol><ul><li><code>NSCopying</code>协议方法为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">  MyObject *copy &#x3D; [[[self class] allocWithZone: zone] init];</span><br><span class="line">  copy.username &#x3D; self.username;</span><br><span class="line">  return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li><p>为什么<code>assign</code>不能用于修饰对象</p><blockquote><p>首先我们需要明确，对象的内存一般被分配到堆上，基本数据类型和oc数据类型的内存一般被分配在栈上<br>如果用<code>assign</code>修饰对象，当对象被释放后，指针的地址还是存在的，也就是说指针并没有被置为<code>nil</code>，从而造成了野指针。因为对象是分配在堆上的，堆上的内存由程序员分配释放。而因为指针没有被置为<code>nil</code>，如果后续的内存分配中，刚好分配到了这块内存，就会造成崩溃<br>而<code>assign</code>修饰基本数据类型或oc数据类型，因为基本数据类型是分配在栈上的，由系统分配和释放，所以不会造成野指针</p></blockquote></li><li><p>请写出以下代码输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int *ptr &#x3D; (int *)(&amp;a + 1);</span><br><span class="line">printf(&quot;%d, %d&quot;, *(a + 1), *(ptr + 1));</span><br></pre></td></tr></table></figure><blockquote><p>参考答案：2，随机值<br>分析：<br><code>a</code>代表有5个元素的数组的首地址，<code>a[5]</code>的元素分别是1，2，3，4，5。接下来，<code>a + 1</code>表示数据首地址加1，那么就是<code>a[1]</code>，也就是对应于值为2，但是，这里是<code>&amp;a + 1</code>，因为<code>a</code>代表的是整个数组，它的空间大小为<code>5 * sizeof(int)</code>，因此<code>&amp;a + 1</code>就是<code>a + 5</code>。<code>a</code>是个常量指针，指向当前数组的首地址，指针+1就是移动<code>sizeof(int)</code>个字节<br>因此，<code>ptr</code>是指向<code>int *</code>类型的指针，而<code>ptr</code>指向的就是<code>a + 5</code>，那么<code>ptr + 1</code>也相当于<code>a + 6</code>，所以最后的<code>*(ptr + 1)</code>就是一个随机值了。而<code>*(ptr – 1)</code>就相当于<code>a + 4</code>，对应的值就是5</p></blockquote></li><li><p>一个<code>view</code>已经初始化完毕，<code>view</code>上面添加了n个<code>button</code>（可能使用循环创建），除用<code>view</code>的<code>tag</code>之外，还可以采用什么办法来找到自己想要的<code>button</code>来修改<code>Button</code>的值</p><blockquote><p>第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可<br>第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找</p></blockquote></li><li><p><code>UIViewController</code>的<code>viewDidUnload、viewDidLoad</code>和<code>loadView</code>分别什么时候调用？<code>UIView</code>的<code>drawRect</code>和<code>layoutSubviews</code>分别起什么作用</p><blockquote><p>第一个问题：<br>在控制器被销毁前会调用<code>viewDidUnload</code>（<code>MRC</code>下才会调用）<br>在控制器没有任何<code>view</code>时，会调用<code>loadView</code><br>在<code>view</code>加载完成时，会调用<code>viewDidLoad</code><br>第二个问题：<br>在调用<code>setNeedsDisplay</code>后，会调用<code>drawRect</code>方法，我们通过在此方法中可以获取到<code>context</code>（设置上下文），就可以实现绘图<br>在调用<code>setNeedsLayout</code>后，会调用<code>layoutSubviews</code>方法，我们可以通过在此方法去调整UI。当然能引起<code>layoutSubviews</code>调用的方式有很多种的，比如添加子视图、滚动<code>scrollview</code>、修改视图的<code>frame</code>等</p></blockquote></li><li><p>自动释放池工作原理</p><blockquote><p>自动释放池是<code>NSAutorelease</code>类的一个实例，当向一个对象发送<code>autorelease</code>消息时，该对象会自动入池，待池销毁时，将会向池中所有对象发送一条<code>release</code>消息，释放对象<br><code>[pool release]、[pool drain]</code>表示的是池本身不会销毁，而是池子中的临时对象都被发送<code>release</code>，从而将对象销毁</p></blockquote></li><li><p>苹果是如何实现<code>autoreleasepool</code>的</p><blockquote><p><code>autoreleasepool</code>是由<code>AutoreleasePoolPage</code>以双向链表的方式实现的，主要通过下列三个函数完成：</p><ul><li>由<code>objc_autoreleasePoolPush</code>作为自动释放池作用域的第一个函数</li><li>使用<code>objc_autorelease</code>将对象加入自动释放池</li><li>由<code>objc_autoreleasePoolPop</code>作为自动释放池作用域的最后一个函数</li></ul></blockquote></li><li><p><code>autorelease</code>的对象何时被释放</p><blockquote><p><code>RunLoop</code>在每个事件循环结束后会去自动释放池将所有自动释放对象的引用计数减一，若引用计数变成了0，则会将对象真正销毁掉，回收内存。<br>在没有手动添加<code>Autorelease Pool</code>的情况下，<code>autorelease</code>的对象是在每个事件循环结束后，自动释放池才会对所有自动释放的对象的引用计数减一，若引用计数变成了0，则释放对象，回收内存。因此，若想要早一点释放掉<code>autorelease</code>对象，那么我们可以在对象外加一个自动释放池。比如，在循环处理数据时，临时变量要快速释放，就应该采用这种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过alloc创建的对象，直接加入@autoreleasepool没有作用，需在创建对象后面显式添加autorelease</span><br><span class="line">&#x2F;&#x2F; 通过类方法创建的对象不需要显式添加autorelease，原因是类方法创建的对象系统会自动添加autorelease</span><br><span class="line">for (int i &#x3D; 0; i &lt; 1000000; i++) &#123;</span><br><span class="line">  @autoreleasepool &#123;</span><br><span class="line">    NSString *str &#x3D; @&quot;Abc&quot;;</span><br><span class="line">    str &#x3D; [str lowercaseString];</span><br><span class="line">    str &#x3D; [str stringByAppendingString:@&quot;xyz&quot;];</span><br><span class="line">    NSLog(@&quot;%@&quot;, str);</span><br><span class="line">  &#125; &#x2F;&#x2F; 出了这里，就会去遍历该自动释放池了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>简述内存管理基本原则</p><blockquote><p>OC内存管理遵循<code>谁创建，谁释放，谁引用，谁管理</code>的机制，当使用<code>alloc、copy(mutableCopy)或者retian</code>一个对象时，你就有义务向它发送一条<code>release或者autorelease</code>消息释放该对象，其他方法创建的对象，不需要由你来管理内存，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（<code>MRC</code>）<br>向一个对象发送一条<code>autorelease</code>消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池中每一个对象发送一条<code>release</code>消息，以此来释放对象<br>向一个对象发送<code>release</code>消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用<code>dealloc</code>方法释放该对象和对象本身所拥有的实例</p></blockquote></li><li><p><code>sizeof</code>关键字</p><blockquote><p><code>sizeof</code>是在编译阶段处理，且不能被编译为机器码。<code>sizeof</code>的结果等于对象或类型所占的内存字节数。<code>sizeof</code>的返回值类型为<code>size_t</code><br>变量：<code>int a;  sizeof(a)</code>为4；<br>指针：<code>int *p;  sizeof(p)</code>为4；<br>数组：<code>int b[10]; sizeof(b)</code>为数组的大小4<em>10；<code>int c[0]; sizeof(c)</code>等于0<br><code>sizeof(void)</code>等于1<br>`sizeof(void </em>)`等于4</p></blockquote></li><li><p>什么是离屏渲染？什么情况下会触发？离屏渲染消耗性能的原因</p><blockquote><p>离屏渲染就是在当前屏幕缓冲区以外，新开辟一个缓冲区进行操作<br>离屏渲染触发的场景有以下：</p><ul><li>圆角（同时设置<code>layer.masksToBounds = YES、layer.cornerRadius</code>大于0）</li><li>图层蒙版</li><li>阴影，<code>layer.shadowXXX</code>，如果设置了<code>layer.shadowPath</code>就不会产生离屏渲染</li><li>遮罩，<code>layer.mask</code></li><li>光栅化，<code>layer.shouldRasterize = YES</code></li></ul></blockquote></li></ol><blockquote><p>离屏渲染消耗性能的原因<br>需要创建新的缓冲区，离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（<code>On-Screen</code>）切换到离屏（<code>Off-Screen</code>）等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕</p></blockquote><ol start="19"><li><p>ARC 下，不显式指定任何属性关键字时，默认的关键字都有哪些</p><blockquote><p>基本数据类型默认关键字是：<code>atomic, readwrite, assign</code><br>普通<code>Objective-C</code>对象默认关键字是：<code>atomic, readwrite, strong</code></p></blockquote></li><li><p>OC中的类方法和实例方法有什么本质区别和联系</p><blockquote><p>类方法：</p><ul><li>类方法是属于类对象的</li><li>类方法只能通过类对象调用</li><li>类方法中的 self 是类对象</li><li>类方法可以调用其他的类方法</li><li>类方法中不能访问成员变量</li><li>类方法中不能直接调用对象方法</li></ul></blockquote></li></ol><blockquote><p>实例方法：</p><ul><li>实例方法是属于实例对象的</li><li>实例方法只能通过实例对象调用</li><li>实例方法中的 self 是实例对象</li><li>实例方法中可以访问成员变量</li><li>实例方法中直接调用实例方法</li><li>实例方法中也可以调用类方法（通过类名）</li></ul></blockquote><ol start="21"><li><p>能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</p><blockquote><ul><li>不能向编译后得到的类中增加实例变量</li><li>能向运行时创建的类中添加实例变量</li><li>因为编译后的类已经注册在<code>runtime</code>中，类结构体中的<code>objc_ivar_list</code>实例变量的链表和<code>instance_size</code>实例变量的内存大小已经确定，同时<code>runtime</code>会调用<code>class_setIvarLayout</code>或<code>class_setWeakIvarLayout</code>来处理<code>strong weak</code>引用，所以不能向存在的类中添加实例变量<br>运行时创建的类是可以添加实例变量，调用<code>class_addIvar</code>函数。但是得在调用<code>objc_allocateClassPair</code>之后，<code>objc_registerClassPair</code>之前，原因同上</li></ul></blockquote></li><li><p><code>runtime</code>如何通过<code>selector</code>找到对应的<code>IMP</code>地址（分别考虑实例方法和类方法）<code>Selector、Method 和 IMP</code>的有什么区别与联系</p><blockquote><p>对于实例方法，每个实例的<code>isa</code>指针指向着对应类对象，而每一个类对象中都有一个对象方法列表。对于类方法，每个类对象的<code>isa</code>指针都指向着对应的元类对象，而每一个元类对象中都有一个类方法列表。方法列表中记录着方法的名称，方法实现，以及参数类型，其实<code>selector</code>本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的方法实现<br><code>Selector、Method 和 IMP</code>的关系可以这样描述：在运行期分发消息，方法列表中的每一个实体都是一个方法（<code>Method</code>）它的名字叫做选择器（<code>SEL</code>）对应着一种方法实现（<code>IMP</code>）</p></blockquote></li><li><p><code>objc_msgSend、_objc_msgForward</code>都是做什么的？OC 中的消息调用流程是怎样的</p><blockquote><ul><li><code>objc_msgSend</code>是用来做消息发送的。在<code>OC</code>中，对方法的调用都会被转换成内部的消息发送执行</li><li><code>_objc_msgForward</code>是<code>IMP</code>类型（函数指针）用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发</li><li>在消息调用的过程中，<code>objc_msgSend</code>的动作比较清晰：首先在<code>Class</code>中的缓存查找<code>IMP</code>（没缓存则初始化缓存）如果没找到，则向父类的<code>Class</code>查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替<code>IMP</code>。最后，执行这个<code>IMP</code>。当调用一个<code>NSObject</code>对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的<code>-resolveInstanceMethod:、-forwardingTargetForSelector:、-methodSignatureForSelector:、-forwardInvocation:</code>等方法。其中最后<code>-forwardInvocation:</code>是会有一个<code>NSInvocation</code>对象，这个<code>NSInvocation</code>对象保存了这个方法调用的所有信息，包括<code>Selector名，参数和返回值类型</code>，可以从这个<code>NSInvocation</code>对象里拿到调用的所有参数值<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.12.18.01.jpg" alt=""></li></ul></blockquote></li><li><p><code>class</code>方法和<code>objc_getClass</code>方法有什么区别</p><blockquote><p><code>object_getClass(obj)</code>返回的是<code>obj</code>中的<code>isa</code>指针，即指向类对象的指针；而<code>[obj class]</code>则分两种情况：一是当<code>obj</code>为实例对象时，<code>[obj  class]</code>中<code>class</code>是实例方法，返回的是<code>obj</code>对象中的<code>isa</code>指针；二是当<code>obj</code>为类对象（包括元类和根类以及根元类）时，调用的是类方法，返回的结果为其本身</p></blockquote></li><li><p>OC中向一个<code>nil</code>对象发送消息将会发生什么</p><blockquote><p>在<code>OC</code>中向<code>nil</code>发送消息是完全有效的，只是在运行时不会有任何作用；向一个<code>nil</code>对象发送消息，首先在寻找对象的<code>isa</code>指针时就是<code>0地址</code>返回了，所以不会出现任何错误，也不会崩溃</p></blockquote></li><li><p><code>_objc_msgForward</code>函数是做什么的？直接调用它将会发生什么</p><blockquote><p><code>_objc_msgForward</code>是一个函数指针（和<code>IMP</code>的类型一样）用于消息转发；当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发<br><code>objc_msgSend</code>在<code>消息传递</code>中的作用。在<code>消息传递</code>过程中，<code>objc_msgSend</code>的动作比较清晰：首先在<code>Class</code>中的缓存查找<code>IMP</code>（<code>没有缓存则初始化缓存</code>）如果没找到，则向<code>父类的Class</code>查找。如果一直查找到<code>根类</code>仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替<code>IMP</code>，最后执行这个<code>IMP</code><br>一旦调用了<code>_objc_msgForward</code>，将跳过查找<code>IMP</code>的过程，直接触发<code>消息转发</code>，如果调用了<code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉<code>objc_msgSend</code>，我没有在这个对象里找到这个方法的实现，如果用不好会直接导致程序<code>Crash</code></p></blockquote></li><li><p>什么时候会报<code>unrecognized selector</code>的异常</p></li></ol><ul><li>当调用该对象上某个方法，而该对象上没有实现这个方法的时候。可以通过<code>消息转发</code>进行解决，流程见下图<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.12.18.01.jpg" alt=""></li><li><code>OC</code>在向一个对象发送消息时，<code>runtime</code>库会根据对象的<code>isa</code>指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常<code>unrecognized selector sent to XXX</code><br><strong>但是在这之前，OC的运行时会给出三次拯救程序崩溃的机会</strong></li><li>Method resolution（消息动态解析）<br><code>OC</code>运行时会调用<code>+resolveInstanceMethod:</code>或者<code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步，消息转发（<code>Message Forwarding</code>）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重写 resolveInstanceMethod: 添加对象方法实现</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是执行 run 函数，就动态解析，指定新的 IMP</span><br><span class="line">    if (sel &#x3D;&#x3D; NSSelectorFromString(@&quot;run:&quot;)) &#123;</span><br><span class="line">        &#x2F;&#x2F; class: 给哪个类添加方法</span><br><span class="line">        &#x2F;&#x2F; SEL: 添加哪个方法</span><br><span class="line">        &#x2F;&#x2F; IMP: 方法实现 &#x3D;&gt; 函数 &#x3D;&gt; 函数入口 &#x3D;&gt; 函数名</span><br><span class="line">        &#x2F;&#x2F; type: 方法类型：void用v来表示，id参数用@来表示，SEL用:来表示</span><br><span class="line">        class_addMethod(self, sel, (IMP)runMethod, &quot;v@:@&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新的 run 函数</span><br><span class="line">void runMethod(id self, SEL _cmd, NSNumber *meter) &#123;</span><br><span class="line">    NSLog(@&quot;跑了%@&quot;, meter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Fast forwarding（消息接受者重定向）<br>如果目标对象实现了<code>-forwardingTargetForSelector:</code>，<code>Runtime</code>这时就会调用这个方法，给你把这个消息转发给其他对象的机会。只要这个方法返回的不是<code>nil</code>和<code>self</code>，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续<code>Normal Fowarding</code>。 这里叫<code>Fast</code>，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个<code>NSInvocation</code>对象，所以相对更快点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 消息接受者重定向</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(run:)) &#123;</span><br><span class="line">        return [[Person alloc] init];</span><br><span class="line">        &#x2F;&#x2F; 返回 Person 对象，让 Person 对象接收这个消息</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Normal forwarding（消息重定向）<br>这一步是<code>Runtime</code>最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果<code>-methodSignatureForSelector:</code>返回<code>nil</code>，<code>Runtime</code>则会发出<code>-doesNotRecognizeSelector:</code>消息，程序这时也就挂掉了。如果返回了一个函数签名，<code>Runtime</code>就会创建一个<code>NSInvocation</code>对象并发送<code>-forwardInvocation:</code>消息给目标对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取函数的参数和返回值类型，返回签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;run:&quot;]) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消息重定向</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    &#x2F;&#x2F; 从 anInvocation 中获取消息</span><br><span class="line">    SEL sel &#x3D; anInvocation.selector;</span><br><span class="line">    if (sel &#x3D;&#x3D; NSSelectorFromString(@&quot;run:&quot;)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 指定当前类的一个方法作为IMP</span><br><span class="line">        &#x2F;&#x2F; anInvocation.selector &#x3D; @selector(readBook:);</span><br><span class="line">        &#x2F;&#x2F; [anInvocation invoke];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 2. 指定其他类来执行这个IMP</span><br><span class="line">        Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">        &#x2F;&#x2F; 判断 Person 对象方法是否可以响应 sel</span><br><span class="line">        if([p respondsToSelector:sel]) &#123;</span><br><span class="line">            &#x2F;&#x2F; 若可以响应，则将消息转发给其他对象处理</span><br><span class="line">            [anInvocation invokeWithTarget:p];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 若仍然无法响应，则报错：找不到响应方法</span><br><span class="line">            [self doesNotRecognizeSelector:sel];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    [super doesNotRecognizeSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>既然<code>-forwardingTargetForSelector:</code>和<code>-forwardInvocation:</code>都可以将消息转发给其他对象处理，那么两者的区别在哪？</strong><br>区别就在于<code>-forwardingTargetForSelector:</code>只能将消息转发给一个对象。而<code>-forwardInvocation:</code>可以把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。修改消息的target，selector，参数等。将消息转发给多个对象</li></ul><ol start="28"><li><p><code>iOS layoutSubviews</code>什么时候会被调用</p><blockquote><ul><li><code>init</code>方法不会调用<code>layoutSubviews</code>，但是是用<code>initWithFrame</code>进行初始化时，当<code>rect</code>的值不为<code>CGRectZero</code>时，会触发</li><li><code>addSubview</code>会触发<code>layoutSubviews</code>方法</li><li><code>setFrame</code>只有当设置的<code>frame</code>的参数的<code>size</code>与原来的<code>size</code>不同，才会触发其<code>view</code>的<code>layoutSubviews</code>方法</li><li>滑动<code>UIScrollView</code>会调用<code>scrollview</code>及<code>scrollview</code>上的<code>view</code>的<code>layoutSubviews</code>方法</li><li>旋转设备只会调用<code>VC</code>的<code>view</code>的<code>layoutSubviews</code>方法</li><li>直接调用<code>[self setNeedsLayout];</code>（这个在上面苹果官方文档里有说明）<br><code>-layoutSubviews</code>方法：这个方法默认没有做任何事情，需要子类进行重写<br><code>-setNeedsLayout</code>方法：标记为需要重新布局，异步调用<code>layoutIfNeeded</code>刷新布局，不立即刷新，但<code>layoutSubviews</code>一定会被调用<br><code>-layoutIfNeeded</code>方法：如果有需要刷新的标记，立即调用<code>layoutSubviews</code>进行布局（如果没有标记，不会调用<code>layoutSubviews</code>）<br>如果要立即刷新，要先调用<code>[view setNeedsLayout]</code>，把标记设为需要布局，然后马上调用<code>[view layoutIfNeeded]</code>，实现布局<br>在视图第一次显示之前，标记总是<code>需要刷新</code>的，可以直接调用<code>[view layoutIfNeeded]</code></li></ul></blockquote></li><li><p>下面代码会发生什么问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *str;</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">for (int i &#x3D; 0; i &lt; 1000000 ; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        self.str &#x3D; [NSString stringWithFormat:@&quot;changzifuchaung:%d&quot;,i];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会<code>crash</code>。因为在并行队列<code>DISPATCH_QUEUE_CONCURRENT</code>中异步<code>dispatch_async</code>对<code>str</code>属性进行赋值，就会导致<code>str</code>已经被<code>release</code>了，还会执行<code>release</code>。这就是向已释放内存的对象发送消息而发生<code>crash</code><br>详细解析：对<code>str</code>属性<code>strong</code>修饰进行赋值，相当与<code>MRC</code>中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setStr:(NSString *)str&#123;</span><br><span class="line">    if (str &#x3D;&#x3D; _str) return;</span><br><span class="line">    id pre &#x3D; _str;</span><br><span class="line">    [str retain];&#x2F;&#x2F;1.先保留新值</span><br><span class="line">    _str &#x3D; str;&#x2F;&#x2F;2.再进行赋值</span><br><span class="line">    [pre release];&#x2F;&#x2F;3.释放旧值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么假如<code>并发队列</code>里调度的<code>线程A</code>执行到<code>步骤1</code>，还没到<code>步骤2</code>时，<code>线程B</code>执行到<code>步骤3</code>，那么当<code>线程A</code>再执行<code>步骤3</code>时，旧值就会被<code>过度释放</code>，导致向已释放内存的对象发送消息而崩溃</p></li></ol><ul><li><p>追问：怎么修改这段代码变为不崩溃呢</p><blockquote><p>1、使用串行队列<br>将<code>set</code>方法改成在串行队列中执行就行，这样即使异步，但所有<code>block</code>操作追加在队列最后依次执行<br>2、使用<code>atomic</code><br><code>atomic</code>关键字相当于在<code>setter</code>方法加锁，这样每次执行<code>setter</code>都是线程安全的，但这只是单独针对<code>setter</code>方法而言的狭义的线程安全<br>3、使用<code>weak</code>关键字<br><code>weak</code>的<code>setter</code>没有<code>保留新值</code>的操作，所以不会引发重复释放。当然这个时候要看具体情况能否使用<code>weak</code>，可能值并不是所需要的值<br>4、使用互斥锁，保证数据访问的唯一性<code>@synchronized (self) &#123;self.str = [NSString stringWithFormat:@&quot;changzifuchaung:%d&quot;,i];&#125;</code><br>5、使用<code>Tagged Pointer</code><br><code>Tagged Pointer</code>是苹果在64位系统引入的内存技术。简单来说就是对于<code>NSString</code>(内存小于60位的字符串)或<code>NSNumber</code>(小于2^31)，64位的指针有8个字节，完全可以直接用这个空间来直接表示值，这样的话其实会将<code>NSString</code>和<code>NSNumber</code>对象由一个<code>指针</code>转换成一个<code>值类型</code>，而值类型的<code>setter和getter</code>又是原子的，从而线程安全</p></blockquote></li><li><p>发散：下面代码会<code>crash</code>吗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *str;</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">for (int i &#x3D; 0; i &lt; 1000000 ; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 相比上面，仅字符串变短了</span><br><span class="line">        self.str &#x3D; [NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line">        NSLog(@&quot;%d, %s, %p&quot;, i, object_getClassName(self.str), self.str);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不会<code>crash</code>。而且发现<code>str</code>这个字符串类型是<code>NSTaggedPointerString</code><br><code>Tagged Pointer</code>是一个能够提升性能、节省内存的有趣的技术<br><code>Tagged Pointer</code>专门用来存储小的对象，例如<code>NSNumber</code>和<code>NSDate</code>(后来可以存储小字符串)<br><code>Tagged Pointer指针的值</code>不再是<code>地址</code>了，而是<code>真正的值</code>。所以，实际上它不再是一个<code>对象</code>了，它只是一个披着对象皮的<code>普通变量</code>而已<br>它的内存并不存储在<code>堆</code>中，也不需要<code>malloc和free</code>，所以拥有极快的读取和创建速度</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;UIView&lt;/code&gt;和&lt;code&gt;CALayer&lt;/code&gt;是什么关系&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UIView&lt;/code&gt;继承自&lt;code&gt;UIResponder&lt;/code&gt;类，可以响应事件&lt;/
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 关于Other Linker Flags的作用</title>
    <link href="https://gsl201600.github.io/2019/12/11/iOS%E5%85%B3%E4%BA%8EOtherLinkerFlags%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://gsl201600.github.io/2019/12/11/iOS关于OtherLinkerFlags的作用/</id>
    <published>2019-12-11T06:43:00.000Z</published>
    <updated>2019-12-11T06:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在用第三方库时，我们常常在Xcode的<code>Build Settings</code>下<code>Other Linker Flags</code>里面加入<code>-ObjC</code>标志，它和<code>Objective-C</code>的一个重要特性：类别（<code>category</code>)有关</p><blockquote><p>根据官方的解释，<code>Unix</code>的标准静态库实现和<code>Objective-C</code>的动态特性之间有一些冲突：<code>Objective-C</code>没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，出现<code>&quot;selector not recognized&quot;</code>，也就是找不到方法定义的错误。</p></blockquote><p>为了解决这个问题，引入了<code>-ObjC</code>标志，它的作用就是将静态库中所有的          <code>Objective-C</code>代码都加载进来。可以看出，使用<code>-ObjC</code>可能会链接很多静态库中未被使用的<code>Objective-C</code>代码，极大的增加APP的代码体积。<br>不要以为这样就可以解决所有问题了，在64位的Mac系统或者iOS系统下，链接器有一个bug，会导致只包含有类别的静态库无法使用<code>-ObjC</code>标志来加载文件。<br>变通方法是使用<code>-all_load</code>或者<code>-force_load</code>标志，它们的作用都是强制链接器把目标文件都加载进来，即使没有objc代码，不过<code>-all_load</code>作用于所有的库，而<code>-force_load</code>后面必须要指定具体文件加载的位置</p><table><thead><tr><th>Flags</th><th>位置</th><th>作用</th></tr></thead><tbody><tr><td><code>-ObjC</code></td><td><code>Other Linker Flags</code></td><td>链接静态库中所有的<code>Objective-C</code>代码到APP</td></tr><tr><td><code>-all_load</code></td><td><code>Other Linker Flags</code></td><td>全加载，链接静态库中所有的代码到APP，无论是<code>c</code>、<code>c++</code>还是<code>oc</code></td></tr><tr><td><code>-force_load</code></td><td><code>Other Linker Flags</code></td><td>链接指定静态库中所有的代码到APP，无论是<code>c</code>、<code>c++</code>还是<code>oc</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在用第三方库时，我们常常在Xcode的&lt;code&gt;Build Settings&lt;/code&gt;下&lt;code&gt;Other Linker Flags&lt;/code&gt;里面加入&lt;code&gt;-ObjC&lt;/code&gt;标志，它和&lt;code&gt;Objective-C&lt;/code&gt;的一个重要特性：
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 使用Jenkins持续集成(简称CI)</title>
    <link href="https://gsl201600.github.io/2019/11/27/iOS%E4%BD%BF%E7%94%A8Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>https://gsl201600.github.io/2019/11/27/iOS使用Jenkins持续集成/</id>
    <published>2019-11-27T08:56:00.000Z</published>
    <updated>2020-04-14T06:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>安装<code>jenkins</code><br>1.1. 直接到<a href="https://link.jianshu.com/?t=http://jenkins-ci.org/">官网</a>下载安装包，通过安装包安装<br>1.2. 通过<code>Homebrew</code>使用命令行安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 安装Homebrew</span><br><span class="line">$ ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br><span class="line">2. 安装Jenkins</span><br><span class="line">$ brew install jenkins</span><br><span class="line">3、启动Jenkins</span><br><span class="line">$ jenkins</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>jenkins</code>需要<code>java</code>环境，如果没有安装会有提示，<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Fdownloads%2Fjdk8-downloads-2133151.html">java安装地址</a></li></ul><p>一切顺利的话，打开浏览器输入：<code>http://localhost:8080/</code>就能看到<code>jenkins</code>已经运行起来了，如果你更换了端口就是你后来设置的端口。接下来打开<code>Jenkins</code>后会让去一个填写<code>password</code>的页面如下图，存储<code>password</code>的地方就是图片上那行红色字体目录<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.01.png" alt=""></p><p>然后将我们得到的<code>password</code>输入到<code>Administrator password</code>中，即可进入如下界面，接着安装一些建议的插件<code>左边的</code>，安装过程中，有的插件可能会安装失败，强烈建议点击右下角的重试，直到把建议安装的都装好<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.02.png" alt=""></p><p>插件安装完成后，可能不会自动跳转，刷新下界面即可，在刷新后的界面中注册，输入用户名和密码，建议输入后点蓝色按钮保存完成</p><ol start="2"><li><p>安装<code>jenkins</code>插件<br>如果要使用<code>Jenkins</code>的插件构建工程的，需要在开始新建工程前安装一些<code>Jenkins</code>插件，在可选插件中选择我们需要的插件进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Xcode integration</span><br><span class="line">2. GIT plugin</span><br><span class="line">3. GitLab Plugin</span><br><span class="line">4. Gitlab Hook Plugin</span><br><span class="line">5. Keychains and Provisioning Profiles Management</span><br></pre></td></tr></table></figure><p>我们今天使用<code>Execute shell</code> <code>Shell脚本</code>构建工程</p></li><li><p><code>jenkins</code>的使用<br>3.1. 构建一个自由风格的软件项目<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.03.png" alt=""></p></li></ol><p>3.2. <code>General</code>参数<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.04.JPG" alt=""><br>可以设置包的保留天数和最大保留个数，这些可以根据需要进行调整，可以不要选</p><ul><li><code>jenkins</code>插件配置多个项目<code>extended choice parameter</code>插件主要是构建的时候可以多选框来选择要构建的项目模块</li></ul><p><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.05.png" alt=""><br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.06.png" alt=""><br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.07.png" alt=""><br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.08.png" alt="($+上面的Name)就可以获取该值"></p><p>3.3. 源码管理<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.09.png" alt=""><br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.10.png" alt=""></p><p>3.4. 构建触发器设置<br>触发器可自定义的地方很多，可以根据项目需要选择<code>可省略</code></p><ul><li>定时构建：不管<code>SVN</code>或<code>Git</code>中数据有无变化，均执行定时化的构建任务</li><li>轮询<code>SCM</code>：只要<code>SVN</code>或<code>Git</code>中数据有更新，则执行构建任务<br>日程表的填写内容有<code>5</code>个参数，从左到右的参数含义如下：<br>⦁ 第<code>1</code>个参数：分钟<code>minute</code>，取值<code>0~59</code><br>⦁ 第<code>2</code>个参数：小时<code>hour</code>，取值<code>0~23</code><br>⦁ 第<code>3</code>个参数：天<code>day</code>，取值<code>1~31</code><br>⦁ 第<code>4</code>个参数：月<code>month</code>，取值<code>1~12</code><br>⦁ 第<code>5</code>个参数：星期<code>week</code>，取值<code>0~7</code>，<code>0</code>和<code>7</code>都是表示星期天<br><code>5</code>个参数可选择性设定，不写死的参数用<code>*</code>号代替，参数之间用空格隔开。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;0 21 * * *&quot;表示每晚21点0分自动化构建一次</span><br><span class="line">&quot;0 * * * *&quot;表示每个小时的第0分钟执行一次构建</span><br><span class="line">&quot;H&#x2F;5 * * * *&quot;每隔5分钟构建一次</span><br><span class="line">&quot;H H&#x2F;2 * * *&quot;每两小时构建一次</span><br><span class="line">&quot;H H 30 * *&quot;每月30号构建一次</span><br><span class="line">&quot;H(0-29)&#x2F;10 * * * *&quot;每个小时的前半个小时内的每10分钟</span><br><span class="line">&quot;0 8-17&#x2F;2 * * 1-5&quot;周一到周五，8点~17点，两小时构建一次</span><br><span class="line">&quot;H H 1,15 1-11 *&quot;每月1号、15号各构建一次，除12月等</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.11.png" alt=""></li></ul><p>3.5. 构建环境设置<br>本文使用的是<code>shell</code>脚本构建工程，所以该项可以省去<br>3.6. 构建<br>有两种方式打包，一是用<code>Xcode</code>插件打包，二是用<code>Shell</code>脚本打包，本文选择第二种<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.12.png" alt=""></p><ul><li><code>iOS</code>自动打包—<code>Jenkins Shell</code>如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">## !&#x2F;bin&#x2F;sh</span><br><span class="line">## 项目名</span><br><span class="line">TARGET_NAME&#x3D;NNAlgorithm</span><br><span class="line">## Scheme名</span><br><span class="line">SCHEME&#x3D;NNAlgorithm</span><br><span class="line">##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">## 编译类型</span><br><span class="line">BUILD_TYPE&#x3D;Release</span><br><span class="line">## 当前目录</span><br><span class="line">SORCEPATH&#x3D;$&#123;WORKSPACE&#125;</span><br><span class="line">## workspace名</span><br><span class="line">SPACE&#x3D;$&#123;WORKSPACE&#125;&#x2F;$&#123;TARGET_NAME&#125;.xcodeproj</span><br><span class="line">##xcarchive文件的存放路径</span><br><span class="line">ARCHIVEPATH&#x3D;$SORCEPATH&#x2F;build&#x2F;$SCHEME.xcarchive</span><br><span class="line">## ipa文件的存放路径</span><br><span class="line">EXPORTPATH&#x3D;$SORCEPATH&#x2F;build&#x2F;$SCHEME</span><br><span class="line">## ExportOptions.plist文件的存放路径，该文件要存放在这个路径下内容如下</span><br><span class="line">EXPORTOPTIONSPLIST&#x3D;$SORCEPATH&#x2F;build&#x2F;ExportOptions.plist</span><br><span class="line">## 导出后的ipa路径</span><br><span class="line">EXPORTPATHIPA&#x3D;$SORCEPATH&#x2F;build&#x2F;$SCHEME&#x2F;$SCHEME.ipa</span><br><span class="line"></span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;First Build Clean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">## 清理缓存</span><br><span class="line">## 如果工程使用的是cocoapods，则&#39;-project %s.xcodeproj&#39;替换为&#39;-workspace %s.xcworkspace&#39;</span><br><span class="line">xcodebuild clean -project $SPACE -scheme $&#123;SCHEME&#125; -configuration $&#123;BUILD_TYPE&#125;</span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Build Clean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">## 输出关键信息</span><br><span class="line">echo -e &quot;  TARGET_NAME    : $&#123;TARGET_NAME&#125;&quot;</span><br><span class="line">echo -e &quot;  BUILD_TYPE    : $&#123;BUILD_TYPE&#125;&quot;</span><br><span class="line">echo -e &quot;  SORCEPATH    : $&#123;SORCEPATH&#125;&quot;</span><br><span class="line">echo -e &quot;  ARCHIVEPATH    : $&#123;ARCHIVEPATH&#125;&quot;</span><br><span class="line">echo -e &quot;  EXPORTPATH    : $&#123;EXPORTPATH&#125;&quot;</span><br><span class="line">echo -e &quot;  EXPORTOPTIONSPLIST    : $&#123;EXPORTOPTIONSPLIST&#125;&quot;</span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Build Archive&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line"></span><br><span class="line">## 导出archive包</span><br><span class="line">xcodebuild archive -project $&#123;SPACE&#125; -scheme $&#123;SCHEME&#125; -archivePath $ARCHIVEPATH</span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Build Archive Success&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line"></span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Export IPA&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">## 导出IPA包</span><br><span class="line">xcodebuild -exportArchive -archivePath $ARCHIVEPATH -exportPath $&#123;EXPORTPATH&#125; -exportOptionsPlist $&#123;EXPORTOPTIONSPLIST&#125;</span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Export IPA SUCCESS&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line"></span><br><span class="line">## 编译完成时间 20181030_0931</span><br><span class="line">BUILD_DATE&#x3D;&quot;$(date +&#39;%Y%m%d_%H%M&#39;)&quot;</span><br><span class="line"></span><br><span class="line">## info.plist路径</span><br><span class="line">PROJECT_INFOPLIST_PATH&#x3D;&quot;$&#123;SORCEPATH&#125;&#x2F;$&#123;TARGET_NAME&#125;&#x2F;Info.plist&quot;</span><br><span class="line">## 取版本号</span><br><span class="line">BUNDLESHORTVERSION&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;PROJECT_INFOPLIST_PATH&#125;&quot;)</span><br><span class="line">## 取build值</span><br><span class="line">VERSION&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;PROJECT_INFOPLIST_PATH&#125;&quot;)</span><br><span class="line">## ipa更名规则  项目名V版本_年月日_时分</span><br><span class="line">IPANAME&#x3D;&quot;$&#123;TARGET_NAME&#125;V$&#123;BUNDLESHORTVERSION&#125;_$&#123;BUILD_DATE&#125;.ipa&quot;</span><br><span class="line">## 更名后ipa路径</span><br><span class="line">EXPORTPATHNEWIPA&#x3D;$EXPORTPATH&#x2F;$IPANAME</span><br><span class="line"></span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Export end :$&#123;BUILD_DATE&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;IPA Old Name: $&#123;EXPORTPATHIPA&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;IPA New Name: $&#123;EXPORTPATHNEWIPA&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line"></span><br><span class="line">## IPA更名</span><br><span class="line">cp $EXPORTPATHIPA $EXPORTPATHNEWIPA</span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Create New Name Success&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">## 删除老IPA</span><br><span class="line">rm $EXPORTPATHIPA</span><br><span class="line">echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Delete Old Name Success&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line"></span><br><span class="line">#userKey和apiKey需要在蒲公英的账号设置中查找</span><br><span class="line">userKey&#x3D;&quot;xxx&quot;</span><br><span class="line">apiKey&#x3D;&quot;xxx&quot;</span><br><span class="line">#蒲公英打包</span><br><span class="line">curl -F &quot;file&#x3D;@$&#123;EXPORTPATHNEWIPA&#125;&quot; \</span><br><span class="line">-F &quot;uKey&#x3D;$&#123;userKey&#125;&quot; \</span><br><span class="line">-F &quot;_api_key&#x3D;$&#123;apiKey&#125;&quot; \</span><br><span class="line">-F &quot;isPublishToPublic&#x3D;2&quot; \</span><br><span class="line">http:&#x2F;&#x2F;www.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload</span><br></pre></td></tr></table></figure></li><li><code>ExportOptions.plist</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;provisioningProfiles&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;com.Y***ane&lt;&#x2F;key&gt;</span><br><span class="line">        &lt;string&gt;azur***_dev&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;&#x2F;dict&gt;</span><br><span class="line">    &lt;key&gt;method&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;development&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;key&gt;signingCertificate&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;iPhone Developer&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;key&gt;signingStyle&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;manual&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;key&gt;teamID&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;string&gt;42***ZL&lt;&#x2F;string&gt;</span><br><span class="line">    &lt;key&gt;compileBitcode&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;false&#x2F;&gt;</span><br><span class="line">    &lt;key&gt;uploadSymbols&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;false&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure></li><li>其中<code>plist</code>文件中的<code>method</code>参数有如下几个方法：<code>app-store, ad-hoc, enterprise, development</code><br>3.7. 构建后操作</li><li>邮件通知系统，通过<code>系统管理</code>→<code>系统设置</code>，进行邮件配置</li><li><p>设置<code>jenkins</code>地址和管理员邮箱地址<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.13.JPG" alt=""></p></li><li><p>设置发件人等信息<br>这里的发件人邮箱地址切记要和系统管理员邮件地址保持一致<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.14.png" alt=""></p></li><li><p><strong>注：上图的Password为邮箱的SMTP授权秘钥，至此系统管理处的内容已配置完成</strong></p></li><li>配置<code>Jenkins</code>自带的邮件功能(测试邮件功能是否正常使用，可以不配置，不影响)<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.15.png" alt=""></li></ul><p>和上面<code>Extended E-mail Notification</code>配置一样即可，点击<code>Test configuration</code>，收到邮件并且显示<code>Email was successfully sent</code>，代表邮件配置成功，接下来可以去项目中具体配置就可以使用了</p><ul><li><p>进入项目，然后找到构建后操作，点击<code>增加构建后的操作步骤</code>，点击<code>Editable Email Notification</code><br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.16.png" alt=""><br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.17.png" alt=""></p></li><li><p>至此所有的配置已完成，点击应用后保存，<code>enjoy it！</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Project Recipient List：这个项目的需要发送邮件给哪些人，可以在这里输入多个邮箱，中间以英文逗号隔开</span><br><span class="line">Project Reply-To List：保持默认即可，这个是收到邮件的人回复邮件时候回复给谁用的，一般不会回复邮件</span><br><span class="line">Content Type：可以选择Html或者Default也行，因为我们在jenkins系统设置中的默认格式就是html</span><br><span class="line">Default Subject： 邮件主题，可以书写成：XXX项目iOS打包通知:$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS! 分析下这几个参数什么意思：$PROJECT_NAME 构建项目的名称；$BUILD_NUMBER 构建的号码；$BUILD_STATUS 构建状态，这几个参数，它会自动读取，按照这种格式书写即可</span><br><span class="line">Default Content：邮件内容，以下内容为模板，可直接复制修改使用：</span><br><span class="line"></span><br><span class="line">&lt;hr&#x2F;&gt;</span><br><span class="line">本邮件是程序自动下发的，请勿回复！&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;</span><br><span class="line">项目名称：$PROJECT_NAME&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;</span><br><span class="line">构建编号：$BUILD_NUMBER&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;</span><br><span class="line">构建状态：$BUILD_STATUS&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;</span><br><span class="line">触发原因：$&#123;CAUSE&#125;&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;</span><br><span class="line">构建日志地址：&lt;a href&#x3D;&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console&#x2F;&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;</span><br><span class="line">构建地址：&lt;a href&#x3D;&quot;$BUILD_URL&quot;&gt;$BUILD_URL&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;</span><br><span class="line">构建报告：&lt;a href&#x3D;&quot;$&#123;BUILD_URL&#125;testReport&quot;&gt;$&#123;BUILD_URL&#125;testReport&#x2F;&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;</span><br><span class="line">变更集:$&#123;JELLY_SCRIPT,template&#x3D;&quot;html&quot;&#125;&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li><a href="https://www.cnblogs.com/EasonJim/p/6277708.html">Jenkins卸载方法（Windows/Linux/MacOS）</a></li></ol><ul><li>如果使用<code>brew</code>安装的，可以执行以下命令<code>$ brew uninstall jenkins</code></li><li><strong>注：Jenkins修改工程的工作空间</strong><br>在项目的配置中点击高级，选择使用自定义工作空间，输入工作空间路径即可<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.18.png" alt=""><br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.27.19.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;安装&lt;code&gt;jenkins&lt;/code&gt;&lt;br&gt;1.1. 直接到&lt;a href=&quot;https://link.jianshu.com/?t=http://jenkins-ci.org/&quot;&gt;官网&lt;/a&gt;下载安装包，通过安装包安装&lt;br&gt;1.2. 通过&lt;code&gt;
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 插件化开发(动态库研究)</title>
    <link href="https://gsl201600.github.io/2019/11/13/iOS%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>https://gsl201600.github.io/2019/11/13/iOS插件化开发/</id>
    <published>2019-11-13T09:16:00.000Z</published>
    <updated>2019-11-13T09:18:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>framework是一种优秀的资源打包方式，我们平时看到的第三方发布的framework大部分都是静态库，苹果对iOS允许使用动态库，但是要利用动态库热更新，由于苹果的审核和签名技术，暂时还是不行，内部使用还是可行的</p><ul><li>思路：在用户想使用某个功能的时候让其从服务器上将动态库文件下载到本地，然后手动加载动态库，实现功能的的插件化</li></ul></blockquote><ol><li>创建动态库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 头文件部分</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface DynamicLlib : NSObject</span><br><span class="line"></span><br><span class="line">- (void)doSomething;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"># 实现部分</span><br><span class="line">#import &quot;DynamicLlib.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation DynamicLlib</span><br><span class="line"></span><br><span class="line">- (void)doSomething&#123;</span><br><span class="line">    NSLog(@&quot;doSomething!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li>使用动态库</li></ol><ul><li>实际过程中动态库是需要从服务器下载并且保存到app的沙盒中的,这边直接模拟已经下载好了动态库并且保存到沙盒中</li></ul><p>2.1. 使用NSBundle加载动态库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)loadFrameWorkByBundle:(id)sender &#123;</span><br><span class="line">    &#x2F;&#x2F;从服务器去下载并且存入Documents下(只要知道存哪里即可),事先要知道framework名字,然后去加载</span><br><span class="line">    NSString *frameworkPath &#x3D; [NSString stringWithFormat:@&quot;%@&#x2F;Documents&#x2F;DynamicLlib.framework&quot;,NSHomeDirectory()];</span><br><span class="line">    </span><br><span class="line">    NSError *err &#x3D; nil;</span><br><span class="line">    NSBundle *bundle &#x3D; [NSBundle bundleWithPath:frameworkPath];</span><br><span class="line">    NSString *str &#x3D; @&quot;加载动态库失败!&quot;;</span><br><span class="line">    if ([bundle loadAndReturnError:&amp;err]) &#123;</span><br><span class="line">        NSLog(@&quot;bundle load framework success.&quot;);</span><br><span class="line">        str &#x3D; @&quot;加载动态库成功!&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;bundle load framework err:%@&quot;,err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2.2. 使用dlopen加载动态库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 动态库中真正的可执行代码为DynamicLlib.framework&#x2F;DynamicLlib文件，因此使用dlopen时指定加载动态库的路径为DynamicLlib.framework&#x2F;DynamicLlib</span><br><span class="line">NSString *documentsPath &#x3D; [NSString stringWithFormat:@&quot;%@&#x2F;Documents&#x2F;DynamicLlib.framework&#x2F;DynamicLlib&quot;,NSHomeDirectory()];</span><br><span class="line">[self dlopenLoadDylibWithPath:documentsPath];</span><br><span class="line">    if (dlopen([path cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW) &#x3D;&#x3D; NULL) &#123; </span><br><span class="line">        char *error &#x3D; dlerror(); </span><br><span class="line">        NSLog(@&quot;dlopen error: %s&quot;, error); </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        NSLog(@&quot;dlopen load framework success.&quot;); </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><br>2.3. 调用动态库中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;调用framework的方法,利用runtime运行时</span><br><span class="line">- (IBAction)callMethodOfFrameWork:(id)sender &#123;</span><br><span class="line">    Class DynamicLlibClass &#x3D; NSClassFromString(@&quot;DynamicLlib&quot;);</span><br><span class="line">    if(DynamicLlibClass)&#123;</span><br><span class="line">        &#x2F;&#x2F;事先要知道有什么方法在这个framework中</span><br><span class="line">        id object &#x3D; [[DynamicLlibClass alloc] init];</span><br><span class="line">        &#x2F;&#x2F;由于没有引入相关头文件故通过performSelector调用</span><br><span class="line">        [object performSelector:@selector(doSomething)];</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;调用方法失败!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;framework是一种优秀的资源打包方式，我们平时看到的第三方发布的framework大部分都是静态库，苹果对iOS允许使用动态库，但是要利用动态库热更新，由于苹果的审核和签名技术，暂时还是不行，内部使用还是可行的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;思路
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 唤起APP之Universal Link(通用链接)</title>
    <link href="https://gsl201600.github.io/2019/11/06/iOS%E5%94%A4%E8%B5%B7APP%E4%B9%8BUniversal%20Link/"/>
    <id>https://gsl201600.github.io/2019/11/06/iOS唤起APP之Universal Link/</id>
    <published>2019-11-06T08:09:00.000Z</published>
    <updated>2020-07-02T07:15:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>iOS 9</code>之前，一直使用的是<code>URL Schemes</code>技术来从外部对<code>App</code>进行跳转，但是<code>iOS</code>系统中进行<code>URL Schemes</code>跳转的时候如果没有安装<code>App</code>，会提示<code>Cannot open Page</code>的提示，而且当注册有多个<code>scheme</code>相同的时候，目前没有办法区分，但是从<code>iOS 9</code>起可以使用<code>Universal Links</code>技术进行跳转页面，这是一种体验更加完美的解决方案</p></blockquote><ul><li><p>什么是<code>Universal Link</code>（通用链接）<br><code>Universal Link</code>是<code>Apple</code>在<code>iOS 9</code>推出的一种能够方便的通过传统<code>HTTPS</code>链接来启动<code>APP</code>的功能。如果你的应用支持<code>Universal Link</code>，当用户点击一个链接时可以跳转到你的网站并获得无缝重定向到对应的<code>APP</code>，且不需要通过<code>Safari</code>浏览器。如果你的应用不支持的话，则会在<code>Safari</code>中打开该链接</p></li><li><p>支持<code>Universal Link</code>（通用链接）<br>先决条件：必须有一个支持<code>HTTPS</code>的域名，并且拥有该域名下上传到根目录的权限（为了上传<code>Apple</code>指定文件）</p></li><li><strong>集成步骤</strong></li></ul><ol><li><p>开发者中心配置<br>找到对应的<code>App ID</code>，在<code>Application Services</code>列表里有<code>Associated Domains</code>一条，把它变为<code>Enabled</code>就可以了<br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.06.01.png" alt="配置App ID支持Associated Domains"></p></li><li><p>工程配置<br><code>targets-&gt;Capabilites-&gt;Associated Domains</code>，在其中的<code>Domains</code>中填入你想支持的域名，必须以<code>applinks:</code>为前缀，如：<code>applinks:domain</code><br><img src="https://raw.githubusercontent.com/Gsl201600/PicGoImg/master/img/2019.11.06.02.png" alt="配置项目中的Associated Domains"></p></li><li><p>配置指定文件<br>创建一个内容为<code>json</code>格式的文件，苹果将会在合适的时候，从我们在项目中填入的域名请求这个文件。这个文件名必须为<code>apple-app-site-association</code>，切记没有<code>后缀名</code>，文件内容大概是这样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;applinks&quot;: &#123;</span><br><span class="line">        &quot;apps&quot;: [],</span><br><span class="line">        &quot;details&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;9JA89QQLNQ.com.apple.wwdc&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;&#x2F;wwdc&#x2F;news&#x2F;&quot;, &quot;&#x2F;videos&#x2F;wwdc&#x2F;2015&#x2F;*&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;appID&quot;: &quot;ABCD1234.com.apple.wwdc&quot;,</span><br><span class="line">                &quot;paths&quot;: [ &quot;*&quot; ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>appID</code>：组成方式是<code>TeamID.BundleID</code>。如上面的<code>9JA89QQLNQ</code>就是<code>teamId</code>。登陆开发者中心，在<code>Account -&gt; Membership</code>里面可以找到<code>Team ID</code><br><code>paths</code>：设定你的<code>app</code>支持的路径列表，只有这些指定路径的链接，才能被<code>app</code>所处理。<code>*</code>的写法代表了可识别域名下所有链接</p></li><li><p>上传该文件<br>上传该文件到你的域名所对应的<code>根目录</code>或者<code>.well-known目录</code>下，这是为了苹果能获取到你上传的文件。上传完后，先访问一下，看看是否能够获取到，当你在浏览器中输入这个文件链接后，应该是直接下载<code>apple-app-site-association</code>文件</p></li><li><p>代码中的相关支持<br>当点击某个链接，可以直接进我们的<code>app</code>，但是我们的目的是要能够获取到用户进来的链接，根据链接来展示给用户相应的内容，我们需要在工程里实现<code>AppDelegate</code>对应的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler &#123;</span><br><span class="line">    &#x2F;&#x2F; NSUserActivityTypeBrowsingWeb 由Universal Links唤醒的APP</span><br><span class="line">    if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb])&#123;</span><br><span class="line">        NSURL *webpageURL &#x3D; userActivity.webpageURL;</span><br><span class="line">        NSString *host &#x3D; webpageURL.host;</span><br><span class="line">        if ([host isEqualToString:@&quot;api.r2games.com.cn&quot;])&#123;</span><br><span class="line">            &#x2F;&#x2F;进行我们的处理</span><br><span class="line">            NSLog(@&quot;TODO....&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;openurl&quot;);</span><br><span class="line">            [[UIApplication sharedApplication] openURL:webpageURL options:nil completionHandler:nil];</span><br><span class="line">            &#x2F;&#x2F; [[UIApplication sharedApplication] openURL:webpageURL];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果为了方便开发者，提供了一个<a href="https://search.developer.apple.com/appsearch-validation-tool/">网页验证</a>我们编写的这个<code>apple-app-site-association</code>是否合法有效</p></li></ol><ul><li><strong>Universal Link（通用链接）注意点</strong></li></ul><ol><li><code>Universal Link</code>跨域<br><code>Universal Link</code>有跨域问题，<code>Universal Link</code>必须要求跨域，如果不跨域，就不会跳转（<code>iOS 9.2</code>之后的改动）<br>假如当前网页的域名是<code>A</code>，当前网页发起跳转的域名是<code>B</code>，必须要求<code>B</code>和<code>A</code>是不同域名才会触发<code>Universal Link</code>，如果<code>B</code>和<code>A</code>是相同域名，只会继续在当前<code>WebView</code>里面进行跳转，哪怕你的<code>Universal Link</code>一切正常，根本不会打开<code>App</code></li><li><code>Universal Link</code>请求<code>apple-app-site-association</code>时机</li></ol><ul><li>当我们的<code>App</code>在设备上第一次运行时，如果支持<code>Associated Domains</code>功能，那么<code>iOS</code>会自动去<code>GET</code>定义的<code>Domain</code>下的<code>apple-app-site-association</code>文件</li><li><code>iOS</code>会先请求<code>https://domain.com/.well-known/apple-app-site-association</code>，如果此文件请求不到，再去请求<code>https://domain.com/apple-app-site-association</code>，所以如果想要避免服务器接收过多<code>GET</code>请求，可以直接把<code>apple-app-site-association</code>放在<code>./well-known</code>目录下</li><li><p>服务器上<code>apple-app-site-association</code>的更新不会让<code>iOS</code>本地的<code>apple-app-site-association</code>同步更新，即<code>iOS</code>只会在<code>App</code>第一次启动时请求一次，以后除非<code>App</code>更新或重新安装，否则不会在每次打开时请求<code>apple-app-site-association</code></p></li><li><p><strong>Universal Link的好处</strong></p></li></ul><ol><li>之前的<code>Custom URL scheme</code>是自定义的协议，因此在没有安装该<code>app</code>的情况下是无法直接打开的。而<code>Universal Links</code>本身就是一个能够指向<code>web</code>页面或者<code>app</code>内容页的标准<code>web link</code>，因此能够很好的兼容其他情况</li><li><code>Universal links</code>是从服务器上查询是哪个<code>app</code>需要被打开，因此不存在<code>Custom URL scheme</code>那样名字被抢占、冲突的情况</li><li><code>Universal links</code>支持从其他<code>app</code>中的<code>UIWebView</code>中跳转到目标<code>app</code></li><li>提供<code>Universal link</code>给别的<code>app</code>进行<code>app</code>间的交流时，对方并不能够用这个方法去检测你的<code>app</code>是否被安装（之前的<code>custom scheme URL</code>的<code>canOpenURL</code>方法可以）</li></ol><p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW1">附：[官方文档] Support Universal Links</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;iOS 9&lt;/code&gt;之前，一直使用的是&lt;code&gt;URL Schemes&lt;/code&gt;技术来从外部对&lt;code&gt;App&lt;/code&gt;进行跳转，但是&lt;code&gt;iOS&lt;/code&gt;系统中进行&lt;code&gt;URL Schemes&lt;/cod
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>iOS 归档缓存</title>
    <link href="https://gsl201600.github.io/2019/10/30/iOS%E5%BD%92%E6%A1%A3%E7%BC%93%E5%AD%98/"/>
    <id>https://gsl201600.github.io/2019/10/30/iOS归档缓存/</id>
    <published>2019-10-30T09:55:00.000Z</published>
    <updated>2019-10-30T09:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码如下：</p><ul><li>头文件定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 归档缓存内容</span><br><span class="line">+ (void)archiverObject:(id)object byKey:(NSString *)key withPath:(NSString *)path;</span><br><span class="line">&#x2F;&#x2F; 解归档缓存内容</span><br><span class="line">+ (id)unarchiverObjectByKey:(NSString *)key withPath:(NSString *)path;</span><br></pre></td></tr></table></figure></li><li>方法实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ (void)archiverObject:(id)object byKey:(NSString *)key withPath:(NSString *)path&#123;</span><br><span class="line">    &#x2F;&#x2F;初始化存储对象信息的data</span><br><span class="line">    NSMutableData *data &#x3D; [NSMutableData data];</span><br><span class="line">    &#x2F;&#x2F;创建归档工具对象</span><br><span class="line">    NSKeyedArchiver *archiver &#x3D; [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];</span><br><span class="line">    &#x2F;&#x2F;开始归档</span><br><span class="line">    [archiver encodeObject:object forKey:key];</span><br><span class="line">    &#x2F;&#x2F;结束归档</span><br><span class="line">    [archiver finishEncoding];</span><br><span class="line">    &#x2F;&#x2F;写入本地地址</span><br><span class="line">    NSString *resultStr &#x3D; [self destPath:path];</span><br><span class="line">    [data writeToFile:resultStr atomically:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSString *)destPath:(NSString *)path&#123;</span><br><span class="line">    NSString *docPath &#x3D; NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES).lastObject;</span><br><span class="line">    NSString *destPath &#x3D; [[docPath stringByAppendingPathComponent:@&quot;Caches&quot;] stringByAppendingPathComponent:path];</span><br><span class="line">    NSLog(@&quot;%@&quot;, destPath);</span><br><span class="line">    return destPath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)unarchiverObjectByKey:(NSString *)key withPath:(NSString *)path&#123;</span><br><span class="line">    NSString *resultStr &#x3D; [self destPath:path];</span><br><span class="line">    NSData *data &#x3D; [NSData dataWithContentsOfFile:resultStr];</span><br><span class="line">    &#x2F;&#x2F;创建反归档对象</span><br><span class="line">    NSKeyedUnarchiver *unarchiver &#x3D; [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</span><br><span class="line">    &#x2F;&#x2F;接收反归档得到的对象</span><br><span class="line">    id object &#x3D; [unarchiver decodeObjectForKey:key];</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dict &#x3D; @&#123;@&quot;1&quot;:@&quot;ding&quot;, @&quot;2&quot;:@&quot;guan&quot;, @&quot;3&quot;:@&quot;xiong&quot;&#125;;</span><br><span class="line">[TestObj archiverObject:dict byKey:@&quot;cache&quot; withPath:@&quot;cache.plist&quot;];</span><br><span class="line"></span><br><span class="line">NSDictionary *result &#x3D; [TestObj unarchiverObjectByKey:@&quot;cache&quot; withPath:@&quot;cache.plist&quot;];</span><br><span class="line">NSLog(@&quot;***::%@&quot;, result);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头文件定义&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="代码库" scheme="https://gsl201600.github.io/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
</feed>
