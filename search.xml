<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[适配iPhoneX、iPhoneXs、iPhoneXs Max、iPhoneXr屏幕尺寸及安全区域]]></title>
    <url>%2F2020%2F12%2F30%2F%E9%80%82%E9%85%8DiPhoneXiPhoneXsiPhoneXsMaxiPhoneXr%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E5%8F%8A%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[先来认识px与pt区别px就是表示pixel像素，是屏幕上显示数据的最基本的点，它不是自然界的长度单位，点的大小是会变的，也称为相对长度；pt就是point，是印刷行业常用单位磅，等于1/72英寸，所以它是一个自然界标准的长度单位，也称为绝对长度。 我们再来了解缩放因子(scale factor between logic point and device pixel)早期的iPhone3GS的屏幕分辨率是320*480(PPI=163)，iOS绘制图形(CGPoint/CGSize/CGRect)均以point为单位：1 point = 1 pixel后来在iPhone4中，同样大小3.5 inch的屏幕采用了Retina显示技术，横、纵向方向像素密度都被放大到2倍，像素分辨率提高到(320x2)x(480x2)= 960x640(PPI=326)显像分辨率提升至iPhone3GS的4倍（1个Point被渲染成1个2x2的像素矩阵）但是对于开发者来说，iOS绘制图形的API依然沿袭point为单位。在同样的逻辑坐标系下：1 point = scale*pixel（在iPhone4~6中，缩放因子scale=2；在iPhone6+中，缩放因子scale=3） iPhone 各种机型尺寸信息列表入下表： 机型 尺寸 逻辑缩放因子(UIKit Scale factor) 实际缩放因子(Native Scale factor) 屏幕宽高(开发尺寸) 屏幕分辨率 是否全面屏 有无刘海 3GS 3.5寸 1.0 1.0 320x480 320x480 非全面屏 无 4(S) 3.5寸 2.0 2.0 320x480 640x960 非全面屏 无 5(C)／5(S)/SE 4寸 2.0 2.0 320x568 640x1136 非全面屏 无 6(S)／7／8 4.7寸 2.0 2.0 375x667 750x1334 非全面屏 无 6(S)+／7+／8+ 5.5寸 3.0 2.608 414x736 1080x1920 非全面屏 无 X/XS 5.8寸 3.0 3.0 375x812 1125x2436 全面屏 有 XR 6.1寸 2.0 2.0 414×896 828 x1792 全面屏 有 XS Max 6.5寸 3.0 3.0 414×896 1242x2688 全面屏 有 需要注意的地方是6(S)+／7+／8+的时候，实际的缩放因子并不等于逻辑上的缩放因子。所以，他的屏幕分辨率是1080x1920而不是1242x2208上述数据，可以通过代码获取逻辑缩放因子、逻辑屏幕宽度；实际缩放/物理因子、实际/物理屏幕宽度：123456789&#x2F;&#x2F;逻辑缩放因子[UIScreen mainScreen].scale&#x2F;&#x2F;逻辑屏幕宽度[UIScreen mainScreen].bounds &#x2F;&#x2F;实际&#x2F;物理缩放因子[UIScreen mainScreen].nativeScale&#x2F;&#x2F;实际&#x2F;物理屏幕宽度[UIScreen mainScreen].nativeBounds 适配常用宏123456789101112131415161718192021222324&#x2F;&#x2F;获得屏幕的宽高#define kScreenWidth [UIScreen mainScreen].bounds.size.width#define kScreenHeight [UIScreen mainScreen].bounds.size.height&#x2F;&#x2F;iPhoneX &#x2F; iPhoneXS#define isIphoneX_XS kScreenWidth &#x3D;&#x3D; 375.f &amp;&amp; kScreenHeight &#x3D;&#x3D; 812.f ? YES : NO&#x2F;&#x2F;iPhoneXR &#x2F; iPhoneXSMax#define isIphoneXR_XSMax kScreenWidth &#x3D;&#x3D; 414.f &amp;&amp; kScreenHeight &#x3D;&#x3D; 896.f ? YES : NO&#x2F;&#x2F;异性全面屏#define isFullScreen isIphoneX_XS || isIphoneXR_XSMax&#x2F;&#x2F; Status bar height.#define StatusBarHeight isFullScreen ? 44.f : 20.f&#x2F;&#x2F; Navigation bar height.#define NavigationBarHeight 44.f&#x2F;&#x2F; Tabbar height.#define TabbarHeight isFullScreen ? (49.f+34.f) : 49.f&#x2F;&#x2F; Tabbar safe bottom margin.#define TabbarSafeBottomMargin isFullScreen ? 34.f : 0.f&#x2F;&#x2F; Status bar &amp; navigation bar height.#define StatusBarAndNavigationBarHeight isFullScreen ? 88.f : 64.f 获取安全区域1234567891011121314151617181920212223242526272829303132+ (CGRect)GetSafeAreaImpl&#123; UIView *view &#x3D; UIApplication.sharedApplication.windows.lastObject;&#x2F;&#x2F; UIView *view &#x3D; (UIView *)GetAppController().unityView; CGRect area &#x3D; [self CustomComputeSafeArea:view]; &#x2F;&#x2F; x &#x3D; area.origin.x; &#x2F;&#x2F; y &#x3D; area.origin.y; &#x2F;&#x2F; w &#x3D; area.size.width; &#x2F;&#x2F; h &#x3D; area.size.height; return area;&#125;+ (CGRect)CustomComputeSafeArea:(UIView *)view&#123; CGSize screenSize &#x3D; view.bounds.size; CGRect screenRect &#x3D; CGRectMake(0, 0, screenSize.width, screenSize.height); UIEdgeInsets insets &#x3D; UIEdgeInsetsMake(0, 0, 0, 0); if (@available(iOS 11.0, *)) &#123; insets &#x3D; [view safeAreaInsets]; &#125; screenRect.origin.x &#x3D; screenRect.origin.x + insets.left; screenRect.origin.y &#x3D; screenRect.origin.y + insets.top;&#x2F;&#x2F; screenRect.size.width -&#x3D; insets.left + insets.right; screenRect.size.width &#x3D; screenRect.size.width - (insets.left + insets.right); screenRect.size.height &#x3D; screenRect.size.height - (insets.top + insets.bottom); &#x2F;&#x2F; 乘以缩放因子，根据需求可以省略 float scale &#x3D; view.contentScaleFactor; screenRect.origin.x &#x3D; screenRect.origin.x * scale; screenRect.origin.y &#x3D; screenRect.origin.y * scale; screenRect.size.width &#x3D; screenRect.size.width * scale; screenRect.size.height &#x3D; screenRect.size.height * scale; return screenRect;&#125; 启动图数据 有刘海机型安全区域，有无刘海机型开发尺寸对比图]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 初探 AFNetworking]]></title>
    <url>%2F2020%2F07%2F08%2FiOS%E5%88%9D%E6%8E%A2AFNetworking%2F</url>
    <content type="text"><![CDATA[本文不对AFNetworking作全面的解析，仅对比解析一下2.x和3.x的差异。 AFNetworking分为如下5个功能模块： 网络通信模块(AFURLSessionManager、AFHTTPSessionManger) 网络状态监听模块(Reachability) 网络通信安全策略模块(Security) 网络通信信息序列化/反序列化模块(Serialization) 对于iOS UIKit库的扩展(UIKit) AFNetworking 2.x需要常驻线程而3.x不需要常驻线程2.x常驻线程用来并发请求和处理数据回调，避免多个网络请求的线程开销(不用开辟一个线程，就保活一条线程)；而3.x不需要常驻线程是因为NSURLSession可以指定回调delegateQueue，NSURLConnection不行；NSURLConnection的一大痛点就是：发起请求后，需要一直处于等待回调的状态。而3.x后NSURLSession解决了这个问题；NSURLSession发起的请求，不再需要在当前线程进行回调，可以指定回调的delegateQueue，这样就不用为了等待代理回调方法而保活线程了 3.x需要设置最大并发数为1(self.operationQueue.maxConcurrentOperationCount = 1)，2.x为什么不需要功能不一样：3.x的operationQueue是用来接收NSURLSessionDelegate回调的，鉴于一些多线程数据访问的安全性考虑，设置了maxConcurrentOperationCount = 1来达到并发的请求串行的进行回调的效果。而2.x的operationQueue是用来添加operation进行并发请求的，所以不要设置为1注意：并发数并不等于所开辟的线程数，具体开辟几条线程由系统决定 3.x为什么要串行回调 123456789- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate &#x3D; nil; [self.lock lock]; &#x2F;&#x2F;给所要访问的资源加锁，防止造成数据混乱 delegate &#x3D; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)]; [self.lock unlock]; return delegate;&#125; 从代码可以看出，这边对self.mutableTaskDelegatesKeyedByTaskIdentifier的访问进行了加锁，目的是保证多线程环境下的数据安全。既然加了锁，就算maxConcurrentOperationCount不设为1，当某个请求正在回调时，下一个请求还是得等待一直到上个请求获取完所要的资源后解锁，所以这边并发回调也是没有意义的。相反多task回调导致的多线程并发，还会导致性能的浪费]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 正则匹配常用方法]]></title>
    <url>%2F2020%2F07%2F08%2FiOS%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[验证手机号123456&#x2F;&#x2F; 验证手机号+ (BOOL)isValidatePhone:(NSString *)phone&#123; NSString *phoneRegex &#x3D; @&quot;^1([358][0-9]|4[579]|66|7[0135678]|9[89])[0-9]&#123;8&#125;$&quot;; NSPredicate *phoneTest &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, phoneRegex]; return [phoneTest evaluateWithObject:phone];&#125; 邮箱账号有效性判断123456&#x2F;&#x2F; 邮箱账号的有效性判断+ (BOOL)isValidateEmail:(NSString *)email&#123; NSString * emailRegex &#x3D; @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;&quot;; NSPredicate * emailTest &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex]; return [emailTest evaluateWithObject:email];&#125; 匹配密码格式(长度6~20位，只能是数字、大小写字母)123456&#x2F;&#x2F; 匹配密码格式+ (BOOL)isValidatePassword:(NSString *)password&#123; NSString * passwordRegex &#x3D; @&quot;[a-zA-Z0-9]&#123;6,20&#125;&quot;; NSPredicate * passwordTest &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, passwordRegex]; return [passwordTest evaluateWithObject:password];&#125; 车牌号码判断1234567891011121314151617&#x2F;&#x2F; 车牌号码正则表达式+ (BOOL)isValidateCarID:(NSString *)carID&#123; if (carID.length&#x3D;&#x3D;7) &#123; &#x2F;&#x2F;普通汽车，7位字符，不包含I和O，避免与数字1和0混淆 NSString *carRegex &#x3D; @&quot;^[\u4e00-\u9fa5]&#123;1&#125;[a-hj-np-zA-HJ-NP-Z]&#123;1&#125;[a-hj-np-zA-HJ-NP-Z0-9]&#123;4&#125;[a-hj-np-zA-HJ-NP-Z0-9\u4e00-\u9fa5]$&quot;; NSPredicate *carTest &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, carRegex]; return [carTest evaluateWithObject:carID]; &#125;else if(carID.length&#x3D;&#x3D;8)&#123; &#x2F;&#x2F;新能源车,8位字符，第一位：省份简称（1位汉字），第二位：发牌机关代号（1位字母）; &#x2F;&#x2F;小型车，第三位：只能用字母D或字母F，第四位：字母或者数字，后四位：必须使用数字;([DF][A-HJ-NP-Z0-9][0-9]&#123;4&#125;) &#x2F;&#x2F;大型车3-7位：必须使用数字，后一位：只能用字母D或字母F。([0-9]&#123;5&#125;[DF]) NSString *carRegex &#x3D; @&quot;^[\u4e00-\u9fa5]&#123;1&#125;[a-hj-np-zA-HJ-NP-Z]&#123;1&#125;([0-9]&#123;5&#125;[d|f|D|F]|[d|f|D|F][a-hj-np-zA-HJ-NP-Z0-9][0-9]&#123;4&#125;)$&quot;; NSPredicate *carTest &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, carRegex]; return [carTest evaluateWithObject:carID]; &#125; return NO;&#125; 身份证号判断12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F; 身份证号段正则表达式+ (BOOL)isValidateIDCard:(NSString *)identityString&#123; if (identityString.length !&#x3D; 18) return NO; &#x2F;&#x2F; 正则表达式判断基本 身份证号是否满足格式 NSString *regex2 &#x3D; @&quot;^(^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$)|(^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])((\\d&#123;4&#125;)|\\d&#123;3&#125;[Xx])$)$&quot;; NSPredicate *identityStringPredicate &#x3D; [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex2]; &#x2F;&#x2F;如果通过该验证，说明身份证格式正确，但准确性还需计算 if(![identityStringPredicate evaluateWithObject:identityString]) return NO; &#x2F;&#x2F;** 开始进行校验 *&#x2F;&#x2F; &#x2F;&#x2F;将前17位加权因子保存在数组里 NSArray *idCardWiArray &#x3D; @[@&quot;7&quot;, @&quot;9&quot;, @&quot;10&quot;, @&quot;5&quot;, @&quot;8&quot;, @&quot;4&quot;, @&quot;2&quot;, @&quot;1&quot;, @&quot;6&quot;, @&quot;3&quot;, @&quot;7&quot;, @&quot;9&quot;, @&quot;10&quot;, @&quot;5&quot;, @&quot;8&quot;, @&quot;4&quot;, @&quot;2&quot;]; &#x2F;&#x2F;这是除以11后，可能产生的11位余数、验证码，也保存成数组 NSArray *idCardYArray &#x3D; @[@&quot;1&quot;, @&quot;0&quot;, @&quot;10&quot;, @&quot;9&quot;, @&quot;8&quot;, @&quot;7&quot;, @&quot;6&quot;, @&quot;5&quot;, @&quot;4&quot;, @&quot;3&quot;, @&quot;2&quot;]; &#x2F;&#x2F;用来保存前17位各自乖以加权因子后的总和 NSInteger idCardWiSum &#x3D; 0; for(int i &#x3D; 0;i &lt; 17;i++) &#123; NSInteger subStrIndex &#x3D; [[identityString substringWithRange:NSMakeRange(i, 1)] integerValue]; NSInteger idCardWiIndex &#x3D; [[idCardWiArray objectAtIndex:i] integerValue]; idCardWiSum +&#x3D; subStrIndex * idCardWiIndex; &#125; &#x2F;&#x2F;计算出校验码所在数组的位置 NSInteger idCardMod&#x3D;idCardWiSum%11; &#x2F;&#x2F;得到最后一位身份证号码 NSString *idCardLast&#x3D; [identityString substringWithRange:NSMakeRange(17, 1)]; &#x2F;&#x2F;如果等于2，则说明校验码是10，身份证号码最后一位应该是X if(idCardMod&#x3D;&#x3D;2) &#123; if(![idCardLast isEqualToString:@&quot;X&quot;]||[idCardLast isEqualToString:@&quot;x&quot;]) &#123; return NO; &#125; &#125;else&#123; &#x2F;&#x2F;用计算出的验证码与最后一位身份证号码匹配，如果一致，说明通过，否则是无效的身份证号码 if(![idCardLast isEqualToString: [idCardYArray objectAtIndex:idCardMod]]) &#123; return NO; &#125; &#125; return YES;&#125; 随机获取八位字符1234567891011121314151617- (NSString *)obtain8RandomCode &#123; NSArray *changeArray &#x3D; [[NSArray alloc] initWithObjects:@&quot;0&quot;,@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;A&quot;,@&quot;B&quot;,@&quot;C&quot;,@&quot;D&quot;,@&quot;E&quot;,@&quot;F&quot;,@&quot;G&quot;,@&quot;H&quot;,@&quot;I&quot;,@&quot;J&quot;,@&quot;K&quot;,@&quot;L&quot;,@&quot;M&quot;,@&quot;N&quot;,@&quot;O&quot;,@&quot;P&quot;,@&quot;Q&quot;,@&quot;R&quot;,@&quot;S&quot;,@&quot;T&quot;,@&quot;U&quot;,@&quot;V&quot;,@&quot;W&quot;,@&quot;X&quot;,@&quot;Y&quot;,@&quot;Z&quot;,@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,@&quot;d&quot;,@&quot;e&quot;,@&quot;f&quot;,@&quot;g&quot;,@&quot;h&quot;,@&quot;i&quot;,@&quot;j&quot;,@&quot;k&quot;,@&quot;l&quot;,@&quot;m&quot;,@&quot;n&quot;,@&quot;o&quot;,@&quot;p&quot;,@&quot;q&quot;,@&quot;r&quot;,@&quot;s&quot;,@&quot;t&quot;,@&quot;u&quot;,@&quot;v&quot;,@&quot;w&quot;,@&quot;x&quot;,@&quot;y&quot;,@&quot;z&quot;,@&quot;!&quot;,@&quot;@&quot;,@&quot;#&quot;,@&quot;$&quot;,@&quot;^&quot;,@&quot;&amp;&quot;,@&quot;*&quot;,@&quot;-&quot;,@&quot;+&quot;,nil]; NSArray *specailArray &#x3D; [[NSArray alloc] initWithObjects:@&quot;!&quot;,@&quot;@&quot;,@&quot;#&quot;,@&quot;$&quot;,@&quot;^&quot;,@&quot;&amp;&quot;,@&quot;*&quot;,@&quot;-&quot;,@&quot;+&quot;, nil]; NSMutableString *changeString &#x3D; [[NSMutableString alloc] initWithCapacity:8]; NSInteger specialIndex &#x3D; arc4random()%7; NSInteger specialArrayIndex &#x3D; arc4random()%([specailArray count] - 1); for(int i &#x3D; 0; i &lt; 8; i++)&#123; if (i&#x3D;&#x3D;specialIndex) &#123; changeString &#x3D; (NSMutableString *)[changeString stringByAppendingString:[specailArray objectAtIndex:specialArrayIndex]]; continue; &#125; NSInteger index &#x3D; arc4random()%([changeArray count] - 1); changeString &#x3D; (NSMutableString *)[changeString stringByAppendingString:[changeArray objectAtIndex:index]]; &#125; return changeString;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 内购项目的App Store推广]]></title>
    <url>%2F2020%2F05%2F27%2FiOS%E5%86%85%E8%B4%AD%E9%A1%B9%E7%9B%AE%E7%9A%84AppStore%E6%8E%A8%E5%B9%BF%2F</url>
    <content type="text"><![CDATA[iOS 11以后的用户可以在App Store内的下载页面内直接购买应用的内购商品，这项功能苹果称作做Promoting In-App Purchases，如果你的App需要在App Store推广自己的内购商品，则需要在App Store推广里上传推广用的图像，另外苹果也在iOS11 SDK里面新增了从App Store购买内购项目跳转到App的新方法 选择推广App内购买项目的好处 提高展示促销机会，在产品页面上，开发者可一次性推广多达20个App内购买项目 提高下载量，App内购买项目的推广还能促进App的下载量。如果用户尚未安装App，在点击购买App内购项目时，会引导其先下载 如何推广App内购买项目 在App Store Connect中为准备推广的App内购买项目上传宣传图像。该图像不但会显示在App Store产品页面，也可能显示在搜索结果中。如果入选精品推荐，它更可能显示在Today、游戏今日亮点、App今日亮点中。当App内购买项目显示在App Store产品页面以外的地方（如搜索结果中），App图标会显示在外框的左下方，所以要确保设计的宣传图像不会被外框遮盖，注意重要细节不要放在左下角，不建议在图像上叠加文字 App Store后台内购项目的配置，默认情况下，推广的App内购买项目将面向所有设备显示，即使它们没有安装App。①在工具栏中，点按功能，然后在左列中点按App 内购买项目。②点需要修改的App内购买项目，然后前往App Store 推广部分。③配置面向所有 App Store 用户显示，即使是没有安装该 App 的用户复选框设置。④点按存储。⑤在左列中点按App Store 推广，勾选需要推广的项目 开发者需注意 iOS11以上用户可见，所以产品需要针对iOS11以上系统兼容 开发者显示App内购买项目推广后，不一定被显示在苹果搜索结果中，只是可能 苹果明确规定只有除消耗型 App 内购买项目会显示在搜索结果中 产品提供订阅获取收益十分可观，从而苹果针对自动续期订阅也十分看重，并且为其提供了相关设置方法及运营手段的介绍，所以开发者们可重点尝试App内购买项目中自动续期订阅形式展示，能够得到苹果更多认可及展示 游戏开发者可考虑利用关卡设置App 内购买项目的形式吸引苹果关注，不同关卡有不同的App 内购买项目（非消耗型）或完整体验需付费的形式，类似这类App苹果是给予鼓励的 用户直接在App下载页面购买内购商品，这就涉及到从App Store跳转到自己App，所以苹果在SKPaymentTransactionObserver新增了一个代理方法：- (BOOL)paymentQueue:(SKPaymentQueue *)queue shouldAddStorePayment:(SKPayment *)payment forProduct:(SKProduct *)product这个代理函数是在App Store发起购买的时候会有回调，用户如果在App下载页面点击购买你推广的内购商品，如果用户已经安装过你的App则会直接跳转你的App并调用上述代理方法；如果用户还没有安装你的App那么就会去下载你的App，下载完成之后系统会推送一个通知，如果用户点击该通知就会跳转到你的App并且调用上面的代理方法上面的代理方法返回YES则表示跳转到你的App，IAP继续完成交易，如果返回NO则表示推迟或者取消购买，实际开发中因为可能还需要用户登录自己的账号、生成订单等，一般都是返回NO，之后自己手动把代理方法里面返回的SKPayment加入支付队列，然后在按照自己的支付、验证逻辑完成支付 测试苹果提了测试方法，就是修改下面的链接地址，然后在safari浏览器打开，就可以测试从App Store发起购买了。其中链接中的bundleId修改为你自己应用的bundleId，productId修改为你创建的商品的id，如：itms-services://?action=purchaseIntent&amp;bundleId=bundleId&amp;productIdentifier=productId 附：iOS 内购总结附：[官方文档] What’s New in StoreKit附：[官方文档] App Store Connect 帮助附：[官方文档] 推广您的 App 内购买项目附：[官方文档] Testing Promoted In-App Purchases附：Promoting-In-App-PurchasesDemo]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS block原理详解]]></title>
    <url>%2F2020%2F05%2F13%2FiOSblock%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[block本质 block底层就是一个struct __main_block_impl_0类型的结构体，这个结构体中包含一个isa指针，本质上是一个OC对象 block是封装了函数调用以及函数调用环境的OC对象 block底层结构block底层结构就是__main_block_impl_0结构体，内部包含了impl结构体和Desc结构体以及外部需要访问的变量，block将需要执行的代码放到一个函数里，impl内部的FuncPtr指向这个函数的地址，通过地址调用这个函数，就可以执行block里面的代码了。Desc用来描述block，内部的reserved作保留，Block_size描述block占用内存 block的变量捕获局部变量block访问方式是值传递，auto自动变量可能会销毁，内存可能会消失，不采用指针访问；局部静态变量block访问方式是指针传递，static变量一直保存在内存中，指针访问即可;全局变量、静态全局变量block不需要对变量捕获，直接取值 123456789101112131415161718&#x2F;&#x2F; block的变量捕获代码解析如下auto int age &#x3D; 10;static int height &#x3D; 10; void (^block)(void) &#x3D; ^&#123; NSLog(@&quot;age is %d,height is %d&quot;,age,height);&#125;; age &#x3D; 20;height &#x3D; 20; block();-------------------------------------------------output: age is 10,height is 20struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int age; &#x2F;&#x2F; 值传递 int *height; &#x2F;&#x2F; 指针传递&#125; block的类型 block类型 环境 存储域 copy操作后 __NSGlobalBlock__ 没有访问auto变量 数据区 什么也不做，类型不改变 __NSStackBlock__ 访问了auto变量 栈区 从栈复制到堆，类型改变为__NSMallocBlock__ __NSMallocBlock__ __NSStackBlock__调用了copy 堆区 引用计数+1，类型不改变 在ARC下Block访问auto变量时系统默认帮我们进行了copy操作，NSGlobalBlock访问了auto变量时会变成NSStackBlock，当NSStackBlock进行copy操作后会变成NSMallocBlock 在ARC环境下，编译器会根据以下几种情况自动将栈上的block复制到堆上:1、block作为函数返回值时，比如使用=2、将block赋值给__strong指针时3、block作为Cocoa API中方法名含有usingBlock的方法参数时4、block作为GCD API的方法参数时 对象类型的auto变量 当block内部访问了对象类型的auto变量时:如果block在栈空间，不论是ARC还是MRC环境，不管外部变量是强引用还是弱引用，block都会弱引用访问对象如果block在堆空间，如果外部强引用，block内部也是强引用；如果外部弱引用，block内部也是弱引用 栈block：a) 如果block是在栈上，将不会对auto变量产生强引用b) 栈上的block随时会被销毁，也没必要去强引用其他对象 堆block：1、如果block被拷贝到堆上a) 会调用block内部的copy函数b) copy函数内部会调用_Block_object_assign函数c) _Block_object_assign函数会根据auto变量的修饰符__strong、__weak、__unsafe_unretained做出相应的操作，形成强引用或者弱引用2、如果block从堆上移除a) 会调用block内部的dispose函数b) dispose函数内部会调用_Block_object_dispose函数c) _Block_object_dispose函数会自动释放引用的auto变量(release，引用计数-1，若为0，则销毁) __block __block修饰符作用：__block可以用于解决block内部无法修改auto变量值的问题__block不能修饰全局变量、静态变量static __block修饰符原理：编译器会将__block变量包装成一个结构体__Block_byref_age_0，结构体内部*__forwarding是指向自身的指针，内部还存储着外部auto变量的值__block的forwarding指针如下图： 栈上，__block结构体中的__forwarding指针指向自己，一旦复制到堆上，栈上的__block结构体中的__forwarding指针会指向堆上的__block结构体，堆上__block结构体中的__forwarding还是指向自己。假设age是栈上的变量，age-&gt;__forwarding会拿到堆上的__block结构体，age-&gt;__forwarding-&gt;age会把20赋值到堆上，不论是栈上还是堆上的__block结构体，都能保证20赋值到堆的结构体里 思考题：block修改NSMutableString、NSMutableArray、NSMutableDictionary，需不需要添加__block题目如下：以下代码是否可以正确执行123456789101112int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSMutableArray *array &#x3D; [NSMutableArray array]; void (^block)(void) &#x3D; ^&#123; [array addObject: @&quot;5&quot;]; [array addObject: @&quot;5&quot;]; NSLog(@&quot;%@&quot;,array); &#125;; block(); &#125; return 0;&#125; 分析：可以正确执行，因为在block块中仅仅是使用了array的内存地址，往内存地址中添加内容，并没有修改arry的内存地址，因此array不需要使用__block修饰也可以正确编译。当仅仅是使用局部变量的内存地址，而不是修改的时候，尽量不要添加__block，通过上述分析我们知道一旦添加了__block修饰符，系统会自动创建相应的结构体，占用不必要的内存空间]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 数据结构]]></title>
    <url>%2F2020%2F05%2F06%2FiOS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数组和链表的区别 数组地址连续，查找速度快，操作效率低存储单元在定义时分配，元素个数固定，内存空间要求高 链表地址不连续，查找速度慢，操作效率高存储单元在程序执行时动态申请，可按需动态增减 iOS内存分区的情况，五大区域 栈区Stack先进后出FILO由编译器自动分配和释放栈空间多线程不共享连续的内存地址，由高向低分配，不会产生碎片空间较小，运行速度较快，效率高栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高 堆区Heap分配方式类似链表，先进先出FIFO一般需要手动分配和释放堆内存多线程共享不连续的内存地址，由低向高分配，容易产生碎片空间较大，运行速度较慢，效率不如栈计算机底层并没有对堆的支持，堆是有C/C++函数库提供的，加上碎片问题，导致堆的效率比栈低 全局区全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域.data段，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域.bss段程序结束后由系统释放 常量区常量字符串就是放在这里的程序结束后由系统释放 代码区存放函数体的二进制代码 当一个app启动后，代码区、常量区、全局区大小就已经固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错） Hash表哈希表(Hash table，也叫散列表)是根据键Key直接访问在内存中存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。通俗讲就是把Key通过一个固定的算法函数(hash函数)转换成一个整型数字，然后就对该数字用数组的长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。当使用hash表查询时，就是使用hash函数将key转换成对应的数组下标，并定位到该下标的数组空间里获取value，这样就充分利用到数组的定位性能进行数据定位 iOS里有哪些地方用到了Hash表]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Crash文件获取及符号化]]></title>
    <url>%2F2020%2F04%2F29%2FiOSCrash%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%8F%8A%E7%AC%A6%E5%8F%B7%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Crash文件获取 大致可以分为两种方式：远程获取和本地获取；具体可以分为如下四种途径 1.1. 远程获取；已经上传到iTunes Connect的应用，可以通过iTunes Connect的App分析查看App崩溃情况不会有崩溃日志，如果是TestFlight测试，则可以在iTunes Connect获取到崩溃日志 1.2. 远程获取；通过Xcode菜单Window -&gt; Organizer -&gt; Crashes获取用户的崩溃日志 注意：以上两种途径都需要登录开发者账号，并且需要用户共享iPhone分析，才能够获取到用户的崩溃日志 注意：官方提供的崩溃信息并不是实时的，只能查看两天之前的崩溃信息，需要实时的可以使用第三方工具 1.3. 本地获取；在手机上设置 -&gt; 隐私 -&gt; 分析与改进 -&gt; 分析数据中，根据应用名称和日期时间找到你需要的日志，点击进去后，右上角会有个分享按钮，分享给Mac 1.4. 把手机连接到Mac，通过Xcode菜单Window -&gt; Devices and Simulators -&gt; Devices -&gt; View Device Logs获取用户的崩溃日志 注意某些iOS系统会没有上面提到的分享按钮，这时候可以全选复制，再发送给Mac Crash文件符号化 大致也是分为两种方式：使用Xcode自动符号化和通过手动命令行工具symbolicatecrash符号化；这两种方式原理一样，都需要dSYM文件，只不过前者是Xcode自动帮我们完成的 注意：如果你们的应用是通过Xcode上传iTunes Connect的，并同时上传了.xcarchive文件(实际上是一个文件夹，包含.ipa和.dSYM文件)，Xcode会默认帮你勾选该选项，那么从iTunes Connect获取到的日志就已经是符号化过的了 2.1. 使用Xcode自动符号化Crash文件，Xcode自带的工具非常好用 如果你用的Mac就是打包的机子，并且得到了发生崩溃的手机，那么手机连接电脑，通过Xcode菜单Window -&gt; Devices and Simulators -&gt; Devices -&gt; View Device Logs找到自己的日志，就是符号化过后的，如果没有符号化，就稍微等待一会儿，或者右击点出菜单选择Re-Symbolicate Log 如果只有Mac出包机，没有手机只有崩溃日志，那么同样可以通过Xcode菜单Window -&gt; Devices and Simulators -&gt; Devices -&gt; View Device Logs把崩溃日志直接拖进去，就是符号化过后的，如果没有符号化，就稍微等待一会儿，或者右击点出菜单选择Re-Symbolicate Log 注意：在有些版本的Xcode是拖不进去的，遇到这种情况可以用下面的手动符号化方式 注意：上面的方法不一定要是出包机，本质是只要你的电脑上有dSYM文件，Xcode就能自动找到他并为你符号化 2.2. 通过终端命令行工具symbolicatecrash符号化大概需要如下三个文件，下面是获取这些文件的方法 通过菜单Xcode -&gt; Window -&gt; Organizer -&gt; Archiver找到打包的项目，右键Show In Finder，找到AppName.xcarchive，右键显示包内容，找到AppName.app.dSYM 在桌面创建一个文件夹tmp，将以上两个文件拷贝到tmp文件夹中 打开终端，用find /Applications/Xcode.app -name symbolicatecrash -type f查找symbolicatecrash，其中/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash路径是需要的symbolicatecrash文件，将symbolicatecrash文件也拷贝到tmp文件夹中 将需要分析的crash文件也拷贝到tmp文件夹中，crash文件的格式可能是.beta、.crash或.ips 在终端中使用以下命令行，crash文件格式以.crash为例123456# 进入到 tmp 文件夹中cd ~&#x2F;Desktop&#x2F;tmp # 分析 crash 文件，会在 &#96;tmp&#96; 文件夹中生成 crash.log 文件.&#x2F;symbolicatecrash .&#x2F;xxx.crash .&#x2F;AppName.app.dSYM &gt; crash.log或.&#x2F;symbolicatecrash .&#x2F;xxx.crash .&#x2F;.app.dSYM &gt; crash.log 如果终端报类似这样的错zsh: permission denied: ./symbolicatecrash说明是symbolicatecrash文件有问题，可能该文件不是本机获取的，或者是之前获取的、Xcode升级等问题造成的，重新在本机上按上面方法获取即可 如果终端报类似这样的错Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.尝试以下命令后，再重复上面命令，正常情况就可以分析bug了export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer 符号化之前，首先得确保Crash文件和dSYM这两个文件里面的UUID是一致的，如果不一致，就说明不是本次Crash对应的文件，就不能进行符号化；查看dSYM文件里面的UUID命令：dwarfdump --uuid AppName.app.dSYM；查看Crash文件文件的UUID就比较简单了，直接打开，Crash最上面的就是各种信息，不同系统版本给的格式可能会有不同，下图内容为参考 Xcode在Debug模式下默认关闭生成dSYM文件，Release模式下默认生成dSYM文件的， 要生成dSYM文件需要查看一下项目的Build Settigns -&gt; Build Options -&gt; Debug information Format属性；只有该属性设置为DWARF with dSYM File时，编译才会生成dSYM文件 该文是在Xcode 11.2和iOS 13.2上写的教程，不同的系统版本的Xcode和手机系统获取路径和符号化方式会有变化]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 时间日期总结]]></title>
    <url>%2F2020%2F04%2F22%2FiOS%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[获取时间戳 单位秒，保留六位有效数字，格式如：1574068247.54510312NSDate *datenow &#x3D; [NSDate date];NSString *timeSp &#x3D; [NSString stringWithFormat:@&quot;%f&quot;, (double)[datenow timeIntervalSince1970]]; 单位秒，整数，格式如：157406826512NSDate *datenow &#x3D; [NSDate date];NSString *timeSp &#x3D; [NSString stringWithFormat:@&quot;%ld&quot;, (long)[datenow timeIntervalSince1970]]; 单位毫秒，整数，不精确，后面直接补三个0，格式如：157406860200012NSDate *datenow &#x3D; [NSDate date];NSString *timeSp &#x3D; [NSString stringWithFormat:@&quot;%ld&quot;, (long)[datenow timeIntervalSince1970]*1000]; 单位毫秒，整数，精确，格式如：157407008238712345&#x2F;&#x2F; 获取当前时间0秒后的时间NSDate *date &#x3D; [NSDate dateWithTimeIntervalSinceNow:0];&#x2F;&#x2F; *1000 是精确到毫秒，不乘就是精确到秒NSTimeInterval time &#x3D; [date timeIntervalSince1970]*1000;NSString *timeStr &#x3D; [NSString stringWithFormat:@&quot;%.0f&quot;, time]; 时间戳转日期1234567&#x2F;&#x2F; 传入的时间戳timeStr如果是精确到毫秒的记得要&#x2F;1000NSTimeInterval timeInterval &#x3D; [timeStr doubleValue]&#x2F;1000;NSDate *detailDate &#x3D; [NSDate dateWithTimeIntervalSince1970:timeInterval];NSDateFormatter *dateFormatter &#x3D; [[NSDateFormatter alloc] init];&#x2F;&#x2F; 实例化一个NSDateFormatter对象，设定时间格式，这里可以设置成自己需要的格式[dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss SS&quot;];NSString *dateStr &#x3D; [dateFormatter stringFromDate:detailDate]; 两个日期比较12345678910111213&#x2F;&#x2F;1.将这两个时间戳转换成日期NSDate *date1 &#x3D; [NSDate dateWithTimeIntervalSince1970:1451047216];NSDate *date2 &#x3D; [NSDate dateWithTimeIntervalSince1970:1451847216];&#x2F;&#x2F;2.开始比较&#x2F;&#x2F; 比较date1是不是比date2早——&gt;会返回一个比较早的日期NSDate *date3 &#x3D; [date1 earlierDate:date2];NSLog(@&quot;比较早的日期：%@&quot;,date3);&#x2F;&#x2F;比较两个日期谁比谁晚NSDate *date4 &#x3D; [date1 laterDate:date2];NSLog(@&quot;比较晚的日期：%@&quot;,date4);&#x2F;&#x2F; 比较两个日期 是不是相同 ——&gt;返回值BOOL类型BOOL result &#x3D; [date1 isEqualToDate:date2];NSLog(@&quot;%d&quot;,result); 可以解决跨年、跨月、平闰年时间处理问题1234567&#x2F;&#x2F; 100天后NSDate *date &#x3D; [NSDate dateWithTimeIntervalSinceNow:60 * 60 * 24 * 100];NSDate *nowDate &#x3D; [NSDate date];&#x2F;&#x2F; 日期升序if ([nowDate compare:date] &#x3D;&#x3D; NSOrderedAscending) &#123; NSLog(@&quot;如果打印，nowDate比ndate时间早，如nowDate&#x3D;2019-11-18， ndate&#x3D;2020-02-26&quot;);&#125; 日历组件NSCalendar12345678910NSDate *nowDate &#x3D; [NSDate date];NSCalendar *calendar &#x3D; [NSCalendar currentCalendar];&#x2F;&#x2F; 初始化日历组件，可以选择需要的组件NSDateComponents *comps &#x3D; [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitWeekday|NSCalendarUnitWeekdayOrdinal|NSCalendarUnitWeekOfMonth|NSCalendarUnitWeekOfYear|NSCalendarUnitYearForWeekOfYear fromDate:nowDate];&#x2F;&#x2F; 得到：今天是星期几，返回日期的工作日索引（1 &#x3D;星期日，2 &#x3D;星期一，…，7 &#x3D;星期六）NSInteger weekDay &#x3D; [comps weekday];&#x2F;&#x2F; 得到：今天是几号NSInteger day &#x3D; [comps day];&#x2F;&#x2F; 得到：一年中的第几周NSInteger weekOfYear &#x3D; [comps weekOfYear]; 常见NSDateFormatter格式可以使用以下dateFormatter符号单独格式化，拿到需要的数据进行处理 符号 说明 y/yyy/yyyy/Y/YYY/YYYY/u/uu/uuu/uuuu/U/UUU/UUUU 完整的年份 yy/YY/UU 2个数字的年份 M/MM/L/LL 1~12 第几月 MMM/LLL Jan/Feb/Mar/Apr/May/Jun/Jul/Aug/Sep/Oct/Nov/Dec 月份简写 MMMM/LLLL January/February/March/April/May/June/July/August/September/October/November/December 月份全称 d 1~31 (月份的第几天，带0) D 1~366 (年份的第几天，带0) e/c/cc 1~7 (一周的第几天，周日为1，带0) E~EEE/eee/ccc Sun/Mon/Tue/Wed/Thu/Fri/Sat (星期简写) EEEE/eeee/cccc Sunday/Monday/Tuesday/Wednesday/Thursday/Friday/Saturday (星期全拼) H 0~23 带0的时，24小时制 h 1~12 带0的时，12小时制 k 1~24 一天中的小时数，带0的时，24小时制 K 0~11 带0的时，12小时制 m 0~59 分钟 s 0~59 秒数 SSS 毫秒 a AM/PM (上午/下午) A 0~86399999 (一天的第几微秒) F 1~5 每月的第几周 w 1~53 一年的第几周，一周的开始为周日，第一周从去年的最后一个周日起算 W 1~5 一个月的第几周，一周的开始为周日 q/qq/Q/QQ 1~4 第几季度 qqq/QQQ Q1/Q2/Q3/Q4 季度简写 qqqq/QQQQ 1st quarter/2nd quarter/3rd quarter/4th quarter 季度全拼 z~zzz 指定GMT时区的缩写，GMT+8 zzzz/vvvv 指定GMT时区的名称，China Standard Time Z~ZZZ 指定GMT时区的缩写，+0800 ZZZZ 指定GMT时区的缩写，GMT+08:00 v/VVVV 指定GMT时区的名称，China mainland Time VV 指定GMT时区的名称，Asia/Shanghai VVV 指定GMT时区的名称，Shanghai]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS + Mac PE + Win PE 三合一 U盘制作教程]]></title>
    <url>%2F2020%2F04%2F08%2FMacOS%2BMacPE%2BWinPE%E4%B8%89%E5%90%88%E4%B8%80U%E7%9B%98%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[开始之前需要准备一下工具： 移动硬盘或者U盘一个 Mac OS原版安装文件 Mac PE Win PE DiskGenius分区工具 Win PE制作下载好U盘魔术师V5全能版或者通用PE工具箱等Win PE制作软件，安装到电脑打开，然后插入U盘；一般保持默认设置就行，Win PE制作完成。 Mac OS分区制作打开DiskGenius分区工具，找到刚刚制作好的U盘，然后选中这个U盘分区，右击菜单选中调整分区大小，如图： 打开调整窗口，把鼠标放在分区的右边，出现拖拉箭头，然后往左拉，或者在下方直接填写你要分的空间大小，如图： Mac OS分区的空间一般8.5G，也可以设置更大，看个人。然后点击开始，弹出对话框，选中是；制作完成之后点击完成，就会出现空闲8.5G，如图： 右击空闲的分区，选择建立新分区，选中NTFS格式，4K对齐，如图： 选择确定，然后点击左上角的保存更改，提示你格式化分区，选择是，格式化完成之后，8.5G的Mac OS分区就制作好了。 制作Mac PE分区，分9G以上；方法跟制作Mac OS分区是一样的，这里不再重复，如图： 分区基本做好了，现在转到苹果系统去写入系统文件。 格式化两个Mac分区 打开苹果电脑的磁盘工具，找到刚刚分出来的9G容量的分区，然后选择抹掉，名称为Mac PE，只为做区分用，可以随意命名；格式为Mac OS扩展 日志式；然后选择8.5G的Mac OS安装分区，步骤和上面一样，如图： Mac PE系统文件写入，打开下载好的iFen.OS X PE，解压的过程选择跳过，不跳过也行，目的是为了加载进磁盘工具里，回到磁盘工具的界面，会出现解压出来的镜像，然后选中Mac PE分区，选择菜单的恢复按钮，恢复来源选择刚刚解压出来的PE镜像，点击恢复，如图： 注意：iFen.OS X PE是基于Mac OS 10.14制作的，所以要用Mac OS 10.14的电脑才能恢复，否则会恢复失败，恢复过程的快慢就要看U盘的速度了，大概5分钟的时间。 Mac OS系统文件写入，以Mac OS 10.14系统为例，不同的系统制作代码不同，代码中的MyVolume为上面命名的U盘名称，下载好Mac OS 10.14.1系统，并把它放在Mac的应用程序里备用，打开终端，在终端输入代码：sudo /Applications/Install\ macOS\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume等待制作完成，大概5分钟，完成之后；如图： 至此，整个三合一的启动盘制作完成了，三合一U盘电脑启动界面，如图： 附：Mac OS X + Mac PE + Win PE 三合一 U盘制作教程附：[官方文档] 如何创建可引导的 macOS 安装器附：Mac PE下载地址 密码:6jkp附：最新版Mac PE]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 如何优化 App 的启动耗时]]></title>
    <url>%2F2020%2F04%2F01%2FiOS%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96App%E7%9A%84%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%2F</url>
    <content type="text"><![CDATA[iOS 的 App 启动时长大概可以这样计算： t(App 总启动时间) = t1(main 调用之前的加载时间) + t2(main 调用之后的加载时间) t1 = 系统 dylib(动态链接库)和自身 App 可执行文件的加载 t2 = main方法执行之后到AppDelegate类中的application:didFinishLaunchingWithOptions:方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示 在t1阶段加快App启动的建议： 尽量使用静态库，减少动态库的使用，动态链接比较耗时，如果要用动态库，尽量将多个dylib动态库合并成一个 尽量避免对系统库使用optional linking，如果App用到的系统库在你所有支持的系统版本上都有，就设置为required，因为optional会有些额外的检查 减少Objective-C Class、Selector、Category的数量，可以合并或者删减一些OC类 删减一些无用的静态变量，删减没有被调用到或者已经废弃的方法 将不必须在+load中做的事情尽量挪到+initialize中，+initialize是在第一次初始化这个类之前被调用，+load在加载类的时候就被调用。尽量将+load里的代码延后调用 尽量不要用C++虚函数，创建虚函数表有开销 不要使用__attribute__((constructor))将方法显式标记为初始化器，而是让初始化方法调用时才执行。比如使用dispatch_once()，pthread_once()或 std::once() 在初始化方法中不调用dlopen()，dlopen()有性能和死锁的可能性 在初始化方法中不创建线程 在t2阶段加快App启动的建议： 尽量不要使用xib/storyboard，而是用纯代码作为首页UI，如果要用xib/storyboard，不要在xib/storyboard中存放太多的视图 对application:didFinishLaunchingWithOptions:里的任务尽量延迟加载或懒加载 不要在NSUserDefaults中存放太多的数据，NSUserDefaults是一个plist文件，plist文件会被反序列化一次 避免在启动时打印过多的log，少用NSLog，因为每一次NSLog的调用都会创建一个新的NSCalendar实例 为了防止使用GCD创建过多的线程，解决方法是创建串行队列，或者使用带有最大并发数限制的NSOperationQueue 不要在主线程执行磁盘、网络、Lock或者dispatch_sync、发送消息给其他线程等操作]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS RunLoop]]></title>
    <url>%2F2020%2F01%2F17%2FiOSRunLoop%2F</url>
    <content type="text"><![CDATA[RunLoop概念 RunLoop是通过内部维护的事件循环(Event Loop)来对事件/消息进行管理的一个对象 没有消息处理时，休眠以避免资源占用；有消息需要处理时，立刻被唤醒 为什么main函数不会退出12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; UIApplicationMain内部默认开启了主线程的RunLoop，并执行了一段无限循环的代码（不是简单的for循环或while循环）UIApplicationMain函数一直没有返回，不断地接收处理消息以及等待休眠，所以运行程序之后，会保持持续运行状态 RunLoop结构体 Source1 : 基于Port的线程间通信 Source0 : 触摸事件、PerformSelector Timer : 定时器 Observer : 监听器，用于监听RunLoop的状态 RunLoop和线程 线程和RunLoop是一一对应的，其映射关系是保存在一个全局的Dictionary里，线程作为key，RunLoop作为value 自己创建的线程默认是没有开启RunLoop的 runloop在第一次获取时被创建，在线程结束时被销毁 对于主线程来说，runloop在程序一启动就默认创建好了 对于子线程来说，runloop是懒加载的，只有当我们使用的时候才会创建，所以在子线程用定时器要注意：确保子线程的runloop被创建，不然定时器不会回调 怎么创建一个常驻线程 为当前线程开启一个RunLoop（第一次调用[NSRunLoop currentRunLoop]方法时，实际是会先去创建一个RunLoop） 向当前RunLoop中添加一个Port/Source等维持RunLoop的事件循环（如果RunLoop的mode中一个item都没有，RunLoop会退出） 启动该RunLoop12345@autoreleasepool &#123; NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run];&#125; 输出下边代码的执行顺序12345678910111213NSLog(@&quot;1&quot;);dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;2&quot;); [self performSelector:@selector(test) withObject:nil afterDelay:10]; NSLog(@&quot;3&quot;);&#125;);NSLog(@&quot;4&quot;);- (void)test&#123; NSLog(@&quot;5&quot;);&#125; 答案是1423，test方法并不会执行原因是：如果是带afterDelay的延时函数，会在内部创建一个NSTimer，然后添加到当前线程的RunLoop中，也就是如果当前线程没有开启RunLoop，该方法会失效那么我们改成:123456dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;2&quot;); [[NSRunLoop currentRunLoop] run]; [self performSelector:@selector(test) withObject:nil afterDelay:10]; NSLog(@&quot;3&quot;);&#125;); test方法依然不执行原因是：如果RunLoop的mode中一个item都没有，RunLoop会退出即在调用RunLoop的run方法后，由于其mode中没有添加任何item去维持RunLoop的事件循环，RunLoop随即还是会退出，所以我们自己启动RunLoop，一定要在添加item后123456dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;2&quot;); [self performSelector:@selector(test) withObject:nil afterDelay:10]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;3&quot;);&#125;);]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 多线程相关之performSelector、死锁]]></title>
    <url>%2F2020%2F01%2F08%2FiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%B9%8BperformSelector%2F</url>
    <content type="text"><![CDATA[performSelector12345678910&#x2F;&#x2F;在当前线程延迟1s执行，响应了OC语言的动态性：延迟到运行时才绑定方法[self performSelector:@selector(aaa) withObject:nil afterDelay:1];&#x2F;&#x2F; 回到主线程，waitUntilDone:是否将该回调方法执行完再执行后面的代码&#x2F;&#x2F; 如果为YES：就必须等回调方法执行完成之后才能执行后面的代码，说白了就是阻塞当前的线程&#x2F;&#x2F; 如果是NO：就是不等回调方法结束，不会阻塞当前线程[self performSelectorOnMainThread:@selector(aaa) withObject:nil waitUntilDone:YES];&#x2F;&#x2F; 开辟子线程[self performSelectorInBackground:@selector(aaa) withObject:nil];&#x2F;&#x2F;在指定线程执行[self performSelector:@selector(aaa) onThread:[NSThread currentThread] withObject:nil waitUntilDone:YES]; 需要注意的是：如果是带afterDelay的延时函数，会在内部创建一个NSTimer，然后添加到当前线程的Runloop中。也就是如果当前线程没有开启runloop，该方法会失效。在子线程中，需要启动runloop(注意调用顺序)12[self performSelector:@selector(aaa) withObject:nil afterDelay:1];[[NSRunLoop currentRunLoop] run]; performSelector:withObject:只是一个单纯的消息发送，和时间没有一点关系。所以不需要添加到子线程的Runloop中也能执行 下面代码片段的test方法会去执行吗？123dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self performSelector:@selector(test:) withObject:nil afterDelay:0];&#125;); 这里的test方法是不会去执行的，原因在于- (void)performSelector: withObject: afterDelay:这个方法要创建提交任务到runloop上的，而gcd底层创建的线程是默认没有开启对应runloop的，所有这个方法就会失效。而如果将dispatch_get_global_queue改成主队列，由于主队列所在的主线程是默认开启了runloop的，就会去执行(将dispatch_async改成同步，因为同步是在当前线程执行，那么如果当前线程是主线程，test方法也是会去执行的) 死锁 死锁就是队列引起的循环等待，一个比较常见的死锁例子:主队列同步123456- (void)viewDidLoad &#123; [super viewDidLoad]; dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;deallock&quot;); &#125;);&#125; 在主线程中运用主队列同步，也就是把任务放到了主线程的队列中。同步对于任务是立刻执行的，那么当把任务放进主队列时，它就会立马执行，只有执行完这个任务，viewDidLoad才会继续向下执行。而viewDidLoad和任务都是在主队列上的，由于队列的先进先出原则，任务又需等待viewDidLoad执行完毕后才能继续执行，viewDidLoad和这个任务就形成了相互循环等待，就造成了死锁。想避免这种死锁，可以将同步改成异步dispatch_async或者将dispatch_get_main_queue换成其他串行或并行队列，都可以解决 同样，下边的代码也会造成死锁：123456dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);dispatch_async(serialQueue, ^&#123; dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;deadlock&quot;); &#125;);&#125;); 外面的函数无论是同步还是异步都会造成死锁。这是因为里面的任务和外面的任务都在同一个serialQueue队列内，又是同步，这就和上边主队列同步的例子一样造成了死锁。解决方法也和上边一样，将里面的同步改成异步dispatch_async或者将serialQueue换成其他串行或并行队列，都可以解决]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中事件的响应链和传递链]]></title>
    <url>%2F2019%2F12%2F25%2FiOS%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94%E9%93%BE%E5%92%8C%E4%BC%A0%E9%80%92%E9%93%BE%2F</url>
    <content type="text"><![CDATA[iOS事件链有两条：事件的响应链；Hit-Testing事件的传递链 响应链：由离用户最近的view向系统传递。initial view –&gt; super view –&gt; ….. –&gt; view controller –&gt; window –&gt; Application –&gt; AppDelegate 传递链：由系统向离用户最近的view传递。UIKit –&gt; active app&#39;s event queue –&gt; window –&gt; root view –&gt; …… –&gt; lowest view 在iOS中只有继承UIResponder的对象才能够接收并处理事件，UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。我们熟悉的UIApplication、UIViewController、UIWindow和所有继承自UIView的UIKit类都直接或间接的继承自UIResponder，所以它们的实例都是可以构成响应者链的响应者对象，首先我们通过一张图来简单了解一下事件的传递以及响应 传递链 事件传递的两个核心方法12- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; &#x2F;&#x2F; recursively calls -pointInside:withEvent:. point is in the receiver&#39;s coordinate system- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; &#x2F;&#x2F; default returns YES if point is in bounds 第一个方法返回的是一个UIView，是用来寻找最终哪一个视图来响应这个事件 第二个方法是用来判断某一个点击的位置是否在视图范围内，如果在就返回YES 其中UIView不接受事件处理的情况有1231. alpha &lt;0.012. userInteractionEnabled &#x3D; NO3. hidden ＝ YES 事件传递的流程图 流程描述 我们点击屏幕产生触摸事件，系统将这个事件加入到一个由UIApplication管理的事件队列中，UIApplication会从消息队列里取事件分发下去，首先传给UIWindow 在UIWindow中就会调用hitTest:withEvent:方法去返回一个最终响应的视图 在hitTest:withEvent:方法中就会去调用pointInside: withEvent:去判断当前点击的point是否在UIWindow范围内，如果是的话，就会去遍历它的子视图来查找最终响应的子视图 遍历的方式是使用倒序的方式来遍历子视图，也就是说最后添加的子视图会最先遍历，在每一个视图中都回去调用它的hitTest:withEvent:方法，可以理解为是一个递归调用 最终会返回一个响应视图，如果返回视图有值，那么这个视图就作为最终响应视图，结束整个事件传递；如果没有值，那么就会将UIWindow作为响应者 响应链 响应者链流程图 响应者链的事件传递过程总结如下 如果view的控制器存在，就传递给控制器处理；如果控制器不存在，则传递给它的父视图 在视图层次结构的最顶层，如果也不能处理收到的事件，则将事件传递给UIWindow对象进行处理 如果UIWindow对象也不处理，则将事件传递给UIApplication对象 如果UIApplication也不能处理该事件，则将该事件丢弃 实例场景 在一个方形按钮中点击中间的圆形区域有效，而点击四角无效 核心思想是在pointInside: withEvent:方法中修改对应的区域 12345678910111213141516171819202122232425262728293031323334353637383940414243- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; &#x2F;&#x2F; 如果控件不允许与用用户交互,那么返回nil if (!self.userInteractionEnabled || [self isHidden] || self.alpha &lt;&#x3D; 0.01) &#123; return nil; &#125; &#x2F;&#x2F;判断当前视图是否在点击范围内 if ([self pointInside:point withEvent:event]) &#123; &#x2F;&#x2F;遍历当前对象的子视图(倒序) __block UIView *hit &#x3D; nil; [self.subviews enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; &#x2F;&#x2F;坐标转换，把当前坐标系上的点转换成子控件坐标系上的点 CGPoint convertPoint &#x3D; [self convertPoint:point toView:obj]; &#x2F;&#x2F;调用子视图的hitTest方法，判断自己的子控件是不是最适合的View hit &#x3D; [obj hitTest:convertPoint withEvent:event]; &#x2F;&#x2F;如果找到了就停止遍历 if (hit) *stop &#x3D; YES; &#125;]; &#x2F;&#x2F;返回当前的视图对象 return hit?hit:self; &#125;else &#123; return nil; &#125;&#125;&#x2F;&#x2F; 该方法判断触摸点是否在控件身上，是则返回YES，否则返回NO，point参数必须是方法调用者的坐标系- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123; CGFloat x1 &#x3D; point.x; CGFloat y1 &#x3D; point.y; CGFloat x2 &#x3D; self.frame.size.width &#x2F; 2; CGFloat y2 &#x3D; self.frame.size.height &#x2F; 2; &#x2F;&#x2F;判断是否在圆形区域内 double dis &#x3D; sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); if (dis &lt;&#x3D; self.frame.size.width &#x2F; 2) &#123; return YES; &#125; else&#123; return NO; &#125;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周年快乐]]></title>
    <url>%2F2019%2F12%2F25%2Fhello-world1%2F</url>
    <content type="text"><![CDATA[去年这个时候发布了我的第一篇博文 — Hello World转眼已经写了一年了物是人非，感慨良多不管怎样我还是会继续坚持下去的，加油…圣诞节快乐…我的博客上线运行中…]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 面试题-2019.上]]></title>
    <url>%2F2019%2F12%2F18%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%982019%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[UIView和CALayer是什么关系 UIView继承自UIResponder类，可以响应事件 CALayer直接继承自NSObject类，不可以响应事件 UIView是CALayer的delegate(CALayerDelegate) UIView主要处理事件，CALayer负责绘制 每个UIView内部都有一个CALayer在背后提供内容的绘制和显示，并且UIView的尺寸样式都由内部的Layer所提供。两者都有树状层级结构，Layer内部有SubLayers，View内部有SubViews，但是Layer比View多了个AnchorPoint NSCache和NSMutableDictionary的相同点与区别 相同点：NSCache和NSMutableDictionary功能用法基本是相同的区别：NSCache是线程安全的，NSMutableDictionary线程不安全，Mutable开发的类一般都是线程不安全的当内存不足时NSCache会自动释放内存(所以从缓存中取数据的时候总要判断是否为空)NSCache可以指定缓存的限额，当缓存超出限额自动释放内存NSCache的Key只是对对象进行了Strong引用，而非拷贝，所以不需要实现NSCopying协议 atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说） atomic会对属性的setter/getter方法进行加锁，这仅仅只能保证在操作setter/getter方法是安全的。不能保证其他线程的安全 例如：线程1调用了某一属性的setter方法并进行到了一半，线程2调用其getter方法，那么会执行完setter操作后，再执行getter操作，线程2会获取到线程1setter后的完整的值；当几个线程同时调用同一属性的setter、getter方法时，会获取到一个完整的值，但获取到的值不可控 iOS 中内省的几个方法 对象在运行时获取其类型的能力称为内省。内省可以有多种方法实现OC运行时内省的4个方法： 判断对象类型：12-(BOOL) isKindOfClass: &#x2F;&#x2F; 判断是否是这个类或者这个类的子类的实例-(BOOL) isMemberOfClass: &#x2F;&#x2F; 判断是否是这个类的实例 判断对象/类是否有这个方法12-(BOOL) respondsToSelector: &#x2F;&#x2F; 判断实例是否有这样方法+(BOOL) instancesRespondToSelector: &#x2F;&#x2F; 判断类是否有这个方法 objc在向一个对象发送消息时，发生了什么 根据对象的isa指针找到该对象所属的类，去objc的对应的类中找方法1.首先，在相应操作的对象中的缓存方法列表中找调用的方法，如果找到，转向相应实现并执行2.如果没找到，在相应操作的对象中的方法列表中找调用的方法，如果找到，转向相应实现执行3.如果没找到，去父类指针所指向的对象中执行1，2.4.以此类推，如果一直到根类还没找到，转向拦截调用，走消息转发机制5.如果没有重写拦截调用的方法，程序报错 你是否接触过OC中的反射机制？简单聊一下概念和使用 class反射 通过类名的字符串形式实例化对象12Class class &#x3D; NSClassFromString(@&quot;student&quot;); Student *stu &#x3D; [[class alloc] init]; 将类名变为字符串12Class class &#x3D; [Student class];NSString *className &#x3D; NSStringFromClass(class); SEL的反射 通过方法的字符串形式实例化方法12SEL selector &#x3D; NSSelectorFromString(@&quot;setName&quot;);[stu performSelector:selector withObject:@&quot;Mike&quot;]; 将方法变成字符串NSStringFromSelector(@selector(setName:)); 这个写法会出什么问题@property (nonatomic, copy) NSMutableArray *arr; 添加，删除，修改数组内元素的时候，程序会因为找不到对应的方法而崩溃。原因：是因为copy就是复制一个不可变NSArray的对象，不能对NSArray对象进行添加/修改 如何让自己的类用copy修饰符 若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。具体步骤：1.需声明该类遵从NSCopying协议2.实现NSCopying协议的方法，具体区别戳这里 NSCopying协议方法为：12345- (id)copyWithZone:(NSZone *)zone &#123; MyObject *copy &#x3D; [[[self class] allocWithZone: zone] init]; copy.username &#x3D; self.username; return copy;&#125; 为什么assign不能用于修饰对象 首先我们需要明确，对象的内存一般被分配到堆上，基本数据类型和oc数据类型的内存一般被分配在栈上如果用assign修饰对象，当对象被释放后，指针的地址还是存在的，也就是说指针并没有被置为nil，从而造成了野指针。因为对象是分配在堆上的，堆上的内存由程序员分配释放。而因为指针没有被置为nil，如果后续的内存分配中，刚好分配到了这块内存，就会造成崩溃而assign修饰基本数据类型或oc数据类型，因为基本数据类型是分配在栈上的，由系统分配和释放，所以不会造成野指针 请写出以下代码输出 123int a[5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;int *ptr &#x3D; (int *)(&amp;a + 1);printf(&quot;%d, %d&quot;, *(a + 1), *(ptr + 1)); 参考答案：2，随机值分析：a代表有5个元素的数组的首地址，a[5]的元素分别是1，2，3，4，5。接下来，a + 1表示数据首地址加1，那么就是a[1]，也就是对应于值为2，但是，这里是&amp;a + 1，因为a代表的是整个数组，它的空间大小为5 * sizeof(int)，因此&amp;a + 1就是a + 5。a是个常量指针，指向当前数组的首地址，指针+1就是移动sizeof(int)个字节因此，ptr是指向int *类型的指针，而ptr指向的就是a + 5，那么ptr + 1也相当于a + 6，所以最后的*(ptr + 1)就是一个随机值了。而*(ptr – 1)就相当于a + 4，对应的值就是5 一个view已经初始化完毕，view上面添加了n个button（可能使用循环创建），除用view的tag之外，还可以采用什么办法来找到自己想要的button来修改Button的值 第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找 UIViewController的viewDidUnload、viewDidLoad和loadView分别什么时候调用？UIView的drawRect和layoutSubviews分别起什么作用 第一个问题：在控制器被销毁前会调用viewDidUnload（MRC下才会调用）在控制器没有任何view时，会调用loadView在view加载完成时，会调用viewDidLoad第二个问题：在调用setNeedsDisplay后，会调用drawRect方法，我们通过在此方法中可以获取到context（设置上下文），就可以实现绘图在调用setNeedsLayout后，会调用layoutSubviews方法，我们可以通过在此方法去调整UI。当然能引起layoutSubviews调用的方式有很多种的，比如添加子视图、滚动scrollview、修改视图的frame等 自动释放池工作原理 自动释放池是NSAutorelease类的一个实例，当向一个对象发送autorelease消息时，该对象会自动入池，待池销毁时，将会向池中所有对象发送一条release消息，释放对象[pool release]、[pool drain]表示的是池本身不会销毁，而是池子中的临时对象都被发送release，从而将对象销毁 苹果是如何实现autoreleasepool的 autoreleasepool是由AutoreleasePoolPage以双向链表的方式实现的，主要通过下列三个函数完成： 由objc_autoreleasePoolPush作为自动释放池作用域的第一个函数 使用objc_autorelease将对象加入自动释放池 由objc_autoreleasePoolPop作为自动释放池作用域的最后一个函数 autorelease的对象何时被释放 RunLoop在每个事件循环结束后会去自动释放池将所有自动释放对象的引用计数减一，若引用计数变成了0，则会将对象真正销毁掉，回收内存。在没有手动添加Autorelease Pool的情况下，autorelease的对象是在每个事件循环结束后，自动释放池才会对所有自动释放的对象的引用计数减一，若引用计数变成了0，则释放对象，回收内存。因此，若想要早一点释放掉autorelease对象，那么我们可以在对象外加一个自动释放池。比如，在循环处理数据时，临时变量要快速释放，就应该采用这种方式： 12345678910&#x2F;&#x2F; 通过alloc创建的对象，直接加入@autoreleasepool没有作用，需在创建对象后面显式添加autorelease&#x2F;&#x2F; 通过类方法创建的对象不需要显式添加autorelease，原因是类方法创建的对象系统会自动添加autoreleasefor (int i &#x3D; 0; i &lt; 1000000; i++) &#123; @autoreleasepool &#123; NSString *str &#x3D; @&quot;Abc&quot;; str &#x3D; [str lowercaseString]; str &#x3D; [str stringByAppendingString:@&quot;xyz&quot;]; NSLog(@&quot;%@&quot;, str); &#125; &#x2F;&#x2F; 出了这里，就会去遍历该自动释放池了&#125; 简述内存管理基本原则 OC内存管理遵循谁创建，谁释放，谁引用，谁管理的机制，当使用alloc、copy(mutableCopy)或者retian一个对象时，你就有义务向它发送一条release或者autorelease消息释放该对象，其他方法创建的对象，不需要由你来管理内存，当对象引用计数为0时，系统将释放该对象，这是OC的手动管理机制（MRC）向一个对象发送一条autorelease消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池中每一个对象发送一条release消息，以此来释放对象向一个对象发送release消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用dealloc方法释放该对象和对象本身所拥有的实例 sizeof关键字 sizeof是在编译阶段处理，且不能被编译为机器码。sizeof的结果等于对象或类型所占的内存字节数。sizeof的返回值类型为size_t变量：int a; sizeof(a)为4；指针：int *p; sizeof(p)为4；数组：int b[10]; sizeof(b)为数组的大小410；int c[0]; sizeof(c)等于0sizeof(void)等于1`sizeof(void )`等于4 什么是离屏渲染？什么情况下会触发？离屏渲染消耗性能的原因 离屏渲染就是在当前屏幕缓冲区以外，新开辟一个缓冲区进行操作离屏渲染触发的场景有以下： 圆角（同时设置layer.masksToBounds = YES、layer.cornerRadius大于0） 图层蒙版 阴影，layer.shadowXXX，如果设置了layer.shadowPath就不会产生离屏渲染 遮罩，layer.mask 光栅化，layer.shouldRasterize = YES 离屏渲染消耗性能的原因需要创建新的缓冲区，离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕 ARC 下，不显式指定任何属性关键字时，默认的关键字都有哪些 基本数据类型默认关键字是：atomic, readwrite, assign普通Objective-C对象默认关键字是：atomic, readwrite, strong OC中的类方法和实例方法有什么本质区别和联系 类方法： 类方法是属于类对象的 类方法只能通过类对象调用 类方法中的 self 是类对象 类方法可以调用其他的类方法 类方法中不能访问成员变量 类方法中不能直接调用对象方法 实例方法： 实例方法是属于实例对象的 实例方法只能通过实例对象调用 实例方法中的 self 是实例对象 实例方法中可以访问成员变量 实例方法中直接调用实例方法 实例方法中也可以调用类方法（通过类名） 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ 不能向编译后得到的类中增加实例变量 能向运行时创建的类中添加实例变量 因为编译后的类已经注册在runtime中，类结构体中的objc_ivar_list实例变量的链表和instance_size实例变量的内存大小已经确定，同时runtime会调用class_setIvarLayout或class_setWeakIvarLayout来处理strong weak引用，所以不能向存在的类中添加实例变量运行时创建的类是可以添加实例变量，调用class_addIvar函数。但是得在调用objc_allocateClassPair之后，objc_registerClassPair之前，原因同上 runtime如何通过selector找到对应的IMP地址（分别考虑实例方法和类方法）Selector、Method 和 IMP的有什么区别与联系 对于实例方法，每个实例的isa指针指向着对应类对象，而每一个类对象中都有一个对象方法列表。对于类方法，每个类对象的isa指针都指向着对应的元类对象，而每一个元类对象中都有一个类方法列表。方法列表中记录着方法的名称，方法实现，以及参数类型，其实selector本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的方法实现Selector、Method 和 IMP的关系可以这样描述：在运行期分发消息，方法列表中的每一个实体都是一个方法（Method）它的名字叫做选择器（SEL）对应着一种方法实现（IMP） objc_msgSend、_objc_msgForward都是做什么的？OC 中的消息调用流程是怎样的 objc_msgSend是用来做消息发送的。在OC中，对方法的调用都会被转换成内部的消息发送执行 _objc_msgForward是IMP类型（函数指针）用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发 在消息调用的过程中，objc_msgSend的动作比较清晰：首先在Class中的缓存查找IMP（没缓存则初始化缓存）如果没找到，则向父类的Class查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替IMP。最后，执行这个IMP。当调用一个NSObject对象不存在的方法时，并不会马上抛出异常，而是会经过多层转发，层层调用对象的-resolveInstanceMethod:、-forwardingTargetForSelector:、-methodSignatureForSelector:、-forwardInvocation:等方法。其中最后-forwardInvocation:是会有一个NSInvocation对象，这个NSInvocation对象保存了这个方法调用的所有信息，包括Selector名，参数和返回值类型，可以从这个NSInvocation对象里拿到调用的所有参数值 class方法和objc_getClass方法有什么区别 object_getClass(obj)返回的是obj中的isa指针，即指向类对象的指针；而[obj class]则分两种情况：一是当obj为实例对象时，[obj class]中class是实例方法，返回的是obj对象中的isa指针；二是当obj为类对象（包括元类和根类以及根元类）时，调用的是类方法，返回的结果为其本身 OC中向一个nil对象发送消息将会发生什么 在OC中向nil发送消息是完全有效的，只是在运行时不会有任何作用；向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误，也不会崩溃 _objc_msgForward函数是做什么的？直接调用它将会发生什么 _objc_msgForward是一个函数指针（和IMP的类型一样）用于消息转发；当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发objc_msgSend在消息传递中的作用。在消息传递过程中，objc_msgSend的动作比较清晰：首先在Class中的缓存查找IMP（没有缓存则初始化缓存）如果没找到，则向父类的Class查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替IMP，最后执行这个IMP一旦调用了_objc_msgForward，将跳过查找IMP的过程，直接触发消息转发，如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend，我没有在这个对象里找到这个方法的实现，如果用不好会直接导致程序Crash 什么时候会报unrecognized selector的异常 当调用该对象上某个方法，而该对象上没有实现这个方法的时候。可以通过消息转发进行解决，流程见下图 OC在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX但是在这之前，OC的运行时会给出三次拯救程序崩溃的机会 Method resolution（消息动态解析）OC运行时会调用+resolveInstanceMethod:或者+resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步，消息转发（Message Forwarding）123456789101112131415161718&#x2F;&#x2F; 重写 resolveInstanceMethod: 添加对象方法实现+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; &#x2F;&#x2F; 如果是执行 run 函数，就动态解析，指定新的 IMP if (sel &#x3D;&#x3D; NSSelectorFromString(@&quot;run:&quot;)) &#123; &#x2F;&#x2F; class: 给哪个类添加方法 &#x2F;&#x2F; SEL: 添加哪个方法 &#x2F;&#x2F; IMP: 方法实现 &#x3D;&gt; 函数 &#x3D;&gt; 函数入口 &#x3D;&gt; 函数名 &#x2F;&#x2F; type: 方法类型：void用v来表示，id参数用@来表示，SEL用:来表示 class_addMethod(self, sel, (IMP)runMethod, &quot;v@:@&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;&#x2F;&#x2F;新的 run 函数void runMethod(id self, SEL _cmd, NSNumber *meter) &#123; NSLog(@&quot;跑了%@&quot;, meter);&#125; Fast forwarding（消息接受者重定向）如果目标对象实现了-forwardingTargetForSelector:，Runtime这时就会调用这个方法，给你把这个消息转发给其他对象的机会。只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点12345678&#x2F;&#x2F; 消息接受者重定向- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if (aSelector &#x3D;&#x3D; @selector(run:)) &#123; return [[Person alloc] init]; &#x2F;&#x2F; 返回 Person 对象，让 Person 对象接收这个消息 &#125; return [super forwardingTargetForSelector:aSelector];&#125; Normal forwarding（消息重定向）这一步是Runtime最后一次给你挽救的机会。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象1234567891011121314151617181920212223242526272829303132333435&#x2F;&#x2F; 获取函数的参数和返回值类型，返回签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@&quot;run:&quot;]) &#123; return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125;&#x2F;&#x2F; 消息重定向- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; &#x2F;&#x2F; 从 anInvocation 中获取消息 SEL sel &#x3D; anInvocation.selector; if (sel &#x3D;&#x3D; NSSelectorFromString(@&quot;run:&quot;)) &#123; &#x2F;&#x2F; 1. 指定当前类的一个方法作为IMP &#x2F;&#x2F; anInvocation.selector &#x3D; @selector(readBook:); &#x2F;&#x2F; [anInvocation invoke]; &#x2F;&#x2F; 2. 指定其他类来执行这个IMP Person *p &#x3D; [[Person alloc] init]; &#x2F;&#x2F; 判断 Person 对象方法是否可以响应 sel if([p respondsToSelector:sel]) &#123; &#x2F;&#x2F; 若可以响应，则将消息转发给其他对象处理 [anInvocation invokeWithTarget:p]; &#125; else &#123; &#x2F;&#x2F; 若仍然无法响应，则报错：找不到响应方法 [self doesNotRecognizeSelector:sel]; &#125; &#125;else&#123; [super forwardInvocation:anInvocation]; &#125;&#125;- (void)doesNotRecognizeSelector:(SEL)aSelector &#123; [super doesNotRecognizeSelector:aSelector];&#125; 既然-forwardingTargetForSelector:和-forwardInvocation:都可以将消息转发给其他对象处理，那么两者的区别在哪？区别就在于-forwardingTargetForSelector:只能将消息转发给一个对象。而-forwardInvocation:可以把消息存储，在你觉得合适的时机转发出去，或者不处理这个消息。修改消息的target，selector，参数等。将消息转发给多个对象 iOS layoutSubviews什么时候会被调用 init方法不会调用layoutSubviews，但是是用initWithFrame进行初始化时，当rect的值不为CGRectZero时，会触发 addSubview会触发layoutSubviews方法 setFrame只有当设置的frame的参数的size与原来的size不同，才会触发其view的layoutSubviews方法 滑动UIScrollView会调用scrollview及scrollview上的view的layoutSubviews方法 旋转设备只会调用VC的view的layoutSubviews方法 直接调用[self setNeedsLayout];（这个在上面苹果官方文档里有说明）-layoutSubviews方法：这个方法默认没有做任何事情，需要子类进行重写-setNeedsLayout方法：标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用-layoutIfNeeded方法：如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局在视图第一次显示之前，标记总是需要刷新的，可以直接调用[view layoutIfNeeded] 下面代码会发生什么问题 12345678@property (nonatomic, strong) NSString *str;dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);for (int i &#x3D; 0; i &lt; 1000000 ; i++) &#123; dispatch_async(queue, ^&#123; self.str &#x3D; [NSString stringWithFormat:@&quot;changzifuchaung:%d&quot;,i]; &#125;);&#125; 会crash。因为在并行队列DISPATCH_QUEUE_CONCURRENT中异步dispatch_async对str属性进行赋值，就会导致str已经被release了，还会执行release。这就是向已释放内存的对象发送消息而发生crash详细解析：对str属性strong修饰进行赋值，相当与MRC中的 1234567- (void)setStr:(NSString *)str&#123; if (str &#x3D;&#x3D; _str) return; id pre &#x3D; _str; [str retain];&#x2F;&#x2F;1.先保留新值 _str &#x3D; str;&#x2F;&#x2F;2.再进行赋值 [pre release];&#x2F;&#x2F;3.释放旧值&#125; 那么假如并发队列里调度的线程A执行到步骤1，还没到步骤2时，线程B执行到步骤3，那么当线程A再执行步骤3时，旧值就会被过度释放，导致向已释放内存的对象发送消息而崩溃 追问：怎么修改这段代码变为不崩溃呢 1、使用串行队列将set方法改成在串行队列中执行就行，这样即使异步，但所有block操作追加在队列最后依次执行2、使用atomicatomic关键字相当于在setter方法加锁，这样每次执行setter都是线程安全的，但这只是单独针对setter方法而言的狭义的线程安全3、使用weak关键字weak的setter没有保留新值的操作，所以不会引发重复释放。当然这个时候要看具体情况能否使用weak，可能值并不是所需要的值4、使用互斥锁，保证数据访问的唯一性@synchronized (self) &#123;self.str = [NSString stringWithFormat:@&quot;changzifuchaung:%d&quot;,i];&#125;5、使用Tagged PointerTagged Pointer是苹果在64位系统引入的内存技术。简单来说就是对于NSString(内存小于60位的字符串)或NSNumber(小于2^31)，64位的指针有8个字节，完全可以直接用这个空间来直接表示值，这样的话其实会将NSString和NSNumber对象由一个指针转换成一个值类型，而值类型的setter和getter又是原子的，从而线程安全 发散：下面代码会crash吗 12345678910@property (nonatomic, strong) NSString *str;dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;parallel&quot;, DISPATCH_QUEUE_CONCURRENT);for (int i &#x3D; 0; i &lt; 1000000 ; i++) &#123; dispatch_async(queue, ^&#123; &#x2F;&#x2F; 相比上面，仅字符串变短了 self.str &#x3D; [NSString stringWithFormat:@&quot;%d&quot;,i]; NSLog(@&quot;%d, %s, %p&quot;, i, object_getClassName(self.str), self.str); &#125;);&#125; 不会crash。而且发现str这个字符串类型是NSTaggedPointerStringTagged Pointer是一个能够提升性能、节省内存的有趣的技术Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate(后来可以存储小字符串)Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已它的内存并不存储在堆中，也不需要malloc和free，所以拥有极快的读取和创建速度]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 关于Other Linker Flags的作用]]></title>
    <url>%2F2019%2F12%2F11%2FiOS%E5%85%B3%E4%BA%8EOtherLinkerFlags%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在用第三方库时，我们常常在Xcode的Build Settings下Other Linker Flags里面加入-ObjC标志，它和Objective-C的一个重要特性：类别（category)有关 根据官方的解释，Unix的标准静态库实现和Objective-C的动态特性之间有一些冲突：Objective-C没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，出现&quot;selector not recognized&quot;，也就是找不到方法定义的错误。 为了解决这个问题，引入了-ObjC标志，它的作用就是将静态库中所有的 Objective-C代码都加载进来。可以看出，使用-ObjC可能会链接很多静态库中未被使用的Objective-C代码，极大的增加APP的代码体积。不要以为这样就可以解决所有问题了，在64位的Mac系统或者iOS系统下，链接器有一个bug，会导致只包含有类别的静态库无法使用-ObjC标志来加载文件。变通方法是使用-all_load或者-force_load标志，它们的作用都是强制链接器把目标文件都加载进来，即使没有objc代码，不过-all_load作用于所有的库，而-force_load后面必须要指定具体文件加载的位置 Flags 位置 作用 -ObjC Other Linker Flags 链接静态库中所有的Objective-C代码到APP -all_load Other Linker Flags 全加载，链接静态库中所有的代码到APP，无论是c、c++还是oc -force_load Other Linker Flags 链接指定静态库中所有的代码到APP，无论是c、c++还是oc]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 使用Jenkins持续集成(简称CI)]]></title>
    <url>%2F2019%2F11%2F27%2FiOS%E4%BD%BF%E7%94%A8Jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[安装jenkins1.1. 直接到官网下载安装包，通过安装包安装1.2. 通过Homebrew使用命令行安装1234561. 安装Homebrew$ ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;2. 安装Jenkins$ brew install jenkins3、启动Jenkins$ jenkins jenkins需要java环境，如果没有安装会有提示，java安装地址 一切顺利的话，打开浏览器输入：http://localhost:8080/就能看到jenkins已经运行起来了，如果你更换了端口就是你后来设置的端口。接下来打开Jenkins后会让去一个填写password的页面如下图，存储password的地方就是图片上那行红色字体目录 然后将我们得到的password输入到Administrator password中，即可进入如下界面，接着安装一些建议的插件左边的，安装过程中，有的插件可能会安装失败，强烈建议点击右下角的重试，直到把建议安装的都装好 插件安装完成后，可能不会自动跳转，刷新下界面即可，在刷新后的界面中注册，输入用户名和密码，建议输入后点蓝色按钮保存完成 安装jenkins插件如果要使用Jenkins的插件构建工程的，需要在开始新建工程前安装一些Jenkins插件，在可选插件中选择我们需要的插件进行安装 123451. Xcode integration2. GIT plugin3. GitLab Plugin4. Gitlab Hook Plugin5. Keychains and Provisioning Profiles Management 我们今天使用Execute shell Shell脚本构建工程 jenkins的使用3.1. 构建一个自由风格的软件项目 3.2. General参数可以设置包的保留天数和最大保留个数，这些可以根据需要进行调整，可以不要选 jenkins插件配置多个项目extended choice parameter插件主要是构建的时候可以多选框来选择要构建的项目模块 3.3. 源码管理 3.4. 构建触发器设置触发器可自定义的地方很多，可以根据项目需要选择可省略 定时构建：不管SVN或Git中数据有无变化，均执行定时化的构建任务 轮询SCM：只要SVN或Git中数据有更新，则执行构建任务日程表的填写内容有5个参数，从左到右的参数含义如下：⦁ 第1个参数：分钟minute，取值0~59⦁ 第2个参数：小时hour，取值0~23⦁ 第3个参数：天day，取值1~31⦁ 第4个参数：月month，取值1~12⦁ 第5个参数：星期week，取值0~7，0和7都是表示星期天5个参数可选择性设定，不写死的参数用*号代替，参数之间用空格隔开。例如：12345678&quot;0 21 * * *&quot;表示每晚21点0分自动化构建一次&quot;0 * * * *&quot;表示每个小时的第0分钟执行一次构建&quot;H&#x2F;5 * * * *&quot;每隔5分钟构建一次&quot;H H&#x2F;2 * * *&quot;每两小时构建一次&quot;H H 30 * *&quot;每月30号构建一次&quot;H(0-29)&#x2F;10 * * * *&quot;每个小时的前半个小时内的每10分钟&quot;0 8-17&#x2F;2 * * 1-5&quot;周一到周五，8点~17点，两小时构建一次&quot;H H 1,15 1-11 *&quot;每月1号、15号各构建一次，除12月等 3.5. 构建环境设置本文使用的是shell脚本构建工程，所以该项可以省去3.6. 构建有两种方式打包，一是用Xcode插件打包，二是用Shell脚本打包，本文选择第二种 iOS自动打包—Jenkins Shell如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778## !&#x2F;bin&#x2F;sh## 项目名TARGET_NAME&#x3D;NNAlgorithm## Scheme名SCHEME&#x3D;NNAlgorithm##&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;## 编译类型BUILD_TYPE&#x3D;Release## 当前目录SORCEPATH&#x3D;$&#123;WORKSPACE&#125;## workspace名SPACE&#x3D;$&#123;WORKSPACE&#125;&#x2F;$&#123;TARGET_NAME&#125;.xcodeproj##xcarchive文件的存放路径ARCHIVEPATH&#x3D;$SORCEPATH&#x2F;build&#x2F;$SCHEME.xcarchive## ipa文件的存放路径EXPORTPATH&#x3D;$SORCEPATH&#x2F;build&#x2F;$SCHEME## ExportOptions.plist文件的存放路径，该文件要存放在这个路径下内容如下EXPORTOPTIONSPLIST&#x3D;$SORCEPATH&#x2F;build&#x2F;ExportOptions.plist## 导出后的ipa路径EXPORTPATHIPA&#x3D;$SORCEPATH&#x2F;build&#x2F;$SCHEME&#x2F;$SCHEME.ipaecho -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;First Build Clean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;## 清理缓存## 如果工程使用的是cocoapods，则&#39;-project %s.xcodeproj&#39;替换为&#39;-workspace %s.xcworkspace&#39;xcodebuild clean -project $SPACE -scheme $&#123;SCHEME&#125; -configuration $&#123;BUILD_TYPE&#125;echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Build Clean&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;## 输出关键信息echo -e &quot; TARGET_NAME : $&#123;TARGET_NAME&#125;&quot;echo -e &quot; BUILD_TYPE : $&#123;BUILD_TYPE&#125;&quot;echo -e &quot; SORCEPATH : $&#123;SORCEPATH&#125;&quot;echo -e &quot; ARCHIVEPATH : $&#123;ARCHIVEPATH&#125;&quot;echo -e &quot; EXPORTPATH : $&#123;EXPORTPATH&#125;&quot;echo -e &quot; EXPORTOPTIONSPLIST : $&#123;EXPORTOPTIONSPLIST&#125;&quot;echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Build Archive&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;## 导出archive包xcodebuild archive -project $&#123;SPACE&#125; -scheme $&#123;SCHEME&#125; -archivePath $ARCHIVEPATHecho -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Build Archive Success&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Export IPA&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;## 导出IPA包xcodebuild -exportArchive -archivePath $ARCHIVEPATH -exportPath $&#123;EXPORTPATH&#125; -exportOptionsPlist $&#123;EXPORTOPTIONSPLIST&#125;echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Export IPA SUCCESS&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;## 编译完成时间 20181030_0931BUILD_DATE&#x3D;&quot;$(date +&#39;%Y%m%d_%H%M&#39;)&quot;## info.plist路径PROJECT_INFOPLIST_PATH&#x3D;&quot;$&#123;SORCEPATH&#125;&#x2F;$&#123;TARGET_NAME&#125;&#x2F;Info.plist&quot;## 取版本号BUNDLESHORTVERSION&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;$&#123;PROJECT_INFOPLIST_PATH&#125;&quot;)## 取build值VERSION&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;print CFBundleVersion&quot; &quot;$&#123;PROJECT_INFOPLIST_PATH&#125;&quot;)## ipa更名规则 项目名V版本_年月日_时分IPANAME&#x3D;&quot;$&#123;TARGET_NAME&#125;V$&#123;BUNDLESHORTVERSION&#125;_$&#123;BUILD_DATE&#125;.ipa&quot;## 更名后ipa路径EXPORTPATHNEWIPA&#x3D;$EXPORTPATH&#x2F;$IPANAMEecho -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Export end :$&#123;BUILD_DATE&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;IPA Old Name: $&#123;EXPORTPATHIPA&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;echo -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;IPA New Name: $&#123;EXPORTPATHNEWIPA&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;## IPA更名cp $EXPORTPATHIPA $EXPORTPATHNEWIPAecho -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Create New Name Success&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;## 删除老IPArm $EXPORTPATHIPAecho -e &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Delete Old Name Success&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;#userKey和apiKey需要在蒲公英的账号设置中查找userKey&#x3D;&quot;xxx&quot;apiKey&#x3D;&quot;xxx&quot;#蒲公英打包curl -F &quot;file&#x3D;@$&#123;EXPORTPATHNEWIPA&#125;&quot; \-F &quot;uKey&#x3D;$&#123;userKey&#125;&quot; \-F &quot;_api_key&#x3D;$&#123;apiKey&#125;&quot; \-F &quot;isPublishToPublic&#x3D;2&quot; \http:&#x2F;&#x2F;www.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload ExportOptions.plist1234567891011121314151617181920212223&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;&lt;plist version&#x3D;&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;provisioningProfiles&lt;&#x2F;key&gt; &lt;dict&gt; &lt;key&gt;com.Y***ane&lt;&#x2F;key&gt; &lt;string&gt;azur***_dev&lt;&#x2F;string&gt; &lt;&#x2F;dict&gt; &lt;key&gt;method&lt;&#x2F;key&gt; &lt;string&gt;development&lt;&#x2F;string&gt; &lt;key&gt;signingCertificate&lt;&#x2F;key&gt; &lt;string&gt;iPhone Developer&lt;&#x2F;string&gt; &lt;key&gt;signingStyle&lt;&#x2F;key&gt; &lt;string&gt;manual&lt;&#x2F;string&gt; &lt;key&gt;teamID&lt;&#x2F;key&gt; &lt;string&gt;42***ZL&lt;&#x2F;string&gt; &lt;key&gt;compileBitcode&lt;&#x2F;key&gt; &lt;false&#x2F;&gt; &lt;key&gt;uploadSymbols&lt;&#x2F;key&gt; &lt;false&#x2F;&gt;&lt;&#x2F;dict&gt;&lt;&#x2F;plist&gt; 其中plist文件中的method参数有如下几个方法：app-store, ad-hoc, enterprise, development3.7. 构建后操作 邮件通知系统，通过系统管理→系统设置，进行邮件配置 设置jenkins地址和管理员邮箱地址 设置发件人等信息这里的发件人邮箱地址切记要和系统管理员邮件地址保持一致 注：上图的Password为邮箱的SMTP授权秘钥，至此系统管理处的内容已配置完成 配置Jenkins自带的邮件功能(测试邮件功能是否正常使用，可以不配置，不影响) 和上面Extended E-mail Notification配置一样即可，点击Test configuration，收到邮件并且显示Email was successfully sent，代表邮件配置成功，接下来可以去项目中具体配置就可以使用了 进入项目，然后找到构建后操作，点击增加构建后的操作步骤，点击Editable Email Notification 至此所有的配置已完成，点击应用后保存，enjoy it！ 12345678910111213141516Project Recipient List：这个项目的需要发送邮件给哪些人，可以在这里输入多个邮箱，中间以英文逗号隔开Project Reply-To List：保持默认即可，这个是收到邮件的人回复邮件时候回复给谁用的，一般不会回复邮件Content Type：可以选择Html或者Default也行，因为我们在jenkins系统设置中的默认格式就是htmlDefault Subject： 邮件主题，可以书写成：XXX项目iOS打包通知:$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS! 分析下这几个参数什么意思：$PROJECT_NAME 构建项目的名称；$BUILD_NUMBER 构建的号码；$BUILD_STATUS 构建状态，这几个参数，它会自动读取，按照这种格式书写即可Default Content：邮件内容，以下内容为模板，可直接复制修改使用：&lt;hr&#x2F;&gt;本邮件是程序自动下发的，请勿回复！&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;项目名称：$PROJECT_NAME&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;构建编号：$BUILD_NUMBER&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;构建状态：$BUILD_STATUS&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;触发原因：$&#123;CAUSE&#125;&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;构建日志地址：&lt;a href&#x3D;&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console&#x2F;&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;构建地址：&lt;a href&#x3D;&quot;$BUILD_URL&quot;&gt;$BUILD_URL&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;构建报告：&lt;a href&#x3D;&quot;$&#123;BUILD_URL&#125;testReport&quot;&gt;$&#123;BUILD_URL&#125;testReport&#x2F;&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt;变更集:$&#123;JELLY_SCRIPT,template&#x3D;&quot;html&quot;&#125;&lt;br&#x2F;&gt;&lt;hr&#x2F;&gt; Jenkins卸载方法（Windows/Linux/MacOS） 如果使用brew安装的，可以执行以下命令$ brew uninstall jenkins 注：Jenkins修改工程的工作空间在项目的配置中点击高级，选择使用自定义工作空间，输入工作空间路径即可]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 插件化开发(动态库研究)]]></title>
    <url>%2F2019%2F11%2F13%2FiOS%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[framework是一种优秀的资源打包方式，我们平时看到的第三方发布的framework大部分都是静态库，苹果对iOS允许使用动态库，但是要利用动态库热更新，由于苹果的审核和签名技术，暂时还是不行，内部使用还是可行的 思路：在用户想使用某个功能的时候让其从服务器上将动态库文件下载到本地，然后手动加载动态库，实现功能的的插件化 创建动态库12345678910111213141516171819# 头文件部分#import &lt;Foundation&#x2F;Foundation.h&gt;@interface DynamicLlib : NSObject- (void)doSomething;@end# 实现部分#import &quot;DynamicLlib.h&quot;@implementation DynamicLlib- (void)doSomething&#123; NSLog(@&quot;doSomething!&quot;);&#125;@end 使用动态库 实际过程中动态库是需要从服务器下载并且保存到app的沙盒中的,这边直接模拟已经下载好了动态库并且保存到沙盒中 2.1. 使用NSBundle加载动态库1234567891011121314- (IBAction)loadFrameWorkByBundle:(id)sender &#123; &#x2F;&#x2F;从服务器去下载并且存入Documents下(只要知道存哪里即可),事先要知道framework名字,然后去加载 NSString *frameworkPath &#x3D; [NSString stringWithFormat:@&quot;%@&#x2F;Documents&#x2F;DynamicLlib.framework&quot;,NSHomeDirectory()]; NSError *err &#x3D; nil; NSBundle *bundle &#x3D; [NSBundle bundleWithPath:frameworkPath]; NSString *str &#x3D; @&quot;加载动态库失败!&quot;; if ([bundle loadAndReturnError:&amp;err]) &#123; NSLog(@&quot;bundle load framework success.&quot;); str &#x3D; @&quot;加载动态库成功!&quot;; &#125; else &#123; NSLog(@&quot;bundle load framework err:%@&quot;,err); &#125;&#125;2.2. 使用dlopen加载动态库123456789&#x2F;&#x2F; 动态库中真正的可执行代码为DynamicLlib.framework&#x2F;DynamicLlib文件，因此使用dlopen时指定加载动态库的路径为DynamicLlib.framework&#x2F;DynamicLlibNSString *documentsPath &#x3D; [NSString stringWithFormat:@&quot;%@&#x2F;Documents&#x2F;DynamicLlib.framework&#x2F;DynamicLlib&quot;,NSHomeDirectory()];[self dlopenLoadDylibWithPath:documentsPath]; if (dlopen([path cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW) &#x3D;&#x3D; NULL) &#123; char *error &#x3D; dlerror(); NSLog(@&quot;dlopen error: %s&quot;, error); &#125; else &#123; NSLog(@&quot;dlopen load framework success.&quot;); &#125; 2.3. 调用动态库中的方法123456789101112&#x2F;&#x2F;调用framework的方法,利用runtime运行时- (IBAction)callMethodOfFrameWork:(id)sender &#123; Class DynamicLlibClass &#x3D; NSClassFromString(@&quot;DynamicLlib&quot;); if(DynamicLlibClass)&#123; &#x2F;&#x2F;事先要知道有什么方法在这个framework中 id object &#x3D; [[DynamicLlibClass alloc] init]; &#x2F;&#x2F;由于没有引入相关头文件故通过performSelector调用 [object performSelector:@selector(doSomething)]; &#125;else &#123; NSLog(@&quot;调用方法失败!&quot;); &#125;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 唤起APP之Universal Link(通用链接)]]></title>
    <url>%2F2019%2F11%2F06%2FiOS%E5%94%A4%E8%B5%B7APP%E4%B9%8BUniversal%20Link%2F</url>
    <content type="text"><![CDATA[iOS 9之前，一直使用的是URL Schemes技术来从外部对App进行跳转，但是iOS系统中进行URL Schemes跳转的时候如果没有安装App，会提示Cannot open Page的提示，而且当注册有多个scheme相同的时候，目前没有办法区分，但是从iOS 9起可以使用Universal Links技术进行跳转页面，这是一种体验更加完美的解决方案 什么是Universal Link（通用链接）Universal Link是Apple在iOS 9推出的一种能够方便的通过传统HTTPS链接来启动APP的功能。如果你的应用支持Universal Link，当用户点击一个链接时可以跳转到你的网站并获得无缝重定向到对应的APP，且不需要通过Safari浏览器。如果你的应用不支持的话，则会在Safari中打开该链接 支持Universal Link（通用链接）先决条件：必须有一个支持HTTPS的域名，并且拥有该域名下上传到根目录的权限（为了上传Apple指定文件） 集成步骤 开发者中心配置找到对应的App ID，在Application Services列表里有Associated Domains一条，把它变为Enabled就可以了 工程配置targets-&gt;Capabilites-&gt;Associated Domains，在其中的Domains中填入你想支持的域名，必须以applinks:为前缀，如：applinks:domain 配置指定文件创建一个内容为json格式的文件，苹果将会在合适的时候，从我们在项目中填入的域名请求这个文件。这个文件名必须为apple-app-site-association，切记没有后缀名，文件内容大概是这样子： 123456789101112131415&#123; &quot;applinks&quot;: &#123; &quot;apps&quot;: [], &quot;details&quot;: [ &#123; &quot;appID&quot;: &quot;9JA89QQLNQ.com.apple.wwdc&quot;, &quot;paths&quot;: [ &quot;&#x2F;wwdc&#x2F;news&#x2F;&quot;, &quot;&#x2F;videos&#x2F;wwdc&#x2F;2015&#x2F;*&quot;] &#125;, &#123; &quot;appID&quot;: &quot;ABCD1234.com.apple.wwdc&quot;, &quot;paths&quot;: [ &quot;*&quot; ] &#125; ] &#125;&#125; appID：组成方式是TeamID.BundleID。如上面的9JA89QQLNQ就是teamId。登陆开发者中心，在Account -&gt; Membership里面可以找到Team IDpaths：设定你的app支持的路径列表，只有这些指定路径的链接，才能被app所处理。*的写法代表了可识别域名下所有链接 上传该文件上传该文件到你的域名所对应的根目录或者.well-known目录下，这是为了苹果能获取到你上传的文件。上传完后，先访问一下，看看是否能够获取到，当你在浏览器中输入这个文件链接后，应该是直接下载apple-app-site-association文件 代码中的相关支持当点击某个链接，可以直接进我们的app，但是我们的目的是要能够获取到用户进来的链接，根据链接来展示给用户相应的内容，我们需要在工程里实现AppDelegate对应的方法： 12345678910111213141516- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler &#123; &#x2F;&#x2F; NSUserActivityTypeBrowsingWeb 由Universal Links唤醒的APP if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb])&#123; NSURL *webpageURL &#x3D; userActivity.webpageURL; NSString *host &#x3D; webpageURL.host; if ([host isEqualToString:@&quot;api.r2games.com.cn&quot;])&#123; &#x2F;&#x2F;进行我们的处理 NSLog(@&quot;TODO....&quot;); &#125;else&#123; NSLog(@&quot;openurl&quot;); [[UIApplication sharedApplication] openURL:webpageURL options:nil completionHandler:nil]; &#x2F;&#x2F; [[UIApplication sharedApplication] openURL:webpageURL]; &#125; &#125; return YES;&#125; 苹果为了方便开发者，提供了一个网页验证我们编写的这个apple-app-site-association是否合法有效 Universal Link（通用链接）注意点 Universal Link跨域Universal Link有跨域问题，Universal Link必须要求跨域，如果不跨域，就不会跳转（iOS 9.2之后的改动）假如当前网页的域名是A，当前网页发起跳转的域名是B，必须要求B和A是不同域名才会触发Universal Link，如果B和A是相同域名，只会继续在当前WebView里面进行跳转，哪怕你的Universal Link一切正常，根本不会打开App Universal Link请求apple-app-site-association时机 当我们的App在设备上第一次运行时，如果支持Associated Domains功能，那么iOS会自动去GET定义的Domain下的apple-app-site-association文件 iOS会先请求https://domain.com/.well-known/apple-app-site-association，如果此文件请求不到，再去请求https://domain.com/apple-app-site-association，所以如果想要避免服务器接收过多GET请求，可以直接把apple-app-site-association放在./well-known目录下 服务器上apple-app-site-association的更新不会让iOS本地的apple-app-site-association同步更新，即iOS只会在App第一次启动时请求一次，以后除非App更新或重新安装，否则不会在每次打开时请求apple-app-site-association Universal Link的好处 之前的Custom URL scheme是自定义的协议，因此在没有安装该app的情况下是无法直接打开的。而Universal Links本身就是一个能够指向web页面或者app内容页的标准web link，因此能够很好的兼容其他情况 Universal links是从服务器上查询是哪个app需要被打开，因此不存在Custom URL scheme那样名字被抢占、冲突的情况 Universal links支持从其他app中的UIWebView中跳转到目标app 提供Universal link给别的app进行app间的交流时，对方并不能够用这个方法去检测你的app是否被安装（之前的custom scheme URL的canOpenURL方法可以） 附：[官方文档] Support Universal Links]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 归档缓存]]></title>
    <url>%2F2019%2F10%2F30%2FiOS%E5%BD%92%E6%A1%A3%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[代码如下： 头文件定义1234&#x2F;&#x2F; 归档缓存内容+ (void)archiverObject:(id)object byKey:(NSString *)key withPath:(NSString *)path;&#x2F;&#x2F; 解归档缓存内容+ (id)unarchiverObjectByKey:(NSString *)key withPath:(NSString *)path; 方法实现123456789101112131415161718192021222324252627282930+ (void)archiverObject:(id)object byKey:(NSString *)key withPath:(NSString *)path&#123; &#x2F;&#x2F;初始化存储对象信息的data NSMutableData *data &#x3D; [NSMutableData data]; &#x2F;&#x2F;创建归档工具对象 NSKeyedArchiver *archiver &#x3D; [[NSKeyedArchiver alloc] initForWritingWithMutableData:data]; &#x2F;&#x2F;开始归档 [archiver encodeObject:object forKey:key]; &#x2F;&#x2F;结束归档 [archiver finishEncoding]; &#x2F;&#x2F;写入本地地址 NSString *resultStr &#x3D; [self destPath:path]; [data writeToFile:resultStr atomically:YES];&#125;+ (NSString *)destPath:(NSString *)path&#123; NSString *docPath &#x3D; NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES).lastObject; NSString *destPath &#x3D; [[docPath stringByAppendingPathComponent:@&quot;Caches&quot;] stringByAppendingPathComponent:path]; NSLog(@&quot;%@&quot;, destPath); return destPath;&#125;+ (id)unarchiverObjectByKey:(NSString *)key withPath:(NSString *)path&#123; NSString *resultStr &#x3D; [self destPath:path]; NSData *data &#x3D; [NSData dataWithContentsOfFile:resultStr]; &#x2F;&#x2F;创建反归档对象 NSKeyedUnarchiver *unarchiver &#x3D; [[NSKeyedUnarchiver alloc] initForReadingWithData:data]; &#x2F;&#x2F;接收反归档得到的对象 id object &#x3D; [unarchiver decodeObjectForKey:key]; return object;&#125; 使用实例12345NSDictionary *dict &#x3D; @&#123;@&quot;1&quot;:@&quot;ding&quot;, @&quot;2&quot;:@&quot;guan&quot;, @&quot;3&quot;:@&quot;xiong&quot;&#125;;[TestObj archiverObject:dict byKey:@&quot;cache&quot; withPath:@&quot;cache.plist&quot;];NSDictionary *result &#x3D; [TestObj unarchiverObjectByKey:@&quot;cache&quot; withPath:@&quot;cache.plist&quot;];NSLog(@&quot;***::%@&quot;, result);]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIView分类]]></title>
    <url>%2F2019%2F10%2F23%2FiOSUIView%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[.h内容1234567891011121314151617181920212223- (CGPoint)origin;- (void)setOrigin:(CGPoint)point;- (CGSize)size;- (void)setSize:(CGSize)size;- (CGFloat)x;- (void)setX:(CGFloat)x;- (CGFloat)y;- (void)setY:(CGFloat)y;- (CGFloat)width;- (void)setWidth:(CGFloat)width;- (CGFloat)height;- (void)setHeight:(CGFloat)height;- (CGFloat)bottom;- (void)setBottom:(CGFloat)bottom;- (CGFloat)right;- (void)setRight:(CGFloat)right; .m内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071- (CGPoint)origin&#123; return self.frame.origin;&#125;- (void)setOrigin:(CGPoint)origin&#123; CGRect frame &#x3D; self.frame; frame.origin &#x3D; origin; self.frame &#x3D; frame;&#125;- (CGSize)size&#123; return self.frame.size;&#125;- (void)setSize:(CGSize)size&#123; CGRect frame &#x3D; self.frame; frame.size &#x3D; size; self.frame &#x3D; frame;&#125;- (CGFloat)x&#123; return self.frame.origin.x;&#125;- (void)setX:(CGFloat)x&#123; CGRect frame &#x3D; self.frame; frame.origin.x &#x3D; x; self.frame &#x3D; frame;&#125;- (CGFloat)y&#123; return self.frame.origin.y;&#125;- (void)setY:(CGFloat)y&#123; CGRect frame &#x3D; self.frame; frame.origin.y &#x3D; y; self.frame &#x3D; frame;&#125;- (CGFloat)width&#123; return self.frame.size.width;&#125;- (void)setWidth:(CGFloat)width&#123; CGRect frame &#x3D; self.frame; frame.size.width &#x3D; width; self.frame &#x3D; frame;&#125;- (CGFloat)height&#123; return self.frame.size.height;&#125;- (void)setHeight:(CGFloat)height&#123; CGRect frame &#x3D; self.frame; frame.size.height &#x3D; height; self.frame &#x3D; frame;&#125;- (CGFloat)bottom&#123; return self.frame.origin.y + self.frame.size.height;&#125;- (void)setBottom:(CGFloat)bottom&#123; CGRect frame &#x3D; self.frame; frame.origin.y &#x3D; bottom - self.frame.size.height; self.frame &#x3D; frame;&#125;- (CGFloat)right&#123; return self.frame.origin.x + self.frame.size.width;&#125;- (void)setRight:(CGFloat)right&#123; CGRect frame &#x3D; self.frame; frame.origin.x &#x3D; right - self.frame.size.width; self.frame &#x3D; frame;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 发布CocoaPods私有库]]></title>
    <url>%2F2019%2F10%2F16%2FiOS%E5%8F%91%E5%B8%83CocoaPods%E7%A7%81%E6%9C%89%E5%BA%93%2F</url>
    <content type="text"><![CDATA[需要做的工作包括以下几点 创建一个本地的仓库，将自己的代码搞进去 将自己的代码上传到远程私有仓库中去 创建一个pods 的描述文件 .podspec 修改.podspec描述文件中的相关的描述信息 创建远程内部私有Spec Repo仓库 向私有的Spec Repo仓库中提交.podspec 在个人项目中的Podfile中增加刚刚制作的好的Pod并使用 后期的升级维护 具体详细的步骤如下 创建远程仓库注意点 正规的仓库都有一个license文件，Pods依赖库对这个文件要求比较严格，需要有这个文件，建议使用MIT类型的license 代码版本要打tag(要在代码版本上传以后打tag) pod 支持 .a静态库、.framework 以及文件，不一定要是可运行的工程里面的某个组件 放代码的仓库不一定非要是Git仓库，只要是可以获取到相关代码文件就可以，可以是SVN的，也可以是zip包，区别就是在podspec中的source项填写的内容不同 创建一个pods 的描述文件 .podspec 如果你已经有先有工程可以使用如下命令直接创建.podspec文件$ pod spec create MyViewExtension&lt;这个名称一般和创建的项目名称一样就可以&gt; 或者使用如下命令创建完整项目工程目录$ pod lib create MyViewExtension &lt;这个名称一般和创建的项目名称一样就可以&gt;使用这个命令会询问如下问题，根据项目情况选择即可 修改.podspec描述文件中的相关的描述信息详情可参考CocoaPods的官网的PodSpec语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Pod::Spec.new do |s| # 项目的名称 s.name &#x3D; &quot;MyViewExtension&quot; # 项目的版本号，通过项目git的tag标签进行对应，这里的标签代表的版本 s.version &#x3D; &quot;0.0.1&quot; # 项目简单的描述信息 s.summary &#x3D; &quot;Just Testing.&quot; # 项目的详细描述信息，注意，这里的文字的长度，一定要比上面的s.summary长，不然会认为格式不合格 s.description &#x3D; &lt;&lt;-DESC this project provide all kind of KeychainDeviceID for iOS developer DESC # 项目的网页主页信息，这里可以直接写自己的远程仓库的主页的地址 s.homepage &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;RunOfTheSnail&#x2F;MyViewExtension&quot; # 开源协议 s.license &#x3D; &quot;MIT&quot; # 作者信息 s.author &#x3D; &#123; &quot;zhangyan&quot; &#x3D;&gt; &quot;17***24@163.com&quot; &#125; # 这个比较重要，指的就是git的对应的远程仓库的地址以及版本号，版本号直接获取的是上面的s.version # 项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS # Supported Keys: # :git &#x3D;&gt; :tag, :branch, :commit, :submodules # :svn &#x3D;&gt; :folder, :tag, :revision # :hg &#x3D;&gt; :revision # :http &#x3D;&gt; :flatten, :type, :sha256, :sha1 s.source &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;RunOfTheSnail&#x2F;MyViewExtension.git&quot;, :tag &#x3D;&gt; s.version &#125; # 支持的平台及版本 s.platform &#x3D; :ios, &quot;11.0&quot; # 支持的ios最低版本 s.ios.deployment_target &#x3D; &quot;7.0&quot; # 如果是 Swift 的话指定 Swift 编译版本 # s.swift_version &#x3D; &quot;4.0&quot; # 必备项，代码源文件地址，如果有多个目录下则用逗号分开,否则&quot;public_header_files&quot;等不可用 s.source_files &#x3D; &quot;GSLXYKeychainDeviceID&#x2F;KeychainDeviceID&#x2F;**&#x2F;*.&#123;h,m&#125;&quot; # 公开头文件地址 # s.public_header_files &#x3D; &quot;Pod&#x2F;Classes&#x2F;**&#x2F;*.h&quot; # 所需的系统framework，多个用逗号隔开，不需要后缀名 # s.framework &#x3D; &quot;SomeFramework&quot; s.frameworks &#x3D; &quot;UIKit&quot;, &quot;AnotherFramework&quot; # 需要弱链接的框架 # s.weak_framework &#x3D; &quot;Twitter&quot; # s.weak_frameworks &#x3D; &quot;Twitter&quot;, &quot;SafariServices&quot; #项目依赖的库文件(这个是系统的库文件),不需要后缀名,比如sqlite,libz等.以lib开头的需要省略掉lib这三个字母.例如:libz需要简写为z否则报错 # s.library &#x3D; &quot;iconv&quot; # s.libraries &#x3D; &quot;iconv&quot;, &quot;xml2&quot; # 第三方或自己创建的 .Framework的名称 # s.vendored_frameworks &#x3D; &quot;YostarLib.framework&quot; # 第三方或自己创建的 .a静态库的名称 # s.vendored_libraries &#x3D; &quot;libYostarStaticLib.a&quot; # 添加资源文件 # s.resource &#x3D; &quot;XXX&#x2F;XXXX&#x2F;**&#x2F;*.bundle&quot; # s.resources &#x3D; &quot;XXX&#x2F;XXXX&#x2F;**&#x2F;*.bundle&quot; # CocoaPods会把这个库配置成static framework，同时支持Swift和Objective-C # s.static_framework &#x3D; true # 依赖关系，该项目所依赖的其他，当在加载的时候也会一块把相关的依赖的库加载下来，如果有多个需要填写多个 # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; # 是否使用ARC，如果指定具体文件，则具体的文件使用ARC s.requires_arc &#x3D; true # 指定项目配置，如HEADER_SEARCH_PATHS、OTHER_LDFLAGS等 # s.xcconfig &#x3D; &#123;&quot;OTHER_LDFLAGS&quot; &#x3D;&gt; &quot;-ObjC&quot;&#125; end 修改完毕之后进行检验一下.podspec的格式有木有问题123456789$ pod lib lint完整lint格式$ pod lib lint --allow-warnings --use-libraries --verbose --no-clean --sources&#x3D;&#39;http:&#x2F;&#x2F;10.11.180.29&#x2F;mobileDevelopers&#x2F;YZT-Loan-Pod-Spec.git&#39;--verbose:打印错误--allow-warnings:允许警告,默认有警告的podspec会验证失败--fail-fast:遇到错误马上停止，默认会完成全过程再停止--use-libraries:如果自己私有库包含library,引用了.a、.framework,在验证和提交时需要加--no-clean:检查问题--sources:如果依赖了其他不包含在官方specs里的pod，则用它来指明源，比如依赖了某个私有库。多个值以逗号分隔 创建远程内部私有Spec Repo仓库创建远程内部私有Spec Repo仓库, 需要到Github或其他代码托管平台创建远程仓库, 之后将远程仓库克隆到本地，终端执行如下命令: 12&#x2F;&#x2F; 这里可以用https或ssh地址方式克隆$ pod repo add WBSpecs https:&#x2F;&#x2F;github.com&#x2F;G***00&#x2F;TestPodspec.git 注意：代码仓库和Spec Repo是需要分开存储的克隆成功之后，我们可以查看一下:$ open ~/.cocoapods/repos本地cocoapods目录如下： 向私有的Spec Repo仓库中提交.podspec 首先将本地.podspec推送到远程私有repo spec仓库和本地repo spec仓库，终端执行如下命令：$ pod repo push WBSpecs WBAvoidCrash.podspec 参数解析:repo spec仓库名称 .podspec名称 验证远程是否通过推送成功之后，终端输入如下命令进行验证$ pod spec lint WBAvoidCrash.podspec 验证私有仓库是否可用用pod命令进行搜索，看能否搜索到:$ pod search WBAvoidCrash如果搜索不到，在终端执行如下命令$ rm ~/Library/Caches/CocoaPods/search_index.json或者更新本地仓库$ pod repo update然后重新search 在个人项目中增加刚刚制作好的Podfile并使用新建一个测试工程测试，用CocoaPods初始化项目，编辑Podfile文件:1234567891011#CocoaPods官方spec仓库source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;#自己私有spec仓库source &#39;https:&#x2F;&#x2F;github.com&#x2F;wenmobo&#x2F;WBSpecs.git&#39;platform :ios, &#39;8.0&#39;target &#39;TestDemo&#39; do #防Crash库 pod &#39;WBAvoidCrash&#39;end 编辑好podfile文件之后，终端执行:123$ pod install 安装时使用，更新库使用update命令或$ pod update 更新时使用 后期的升级维护8.1. 更新远程私有库中的代码8.2. 修改.podspec中的配置，version升级一个版本8.3. 给当前的远程仓库的代码，重新打个tag，tag和.podspec的version一样8.4. 远程仓库的代码更新完毕，接下来执行上面的 6.将当前本地的spec文件传到私有Spec Repo仓库的索引库中8.5. 检查测试一下，有没有上传到私有Spec Repo仓库的索引库中 删除私有的Spec Repo$ pod repo remove [name]其实直接找到以后，手动删除就好了，然后在将Git的变动push到远端仓库即可 清理CocoaPods本地缓存特殊情况下，由于网络或者别的原因，通过CocoaPods下载的文件可能会有问题 手动删除(~/Library/Caches/CocoaPods/Pods/Release目录) 打开终端,输入$ pod cache list,会列出所有本地已经缓存的第三方库，在终端中输入$ pod cache clean AAA会删除AAA缓存库，使用$ pod cache clean --all清除所有缓存]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS 安装与恢复]]></title>
    <url>%2F2019%2F10%2F09%2FMacOS%E5%AE%89%E8%A3%85%E4%B8%8E%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[通过 macOS 恢复功能启动要通过 macOS 恢复功能启动，请开启 Mac 并立即按住键盘上的以下组合键之一。通常建议您使用 Command-R-电源键 Command (⌘)-R-电源键安装您的 Mac 上装有的最新 macOS Option-⌘-R-电源键升级到与您的 Mac 兼容的最新 macOS Shift-Option-⌘-R-电源键安装 Mac 随附的 macOS 或与它最接近且仍在提供的版本当您看到 Apple 标志、旋转的地球的提示时，请松开这些按键。当您看到“实用工具”窗口时，即表示您已通过 macOS 恢复功能启动 如果您在安装 macOS 之前需要抹掉磁盘，请从“实用工具”窗口中选择“磁盘工具”，然后点按“继续”。除非您要出售或赠送您的 Mac，或者遇到一个需要您抹掉磁盘的问题，否则您可能不需要抹掉磁盘 从“实用工具”窗口中选取“重新安装 macOS”（或“重新安装 OS X”）点按“继续”，然后按照屏幕上的说明来选取磁盘并开始安装 制作启动盘来恢复安装 首先准备一个8GB或更大容量的U盘，下载好macOS Mojave正式版的安装程序，并把它放在Mac的「应用程序」里备用 打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、(GUID 分区图可选项)，并将 U 盘命名为「Mojave」(下图序号3处)。注意：这个盘符名称必须与后面的命令里的名称一致，需要认真看清楚 在“终端”中键入或粘贴以下命令之一。这些命令假设安装器仍位于您的“应用程序”文件夹中，并且 MyVolume 是 USB 闪存驱动器或您正在使用的其他宗卷的名称。如果不是这个名称，请相应地替换为 MyVolume 制作 macOS Mojave 启动盘，U盘名称(必须与下面命令对应)，然后拷贝这段命令：sudo /Applications/Install\ macOS\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume 制作 macOS High Sierra 启动盘，U盘名称(要与下面命令对应)，拷贝这段命令：sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume 制作旧版本的 macOS Sierra，拷贝这段命令：sudo /Applications/Install\ macOS\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume --applicationpath /Applications/Install\ macOS\ Sierra.app 制作El Capitan，拷贝这段命令：sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume --applicationpath /Applications/Install\ OS\ X\ El\ Capitan.app 当“终端”显示这个操作已完成时，该宗卷的名称将与您下载的安装器名称相同，例如“Install macOS Mojave”。您现在可以退出“终端”并弹出宗卷 当你制作好 macOS Mojave 的安装盘 U 盘之后，你就可以利用它来给Mac电脑格式化重装 (抹盘安装)了。操作的方法非常简单：按下电源键开机，按住 Option 键不放，直到出现启动菜单选项，这时选择安装U盘 (黄色图标) 并回车，就可以开始安装了，在过程中你可以直接覆盖安装系统(升级)，也可以通过“磁盘工具”对 Mac 的磁盘式化或者重新分区等操作实现全新干净的安装。之后就是一步一步的安装直到完成了 附：制作 macOS Mojave U盘USB启动安装盘方法教程 (全新安装 Mac 系统)附：[官方文档] 如何通过 macOS 恢复功能重新安装 macOS附：[官方文档] 如何创建可引导的 macOS 安装器]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 指针详解]]></title>
    <url>%2F2019%2F09%2F25%2FiOS%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[指针数组与数组指针在这里数组指针是指向数组的指针，其本质为指针，指向的对象是数组。由于数组的形式多样所以数组指针的表达也十分多样。同理，指针数组就是存放指针的数组，其本质为数组。由于[ ]的优先级高于*的优先级，指针数组与数组指针的表达可做如下表示：12int * p1 [10]; &#x2F;&#x2F; 指针数组 p1先与“[ ]”结合构成一个包含10个元素的数组，int*表示的则是数组的内容int (* p2)[10]; &#x2F;&#x2F; 数组指针 p2先与“ * ”构成指针定义，int表示数组内容，[10]表示数组内元素个数 由于指向数组的指针与指向普通整型变量的指针不同，在这里可以再对数组名与&amp;数组名的关系进行理解在一维数组中，数组名表示指向首元素的首地址，是一个指向普通变量的指针常量，当对其+1时偏移量是一个普通数据类型的内存大小。而在数组名前加上取地址符&amp;后，表示的就是一个指向数组的指针常量，对其+1时偏移量是一个数组的内存大小 int p; //这是一个普通的整型变量 int *p; //首先从P处开始,先与*结合，所以说明P是一个指针，然后再与int结合，说明指针所指向的内容的类型为int型，所以P是一个返回整型数据的指针 int p[3]; //首先从P处开始，先与[]结合，说明P是一个数组，然后与int结合，说明数组里的元素是整型的，所以P是一个由整型数据组成的数组 int *p[3]; //首先从P处开始，先与[]结合，因为其优先级比*高，所以P是一个数组，然后再与*结合，说明数组里的元素是指针类型，然后再与int结合，说明指针所指向的内容的类型是整型的，所以P是一个由返回整型数据的指针所组成的数组 int (*p)[3]; //首先从P处开始，先与*结合，说明P是一个指针，然后再与[]结合，说明指针所指向的内容是一个数组，然后再与int结合，说明数组里的元素是整型的，所以P是一个指向由整型数据组成的数组的指针 可以通过如下题目，进一步理解上面的讲解123int arrayName[4] &#x3D; &#123;10, 20, 30, 40&#125;;int *p &#x3D; (int *)(&amp;arrayName + 1);NSLog(@&quot;%d&quot;, *(p - 1)); 答案解析 (&amp;arrayName + 1)：&amp;arrayName是数组的地址（等价于指向arrayName数组的指针） 增加1会往后移动16个字节，开始是4个字节的位置，移动后就是16个字节后面的位置（也就是目前位置是20个字节） 最后又赋值给int类型的指针p（int类型占4个字节） 所以(p - 1)就是减去4个字节，变成为16个字节的位置，输出的*(p - 1)值为40]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS KVO]]></title>
    <url>%2F2019%2F09%2F18%2FiOSKVO%2F</url>
    <content type="text"><![CDATA[KVO和NSNotificationCenter都是iOS中观察者模式的一种实现。区别在于，相对于被观察者和观察者之间的关系，KVO是一对一的，而NSNotificationCenter是一对多的。KVO对被监听对象无侵入性，不需要修改其内部代码即可实现监听。 KVO底层实现KVO是基于runtime机制实现的，运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制, 将2个对象的isa指针互相调换, 就是俗称的黑魔法 当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter方法。派生类在被重写的setter方法内实现真正的通知机制 如果原类为Person，那么生成的派生类名为NSKVONotifying_Person，每个类对象中都有一个isa指针指向当前类，当一个类对象第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法 键值观察通知依赖于NSObject的两个方法：willChangeValueForKey:和didChangevlueForKey:；在一个被观察属性发生改变之前，willChangeValueForKey:一定会被调用，这就会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而observeValueForKey:ofObject:change:context:也会被调用 补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类 如何手动触发KVO手动调用willChangeValueForKey:和didChangeValueForKey:示例代码如下：1234567891011121314151、自动&#x2F;&#x2F;默认返回YES+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key&#123; if ([key isEqualToString:@&quot;age&quot;]) &#123; return NO;&#x2F;&#x2F;不观察age属性值得变化 &#125; return YES;&#125;2、手动- (void)setName:(NSString *)name&#123; [self willChangeValueForKey:@&quot;name&quot;]; _name &#x3D; name; [self didChangeValueForKey:@&quot;name&quot;];&#125; 直接修改成员变量会触发KVO吗不会触发KVO，添加KVO的Person实例，其实是NSKVONotyfing_Person类在调用setter方法，不是调用Person的setter方法，而是NSKVONotyfing_Person的setter方法，因为修改成员变量不是setter方法赋值 如果在项目中对Person类进行了监听，也创建了一个NSKVONotifying_Person类，那么会编译通过么编译通过，因为KVO是运行时刻创建的，并不在编译时刻，在编译时刻只有一个NSKVONotifying_Person，所以不报错，可以通过，但是此时KVO起不了作用]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS python自动化出包脚本]]></title>
    <url>%2F2019%2F09%2F11%2FiOSPython%E8%87%AA%E5%8A%A8%E5%8C%96%E5%87%BA%E5%8C%85%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[脚本代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding:UTF-8 -*-import osimport sysimport time# 发邮件所用from email import encodersfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.utils import parseaddr, formataddrimport smtplib# 需要配置分割线 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# fir tokenfir_api_token &#x3D; &#39;34d6f526c9fdcf9afe90753cdb9bb837&#39; #firm的api tokendownload_address &#x3D; &quot;https:&#x2F;&#x2F;fir.im&#x2F;xxxxxxxxx&quot; #firm 下载地址# pgyerpgyer_uKey &#x3D; &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;pgyer_apiKey &#x3D; &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;pgyer_appQRCodeURL &#x3D; &quot;http:&#x2F;&#x2F;www.pgyer.com&#x2F;xxxxxxxxx&quot; # 下载地址pgyer_password &#x3D; &quot;12345&quot;pgyer_updateDescription &#x3D; &quot;test版本&quot; # 更新描述# 项目配置project_Name &#x3D; &#39;Unity-iPhone&#39; #工程名scheme &#x3D; &#39;Unity-iPhone&#39; #schemeisDistribution &#x3D; False #生成dev包或者dis包类型isWorkspace &#x3D; False #工程类型 pod工程 -workspace 普通工程 -project# 项目根目录project_path &#x3D; &#39;&#x2F;Users&#x2F;yostar&#x2F;Desktop&#x2F;ProjectiOSTest&#39;#当前autoIpa.py 以及 plist 所在文件夹位置#主执行文件的父级目录autoPythonRoot &#x3D; sys.path[0]# 发邮件相关信息from_addr &#x3D; &#39;250***2914@qq.com&#39;password &#x3D; &#39;plgke***pzbjdice&#39;smtp_host &#x3D; &#39;smtp.qq.com&#39;to_addr &#x3D; [&#39;250***2914@qq.com&#39;, &#39;1728***24@qq.com&#39;]# 需要配置分割线 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# 编译模式 Debug,Releasedef configuration(): if isDistribution: return &#39;Release&#39; else: return &#39;Debug&#39;# 编译成功后.xcarchive所在目录archive_dir &#x3D; project_path + &#39;&#x2F;archive&#39;# 打包后ipa存储目录targerIPA_dir &#x3D; project_path + &#39;&#x2F;ipaDir&#39;#CA certificate#发布包相关的plistDistributionExportFileName &#x3D; &quot;Distribution_ExportOptions.plist&quot;#测试包相关的plistDeveloperExportFileName &#x3D; &quot;Develop_ExportOptions.plist&quot;#时间字符串time_Tag &#x3D; &#39;%s&#39;%(time.strftime(&#39;%Y-%m-%d-%H-%M-%S&#39;, time.localtime(time.time())))#xcodebuild export ipa包命令时需要用到def export_OptionsPlist(): if isDistribution: return autoPythonRoot + &#39;&#x2F;&#39; + DistributionExportFileName else: return autoPythonRoot + &#39;&#x2F;&#39; + DeveloperExportFileName#打包名字def archiveName(): return project_Name + &#39;_&#39; + time_Tag + &#39;.xcarchive&#39;#archive地址def archivePath(): return &#39;%s&#x2F;%s&#39;%(archive_dir, archiveName())#ipa包名def ipaFileName(): return &#39;%s_%s&#39;%(project_Name, time_Tag)#ipa导出地址def exportPath(): if isDistribution: return &#39;%s&#x2F;%s&#x2F;%s&#39;%(targerIPA_dir, &#39;Distribution&#39;, ipaFileName()) else: return &#39;%s&#x2F;%s&#x2F;%s&#39;%(targerIPA_dir, &#39;development&#39;, ipaFileName())# 清理项目def clean_project(): os.system(&#39;rm -rf %s&#39;%(archive_dir)) print(project_path + &#39;******&#39; + project_Name + &#39;******&#39; + &#39;******&#39; + scheme + &#39;******&#39; + configuration()) if isWorkspace: os.system(&#39;cd %s; xcodebuild clean -workspace %s.xcworkspace -scheme %s -configuration %s&#39;%(project_path, project_Name, scheme, configuration())) else: os.system(&#39;cd %s; xcodebuild clean -project %s.xcodeproj -scheme %s -configuration %s&#39;%(project_path, project_Name, scheme, configuration()))#archive 打包def archive_project(): print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;archive_project start&#39;) print(archiveName()) if isWorkspace: os.system(&#39;cd %s; xcodebuild archive -workspace %s.xcworkspace -scheme %s -archivePath %s&#39;%(project_path, project_Name, scheme, archivePath())) else: os.system(&#39;cd %s; xcodebuild archive -project %s.xcodeproj -scheme %s -archivePath %s&#39;%(project_path, project_Name, scheme, archivePath())) # 打包ipa 并且保存在桌面def export_ipa(): print(&#39;export_ipa start&#39;) print(ipaFileName()) print(export_OptionsPlist()) os.system(&#39;cd %s; xcodebuild -exportArchive -archivePath %s&#x2F; -exportOptionsPlist %s -exportPath %s&#39;%(project_path, archivePath(), export_OptionsPlist(), exportPath()))##上传到firdef upload_fir(): p &#x3D; exportPath() + &#39;&#x2F;&#39; + scheme + &#39;.ipa&#39; if os.path.exists(p): print(&#39;watting&#x3D;&#x3D;&#x3D;%s...上传到fir&#39;%p) # 直接使用fir 有问题 这里使用了绝对地址 在终端通过 which fir 获得 ret &#x3D; os.system(&#39;fir publish %s -T %s&#39;%(p, fir_api_token)) print(&#39;watting...上传结束&#39;) return True else: print(&#39;没有找到IPA文件&#39;) return False# 发邮件def send_mail(): msg &#x3D; MIMEText(&#39;【%s】&#39;%scheme + &#39;iOS 测试项目完成，请下载测试！如有问题，请联系iOS相关人员，我们会及时解决，谢谢!&#39;, &#39;plain&#39;, &#39;utf-8&#39;) #发邮件内容 msg[&#39;From&#39;] &#x3D; Header(&#39;自动打包系统&lt;%s&gt;&#39; % from_addr, &#39;utf-8&#39;) #发件人 msg[&#39;To&#39;] &#x3D; Header(&#39;测试人员&#39;, &#39;utf-8&#39;) #收件人 msg[&#39;Subject&#39;] &#x3D; Header(&#39;【%s】&#39;%scheme + &#39;iOS客户端测试包构建完成, 构建时间:%s&#39;%(time_Tag), &#39;utf-8&#39;).encode() #邮件主题 try: server &#x3D; smtplib.SMTP(smtp_host, 25) server.set_debuglevel(1) server.login(from_addr, password) server.sendmail(from_addr, to_addr, msg.as_string()) print(&#39;邮件发送成功&#39;) except smtplib.SMTPException: print(&#39;Error:无法发送邮件&#39;) finally: server.quit() # 发送完毕后退出smtpdef main(): # 执行 # 清理目录 clean_project() # 编译coocaPods项目文件并 执行编译目录 archive_project() # 导出ipa export_ipa() if not isDistribution: # 上传fir success &#x3D; upload_fir() # 发邮件 if success: send_mail()main() 该脚本是把Distribution_ExportOptions.plist、Develop_ExportOptions.plist和脚本放在同一目录里面的 该脚本是针对xcode 8及以上版本的，低版本会出包失败 plist文件内容如下 1234567891011121314151617181920212223&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;&lt;plist version&#x3D;&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;provisioningProfiles&lt;&#x2F;key&gt; &lt;dict&gt; &lt;key&gt;com.Y***ane&lt;&#x2F;key&gt; &lt;string&gt;azur***_dev&lt;&#x2F;string&gt; &lt;&#x2F;dict&gt; &lt;key&gt;method&lt;&#x2F;key&gt; &lt;string&gt;development&lt;&#x2F;string&gt; &lt;key&gt;signingCertificate&lt;&#x2F;key&gt; &lt;string&gt;iPhone Developer&lt;&#x2F;string&gt; &lt;key&gt;signingStyle&lt;&#x2F;key&gt; &lt;string&gt;manual&lt;&#x2F;string&gt; &lt;key&gt;teamID&lt;&#x2F;key&gt; &lt;string&gt;42***ZL&lt;&#x2F;string&gt; &lt;key&gt;compileBitcode&lt;&#x2F;key&gt; &lt;false&#x2F;&gt; &lt;key&gt;uploadSymbols&lt;&#x2F;key&gt; &lt;false&#x2F;&gt;&lt;&#x2F;dict&gt;&lt;&#x2F;plist&gt; 其中plist文件中的method参数有如下几个方法：&#123;app-store, ad-hoc, enterprise, development&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome 浏览器扩展插件]]></title>
    <url>%2F2019%2F08%2F28%2FChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Chrome扩展可以在Google应用商店下载这里可以搜索安装你喜欢的各种扩展扩展这么多，推荐以下扩展 油猴Tampermonkey 暴力猴 AdGuard广告拦截器 广告终结者 JSON-handle Postwoman Browser Extension PostWoman Http接口调试插件 FeHelper(前端助手) 其中的油猴Tampermonkey和暴力猴是必须推荐的，它是扩展中的王者，最强大的浏览器扩展，下面讲解下安装和使用方法 安装油猴和暴力猴扩展如果能科学上网直接点击上面链接即可直接安装。上不了Google，可以在国内第三方Chrome插件网站搜索下载 crx4chrome chromecj cnplugins chromefor gugeapps下载的是个crx文件，然后打开Chrome扩展程序，打开开发者模式，将下载的crx文件拖进去，如果出错提示程序包无效。将crx后缀改为zip再拖进去就能安装成功了，浏览器右上角看到图标，即安装完成 注：一定要打开开发者模式，否则会安装失败。用该种方法安装的扩展，在Mac系统重启后，扩展会消失，需要重新安装，所以推荐Google商店直装，此方法首先需要能连上谷歌Chrome商店，必须先安装上一个直连谷歌的插件，安装方法按上面即可，然后就可以商店直装，永久使用以下3款插件可以直连谷歌商店，任选一个使用 谷歌学术助手：学术文献资料查询 谷歌访问助手：有12小时试用时间，设置浏览器首页可免费激活，永久使用 PP谷歌访问助手：永久免费，不限时 有了油猴和暴力猴扩展，还需要配上脚本才能使用安装完扩展后点击图标，选择获取新脚本会进入网站，这里可以获取脚本来源，有3个来源网站 userscripts-mirror openuserjs greasyfork这里推荐greasyfork，因为它支持中文，打开网站首页可以看到很多脚本，选择需要的脚本安装即可 暴力猴是一个可以加载油猴脚本的Chrome扩展，它支持Userscripts.org、GreasyFork、OpenUserJS三大脚本下载源。打开对应网站可以搜索到相应的油猴脚本，相比油猴就是它帮你搜索了，所以使用更方便点]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 13-Sign In with Apple]]></title>
    <url>%2F2019%2F08%2F21%2FiOS13SignInwithApple%2F</url>
    <content type="text"><![CDATA[最近了解了iOS 13新增功能之Sign In with Apple，Sign In with Apple是跨平台的，可以支持iOS、macOS、watchOS、tvOS、JS。本文主要内容为Sign In with Apple在iOS上的基础使用。详情参考WWDC 2019 审核备注 New Guidelines for Sign in with AppleWe’ve updated the App Store Review Guidelines to provide criteria for when apps are required to use Sign in with Apple. Starting today, new apps submitted to the App Store must follow these guidelines. Existing apps and app updates must follow them by April 2020. We’ve also provided new guidelines for using Sign in with Apple on the web and other platforms.September 12, 2019也就是说，所有已接入其它第三方登录的 App，Sign In with Apple 将被要求作为一种登录选择，否则就不给过。从今天开始(2019-9-12)，提交到App Store的新应用必须遵循这些准则，现有应用程序和应用程序更新必须在2020年4月之前进行。详情参考App Store审核指南 开发Sign In with Apple的注意事项需要在苹果后台打开该选项，并且重新生成Profiles配置文件，并安装到Xcode，如下图 服务端验证需要的文件，一个是私钥文件，一个是config.json文件 创建用于客户端身份验证的私钥返回Certificates, Identifiers &amp; Profiles主屏幕，从侧面导航中选择Keys 单击Configure按钮，然后选择你先前创建的Primary App ID，保存之后，Apple将为你生成一个新的私钥，并让你仅下载一次，请确保你保存了此文件，因为以后你将无法再次将其取回！你下载的文件将以.p8结尾，可以将其重命名为key.txt以便在后续步骤中更轻松地使用 创建config.json新文件，格式、内容和参数说明如下 1234567&#123; &quot;client_id&quot;: &quot;实际上被称为“Service ID”，您将在“Identifiers”部分创建它，其实就是应用的bundleID&quot;, &quot;team_id&quot;: &quot;后台账号的teamID&quot;, &quot;redirect_uri&quot;: &quot;重定向url，网页登录需要，只是客服端登录可以不写&quot;, &quot;key_id&quot;: &quot;在苹果后台获取，如下图&quot;, &quot;scope&quot;: &quot;设置我们要从用户那里收集什么信息，我们可以设置email和name，或者也可以不写&#125; web使用Sign In with Apple的相关配置，不需要web登录的，以下配置可以忽略 创建Services ID 在下一步中，你将定义用户在登录流程中将看到的应用程序的名称，并定义成为OAuth的标识符client_id，确保还选中Sign In with Apple复选框 创建web Authentication Configuration，定义应用程序的重定向URL iOS使用Sign In with Apple在Xcode的准备工作在Xcode11 Signing &amp; Capabilities中添加Sign In With Apple，如下图 iOS Sign In with Apple流程 导入系统头文件#import &lt;AuthenticationServices/AuthenticationServices.h&gt;，添加Sign In with Apple登录按钮，设置ASAuthorizationAppleIDButton相关布局，并添加按钮点击响应事件 获取授权码 验证 导入系统头文件#import &lt;AuthenticationServices/AuthenticationServices.h&gt;，添加Sign In with Apple登录按钮，设置ASAuthorizationAppleIDButton相关布局，并添加按钮点击响应事件。当然苹果也允许自定义苹果登录按钮的样式，样式要求详见这个文档：Human Interface Guidelines12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- (void)configUI&#123; &#x2F;&#x2F; 使用系统提供的按钮，要注意不支持系统版本的处理 if (@available(iOS 13.0, *)) &#123; &#x2F;&#x2F; Sign In With Apple Button ASAuthorizationAppleIDButton *appleIDBtn &#x3D; [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeDefault style:ASAuthorizationAppleIDButtonStyleWhite]; appleIDBtn.frame &#x3D; CGRectMake(30, self.view.bounds.size.height - 180, self.view.bounds.size.width - 60, 100); &#x2F;&#x2F; appleBtn.cornerRadius &#x3D; 22.f; [appleIDBtn addTarget:self action:@selector(didAppleIDBtnClicked) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:appleIDBtn]; &#125; &#x2F;&#x2F; 或者自己用UIButton实现按钮样式 UIButton *addBtn &#x3D; [UIButton buttonWithType:UIButtonTypeCustom]; addBtn.frame &#x3D; CGRectMake(30, 80, self.view.bounds.size.width - 60, 44); addBtn.backgroundColor &#x3D; [UIColor orangeColor]; [addBtn setTitle:@&quot;Sign in with Apple&quot; forState:UIControlStateNormal]; [addBtn addTarget:self action:@selector(didCustomBtnClicked) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:addBtn];&#125;&#x2F;&#x2F; 自己用UIButton按钮调用处理授权的方法- (void)didCustomBtnClicked&#123; &#x2F;&#x2F; 封装Sign In with Apple 登录工具类，使用这个类时要把类对象设置为全局变量，或者直接把这个工具类做成单例，如果使用局部变量，和IAP支付工具类一样，会导致苹果回调不会执行 self.signInApple &#x3D; [[SignInApple alloc] init]; [self.signInApple handleAuthorizationAppleIDButtonPress];&#125;&#x2F;&#x2F; 使用系统提供的按钮调用处理授权的方法- (void)didAppleIDBtnClicked&#123; &#x2F;&#x2F; 封装Sign In with Apple 登录工具类，使用这个类时要把类对象设置为全局变量，或者直接把这个工具类做成单例，如果使用局部变量，和IAP支付工具类一样，会导致苹果回调不会执行 self.signInApple &#x3D; [[SignInApple alloc] init]; [self.signInApple handleAuthorizationAppleIDButtonPress];&#125;&#x2F;&#x2F; 处理授权- (void)handleAuthorizationAppleIDButtonPress&#123; NSLog(@&quot;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&quot;); if (@available(iOS 13.0, *)) &#123; &#x2F;&#x2F; 基于用户的Apple ID授权用户，生成用户授权请求的一种机制 ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [[ASAuthorizationAppleIDProvider alloc] init]; &#x2F;&#x2F; 创建新的AppleID 授权请求 ASAuthorizationAppleIDRequest *appleIDRequest &#x3D; [appleIDProvider createRequest]; &#x2F;&#x2F; 在用户授权期间请求的联系信息 appleIDRequest.requestedScopes &#x3D; @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail]; &#x2F;&#x2F; 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器 ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:@[appleIDRequest]]; &#x2F;&#x2F; 设置授权控制器通知授权请求的成功与失败的代理 authorizationController.delegate &#x3D; self; &#x2F;&#x2F; 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户 authorizationController.presentationContextProvider &#x3D; self; &#x2F;&#x2F; 在控制器初始化期间启动授权流 [authorizationController performRequests]; &#125;else&#123; &#x2F;&#x2F; 处理不支持系统版本 NSLog(@&quot;该系统版本不可用Apple登录&quot;); &#125;&#125; 注意：封装Sign In with Apple 登录工具类，使用这个类时要把类对象设置为全局变量，或者直接把这个工具类做成单例，如果使用局部变量，和IAP支付工具类一样，会导致苹果回调不会执行 已经使用Sign In with Apple登录过app的用户如果设备中存在iCloud Keychain凭证或者AppleID凭证，提示用户直接使用TouchID或FaceID登录即可，代码如下12345678910111213141516171819202122232425&#x2F;&#x2F; 如果存在iCloud Keychain 凭证或者AppleID 凭证提示用户- (void)perfomExistingAccountSetupFlows&#123; NSLog(@&quot;&#x2F;&#x2F;&#x2F;已经认证过了&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&quot;); if (@available(iOS 13.0, *)) &#123; &#x2F;&#x2F; 基于用户的Apple ID授权用户，生成用户授权请求的一种机制 ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [[ASAuthorizationAppleIDProvider alloc] init]; &#x2F;&#x2F; 授权请求AppleID ASAuthorizationAppleIDRequest *appleIDRequest &#x3D; [appleIDProvider createRequest]; &#x2F;&#x2F; 为了执行钥匙串凭证分享生成请求的一种机制 ASAuthorizationPasswordProvider *passwordProvider &#x3D; [[ASAuthorizationPasswordProvider alloc] init]; ASAuthorizationPasswordRequest *passwordRequest &#x3D; [passwordProvider createRequest]; &#x2F;&#x2F; 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器 ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:@[appleIDRequest, passwordRequest]]; &#x2F;&#x2F; 设置授权控制器通知授权请求的成功与失败的代理 authorizationController.delegate &#x3D; self; &#x2F;&#x2F; 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户 authorizationController.presentationContextProvider &#x3D; self; &#x2F;&#x2F; 在控制器初始化期间启动授权流 [authorizationController performRequests]; &#125;else&#123; &#x2F;&#x2F; 处理不支持系统版本 NSLog(@&quot;该系统版本不可用Apple登录&quot;); &#125;&#125; 获取授权码获取授权码需要在代码中实现两个代理回调ASAuthorizationControllerDelegate、ASAuthorizationControllerPresentationContextProviding分别用于处理授权登录成功和失败、以及提供用于展示授权页面的Window，代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#pragma mark - delegate&#x2F;&#x2F;@optional 授权成功地回调- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))&#123; NSLog(@&quot;授权完成:::%@&quot;, authorization.credential); NSLog(@&quot;%s&quot;, __FUNCTION__); NSLog(@&quot;%@&quot;, controller); NSLog(@&quot;%@&quot;, authorization); if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123; &#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; authorization.credential; NSString *user &#x3D; appleIDCredential.user; &#x2F;&#x2F; 使用过授权的，可能获取不到以下三个参数 NSString *familyName &#x3D; appleIDCredential.fullName.familyName; NSString *givenName &#x3D; appleIDCredential.fullName.givenName; NSString *email &#x3D; appleIDCredential.email; NSData *identityToken &#x3D; appleIDCredential.identityToken; NSData *authorizationCode &#x3D; appleIDCredential.authorizationCode; &#x2F;&#x2F; 服务器验证需要使用的参数 NSString *identityTokenStr &#x3D; [[NSString alloc] initWithData:identityToken encoding:NSUTF8StringEncoding]; NSString *authorizationCodeStr &#x3D; [[NSString alloc] initWithData:authorizationCode encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@\n\n%@&quot;, identityTokenStr, authorizationCodeStr); &#x2F;&#x2F; Create an account in your system. &#x2F;&#x2F; For the purpose of this demo app, store the userIdentifier in the keychain. &#x2F;&#x2F; 需要使用钥匙串的方式保存用户的唯一信息&#x2F;&#x2F; [YostarKeychain save:KEYCHAIN_IDENTIFIER(@&quot;userIdentifier&quot;) data:user]; &#125;else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]])&#123; &#x2F;&#x2F; 这个获取的是iCloud记录的账号密码，需要输入框支持iOS 12 记录账号密码的新特性，如果不支持，可以忽略 &#x2F;&#x2F; Sign in using an existing iCloud Keychain credential. &#x2F;&#x2F; 用户登录使用现有的密码凭证 ASPasswordCredential *passwordCredential &#x3D; authorization.credential; &#x2F;&#x2F; 密码凭证对象的用户标识 用户的唯一标识 NSString *user &#x3D; passwordCredential.user; &#x2F;&#x2F; 密码凭证对象的密码 NSString *password &#x3D; passwordCredential.password; &#125;else&#123; NSLog(@&quot;授权信息均不符&quot;); &#125;&#125;&#x2F;&#x2F; 授权失败的回调- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))&#123; &#x2F;&#x2F; Handle error. NSLog(@&quot;Handle error：%@&quot;, error); NSString *errorMsg &#x3D; nil; switch (error.code) &#123; case ASAuthorizationErrorCanceled: errorMsg &#x3D; @&quot;用户取消了授权请求&quot;; break; case ASAuthorizationErrorFailed: errorMsg &#x3D; @&quot;授权请求失败&quot;; break; case ASAuthorizationErrorInvalidResponse: errorMsg &#x3D; @&quot;授权请求响应无效&quot;; break; case ASAuthorizationErrorNotHandled: errorMsg &#x3D; @&quot;未能处理授权请求&quot;; break; case ASAuthorizationErrorUnknown: errorMsg &#x3D; @&quot;授权请求失败未知原因&quot;; break; default: break; &#125; NSLog(@&quot;%@&quot;, errorMsg);&#125;&#x2F;&#x2F; 告诉代理应该在哪个window 展示内容给用户- (ASPresentationAnchor)presentationAnchorForAuthorizationController:(ASAuthorizationController *)controller API_AVAILABLE(ios(13.0))&#123; NSLog(@&quot;88888888888&quot;); &#x2F;&#x2F; 返回window return [UIApplication sharedApplication].windows.lastObject;&#125; 在授权登录成功回调中，我们可以拿到以下几类数据 UserID:Unique, stable, team-scoped user ID，苹果用户唯一标识符，该值在同一个开发者账号下的所有App下是一样的，开发者可以用该唯一标识符与自己后台系统的账号体系绑定起来（这与国内的微信、QQ、微博等第三方登录流程基本一致） Verification data:Identity token, code，验证数据，用于传给开发者后台服务器，然后开发者服务器再向苹果的身份验证服务端验证，本次授权登录请求数据的有效性和真实性，详见Sign In with Apple REST API Account information:Name, verified email，苹果用户信息，包括全名、邮箱等，注意：如果玩家登录时拒绝提供真实的邮箱账号，苹果会生成虚拟的邮箱账号，而且记录过的苹果账号再次登录这些参数拿不到 验证关于验证的这一步，需要传递授权码给自己的服务端，自己的服务端调用苹果API去校验授权码Generate and validate tokens。如果验证成功，可以根据userIdentifier判断账号是否已存在，若存在，则返回自己账号系统的登录态，若不存在，则创建一个新的账号，并返回对应的登录状态给App 推荐验证步骤为： 服务端拿authorizationCode去苹果后台验证，验证地址https://appleid.apple.com/auth/token，苹果返回id_token，与客户端获取的identityToken值一样，格式如下1234567&#123; &quot;access_token&quot;: &quot;一个token&quot;, &quot;token_type&quot;: &quot;Bearer&quot;, &quot;expires_in&quot;: 3600, &quot;refresh_token&quot;: &quot;一个token&quot;, &quot;id_token&quot;: &quot;结果是JWT，字符串形式，identityToken&quot;&#125; 另外授权code是有时效性的，且使用一次即失效 服务器拿到相应结果后，其中id_token是JWT数据，解码id_token，得到如下内容123456789&#123; &quot;iss&quot;:&quot;https:&#x2F;&#x2F;appleid.apple.com&quot;, &quot;aud&quot;:&quot;这个是你的app的bundle identifier&quot;, &quot;exp&quot;:1567482337, &quot;iat&quot;:1567481737, &quot;sub&quot;:&quot;这个字段和客户端获取的user字段是完全一样的&quot;, &quot;c_hash&quot;:&quot;8KDzfalU5kygg5zxXiX7dA&quot;, &quot;auth_time&quot;:1567481737&#125; 其中aud与你app的bundleID一致，sub就是授权用户的唯一标识，与手机端获得的user一致，服务器端通过对比sub字段信息是否与手机端上传的user信息一致来确定是否成功登录该token的有效期是10分钟，具体后端验证参考附录 附：官方示例代码 Swift 版附：What the Heck is Sign In with Apple?附：Sign In with Apple 从登陆到服务器验证附：苹果授权登陆后端验证附：[官方文档] Generate and validate tokens附：[官方文档] App Store审核指南附：SignInAppleDemo]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 搭建基于Hexo-Github的Blog]]></title>
    <url>%2F2019%2F08%2F14%2Fmac%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EHexo-Github%E7%9A%84Blog%2F</url>
    <content type="text"><![CDATA[GitHubPages + Hexo：免费，使用简单，使用者众多 博客搭建 创建 GitHub 仓库 注意 Respository name 中一定要输入：你的用户名.github.io其他地方不用修改，然后直接点 ”Create repository“ 按钮完成创建即可 安装博客需要的框架 安装 Homebrew$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 查询Homebrew是否安装成功的命令$ brew -v 安装 git$ brew install git 查询git是否安装成功的命令$ git –version 安装 node.js$ brew install node 查询node是否安装成功的命令$ node -v 安装 hexo$ npm install -g hexo 查询hexo是否安装成功的命令$ hexo -v 安装博客相关插件 自动部署到Github上的插件$ npm install hexo-deployer-git --save 安装atom生成插件，便于感兴趣的小伙伴们订阅(RSS订阅)$ npm install hexo-generator-feed --save然后在本地Blog根目录下的_config.yml文件中，添加以下配置123456789# Extensions## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;#RSS订阅plugin: -hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 在主题目录下的_config.yml目录下，添加如下配置rss: /atom.xml 安装博客首页生成插件$ npm install hexo-generator-index --save 安装tag生成插件$ npm install hexo-generator-tag --save到此为止，安装完毕 创建博客、调试、发布 创建本地一个目录，用来创建博客$ hexo init Blog执行成功后，会创建出一个名为Blog的文件夹 撰写博客内容cd到Blog文件夹下，执行命令$ hexo new firstBlog在Blog/source/_posts中就会新建一个firstBlog.md的文件，然后你就可以编辑你的博客内容了，Visual Studio Code编辑器支持预览，还可以和印象笔记同步 本地调试$ sudo hexo server 或 $ sudo hexo s然后可以访问http://localhost:4000来查看结果 安装发布插件在博客文件夹运行下面命令$ npm install hexo-deployer-git --save然后在_config.yml文件修改发布的配置，最后一行改为（注意替换yourusername）1234567891011# Sitetitle: 博客的名字subtitle: 博客副标题description: 博客描述author: 博客作者language: zh-Hanstheme: next &#x2F;&#x2F;安装的主题名称deploy: type: git &#x2F;&#x2F;使用Git 发布 repo: https:&#x2F;&#x2F;github.com&#x2F;yourusername&#x2F;yourusername.github.com.git &#x2F;&#x2F;自己的Github仓库地址 branch: master 运行生成发布12$ sudo hexo g$ sudo hexo d 如果改动了站点的源码，需要在发布之前$ sudo hexo clean 如果成功了就可以通过yourusername.github.com或者yourusername.github.io来访问你的博客了 配置博客分类内容 新增资源分类页面12345678910hexo new page aboutINFO Created: ~&#x2F;blog&#x2F;source&#x2F;about&#x2F;index.md&#x2F;&#x2F; 打开修改为如下---title: aboutdate: 2016-09-17 13:21:20tags: 代码库 &#x2F;&#x2F; 标签comment: false &#x2F;&#x2F; 添加这行关闭评论---here is something about me 新添加的菜单需要翻译对应的中文打开\themes\next\languages文件夹，创建主站配置语言的对应文件，如：zh-Hans.yml 自定义博客 更换主题如果你对默认的主题不满意，可以通过克隆的方式，把别人的主题克隆到项目”/themes”路径下，喵神的主题在这里，Hexo也有更多主题，比如使用这一套git clone https://github.com/iissnan/hexo-theme-next.git themes/next然后在blog/themes文件夹下，会看到一个next文件夹，在next中有一个_config.yml文件，它就是主题配置文件，这里略过设置详情；要设置博客主题的话，还是要回到根目录下(Blog文件夹下)的_config.yml文件中，将theme属性由landscape修改为next，还有注意配置的键值之间一定要有空格。更多设置修改并保存之后，我们再执行命令12$ hexo g$ hexo d 执行完毕以后，就可以在本地或者git上看到博客的新主题了，更多的主题可以参考知乎 设置网页浏览次数打开themes/你的主题/layout/_partial/footer.ejs添加即可 123456789101112# 脚本&lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;# 标签# pv的方式，单个用户连续点击n篇文章，记录n次访问量&lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次&lt;&#x2F;span&gt;# uv的方式，单个用户连续点击n篇文章，只记录1次访客数&lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt; 总访客数&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;人&lt;&#x2F;span&gt; 评论功能使用韩国来必力评论，需要注册账号详见官网在主题配置文件下添加page_comment: true在\themes\random\layout\_partial文件夹中新建livere.ejs文件并添加如下代码 1234567891011121314151617181920&lt;section class&#x3D;&quot;livere&quot; id&#x3D;&quot;comments&quot;&gt; &lt;!-- 来必力City版安装代码 --&gt; &lt;div id&#x3D;&quot;lv-container&quot; data-id&#x3D;&quot;city&quot; data-uid&#x3D;&quot;MTAyM***注册成功官方返回的uid****xNzkwMw&#x3D;&#x3D;&quot;&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; (function(d, s) &#123; var j, e &#x3D; d.getElementsByTagName(s)[0]; if (typeof LivereTower &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123; return; &#125; j &#x3D; d.createElement(s); j.src &#x3D; &#39;https:&#x2F;&#x2F;cdn-city.livere.com&#x2F;js&#x2F;embed.dist.js&#39;; j.async &#x3D; true; e.parentNode.insertBefore(j, e); &#125;)(document, &#39;script&#39;); &lt;&#x2F;script&gt; &lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;&#x2F;noscript&gt; &lt;&#x2F;div&gt; &lt;!-- City版安装代码已完成 --&gt;&lt;&#x2F;section&gt; 在\themes\random\layout\post.ejs文件中添加或修改如下代码123&lt;% if (page.comment || theme.page_comment) &#123; %&gt; &lt;%- partial(&#39;_partial&#x2F;livere&#39;,&#123;&#125;) %&gt;&lt;% &#125; %&gt; 顶部加载条在\themes\random\layout\_partial head.swig或head.ejs文件中添加如下代码 123456789101112131415&lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;pace&#x2F;1.0.2&#x2F;pace.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;link href&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;pace&#x2F;1.0.2&#x2F;themes&#x2F;pink&#x2F;pace-theme-flash.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; &lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; &#x2F;*进度条颜色*&#x2F; height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; &#x2F;*阴影颜色*&#x2F; &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; &#x2F;*上边框颜色*&#x2F; border-left-color: #1E92FB; &#x2F;*左边框颜色*&#x2F; &#125; &lt;&#x2F;style&gt; 安全运行天数在\themes\random\layout\_partial footer.swig或footer.ejs页脚部分添加如下代码 12345678910111213141516171819# 标签&lt;span id&#x3D;&quot;timeDate&quot;&gt;载入天数...&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;times&quot;&gt;载入时分秒...&lt;&#x2F;span&gt;# 脚本&lt;script&gt; var now &#x3D; new Date(); function createtime() &#123; var grt&#x3D; new Date(&quot;07&#x2F;08&#x2F;2018 12:00:00&quot;);&#x2F;&#x2F;此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days &#x3D; (now - grt ) &#x2F; 1000 &#x2F; 60 &#x2F; 60 &#x2F; 24; dnum &#x3D; Math.floor(days); hours &#x3D; (now - grt ) &#x2F; 1000 &#x2F; 60 &#x2F; 60 - (24 * dnum); hnum &#x3D; Math.floor(hours); if(String(hnum).length &#x3D;&#x3D;1 )&#123;hnum &#x3D; &quot;0&quot; + hnum;&#125; minutes &#x3D; (now - grt ) &#x2F; 1000 &#x2F;60 - (24 * 60 * dnum) - (60 * hnum); mnum &#x3D; Math.floor(minutes); if(String(mnum).length &#x3D;&#x3D;1 )&#123;mnum &#x3D; &quot;0&quot; + mnum;&#125; seconds &#x3D; (now - grt ) &#x2F; 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum &#x3D; Math.round(seconds); if(String(snum).length &#x3D;&#x3D;1 )&#123;snum &#x3D; &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML &#x3D; &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML &#x3D; hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;&#x2F;script&gt; 在每篇文章末尾统一添加“本文结束”标记接着打开\themes\vno\layout\post.ejs文件，在post-body之后， post-footer之前添加如下代码 123&lt;div&gt; &lt;div style&#x3D;&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class&#x3D;&quot;fa fa-paw&quot;&gt;&lt;&#x2F;i&gt;感谢您的阅读-------------&lt;&#x2F;div&gt;&lt;&#x2F;div&gt; 添加打赏功能，使用iframe嵌入打赏把下面代码添加到你想要的位置，一般是在&lt;article&gt;标签内，如\themes\vno\layout\post.ejs的标签内 &lt;iframe src=&quot;https://gsl201600.github.io/RewardCode&quot; style=&quot;overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; allowtransparency=&quot;true&quot;&gt;&lt;/iframe&gt;把该项目添加到你的网站，修改相关参数为你的打赏码，即可实现项目地址 在Hexo博客上添加可爱的Live 2D模型安装npm包$ npm install --save hexo-helper-live2d然后在Blog的配置文件_config.yml中添加如下配置，详细配置可以参考文档12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw&#x2F; pluginJsPath: lib&#x2F; pluginModelPath: assets&#x2F; tagMode: false debug: false model: use: live2d-widget-model-shizuku display: position: right width: 150 height: 300 mobile: show: true 然后下载模型，模型名称可以到这里参考，一些模型的预览可以在这里$ npm install live2d-widget-model-shizuku下载完之后，在Blog根目录中新建文件夹live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中，然后编辑配置文件中的model.use项，将其修改为live2d_models文件夹中的模型文件夹名称一切就绪之后，用hexo server命令启动服务器，稍等一下就可以看到右下角出现了一个可爱的萌萌哒的妹纸！不过因为所有东西都在Github上托管的原因，可能Live2D不能马上加载出来 Hexo操作指令一览123456789$ hexo clean #清理缓存$ hexo generate #生成静态文件$ hexo server #启动本地服务器$ hexo deploy #部署或者$ hexo clean #清理缓存$ hexo g #生成静态文件$ hexo s #启动本地服务器$ hexo d #部署 homebrew操作指令一览12345678910111213141516171819202122&#x2F;&#x2F; 安装 homebrew$ ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;&#x2F;&#x2F; 卸载 homebrew$ ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;uninstall)&quot;&#x2F;&#x2F; 查看版本$ brew -v&#x2F;&#x2F; 下载软件：brew install 软件名如：$ brew install htop, 安装htop&#x2F;&#x2F; 如需要图形安装的软件 要加cask如：$ brew cask install google-chrome&#x2F;&#x2F; 卸载软件:brew uninstall 软件名如: $ brew cask uninstall google-chrome&#x2F;&#x2F; 软件搜索:brew search 软件名如: $ brew search google&#x2F;&#x2F; 列出已安装的包$ brew list&#x2F;&#x2F; 查看软件相关信息:brew info 软件名如：$ brew info google-chrome&#x2F;&#x2F; 删除 Homebrew下载的包$ brew cleanup&#x2F;&#x2F; 更新 Homebrew$ brew update 附：给Hexo搭建的博客增加百度和谷歌的搜索引擎验证 验证站点搜索引擎验证的方法有好几种，下面选择 HTML标签验证 验证方法，其他的方法有兴趣可以自己去试一下 首先打开 百度搜索引擎验证 ，点击 添加网站 ，输入自己的 博客 地址 输完后选择 HTML标签验证 ，然后将下方的 meta 代码复制下来，网页先不要关 重新开一个页面，打开谷歌搜索引擎验证，点击添加属性，一样输入自己的博客地址 输完后选择备用方法下的HTML 标记，然后将下方的meta代码复制下来，网页也不要关 打开本地博客主题下的layout/_partial 文件夹，有一个名为head的文件，使用HTML编辑器打开，将刚才复制的两句meta代码粘贴进去 保存文件后，输入以下命令将博客重新部署到GitHub服务器hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 然后分别点击刚才百度、谷歌验证页面的验证按钮进行站点验证 生成站点地图 打开终端cd到本地博客目录下，输入以下命令安装sitmap插件12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 打开本地博客目录下的_config.yml文件，修改url参数为你博客的首页地址，这样是为了保证能正确生成sitemap.xml文件中的地址1234url: http:&#x2F;&#x2F;jonzzs.cn # 修改成你博客的首页地址root: &#x2F;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;permalink_defaults: 添加以下配置12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 输入以下命令重新部署博客hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 将站点地图提交谷歌 打开谷歌站点控制台进入站点控制台，先点击测试站点地图，测试通过后再点击提交站点地图 百度主动推送首先，在Hexo根目录下，安装本插件：$ npm install hexo-baidu-url-submit --save然后，同样在根目录下，把以下内容配置到_config.yml文件中:12345baidu_url_submit: count: 3 ## 提交最新的3个链接 host: www.hui-wang.info ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 其次，记得查看_config.ym文件中url的值， 必须包含是百度站长平台注册的域名，比如:1234# URLurl: http:&#x2F;&#x2F;www.hui-wang.inforoot: &#x2F;permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; 最后，加入新的deployer:12345deploy:- type: git ## 这是原来的deployer repo: https:&#x2F;&#x2F;github.com&#x2F;yourusername&#x2F;yourusername.github.com.git &#x2F;&#x2F;自己的Github仓库地址 branch: master- type: baidu_url_submitter ## 这是新加的 执行hexo deploy的时候，新的连接就会被推送了 百度自动推送安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度，修改主题目录下的layout/post.swig文件，末尾添加自动推送代码，代码如下1234567891011121314&lt;script&gt;(function()&#123; var bp &#x3D; document.createElement(&#39;script&#39;); var curProtocol &#x3D; window.location.protocol.split(&#39;:&#39;)[0]; if (curProtocol &#x3D;&#x3D;&#x3D; &#39;https&#39;) &#123; bp.src &#x3D; &#39;https:&#x2F;&#x2F;zz.bdstatic.com&#x2F;linksubmit&#x2F;push.js&#39;; &#125; else &#123; bp.src &#x3D; &#39;http:&#x2F;&#x2F;push.zhanzhang.baidu.com&#x2F;push.js&#39;; &#125; var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;&#x2F;script&gt; 用site:域名测试是否成功]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 发布个人开源框架到CocoaPods]]></title>
    <url>%2F2019%2F08%2F09%2FiOS%E5%8F%91%E5%B8%83%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%88%B0CocoaPods%2F</url>
    <content type="text"><![CDATA[需要做的工作包括以下几点 创建一个本地的仓库，将自己想要公开的代码搞进去 将自己的代码上传到远程公开仓库中去 创建一个pods 的描述文件 .podspec 修改.podspec描述文件中的相关的描述信息 将当前本地的.podspec文件传到CocoaPods官方的索引库中 测试一下，有没有上传到CocoaPods的索引库中 后期的升级维护 具体详细的步骤如下 创建远程仓库注意点 正规的仓库都有一个license文件，Pods依赖库对这个文件要求比较严格，需要有这个文件，建议使用MIT类型的license 代码版本要打tag(要在代码版本上传以后打tag) pod 支持 .a静态库、.framework 以及文件，不一定要是可运行的工程里面的某个组件 放代码的仓库不一定非要是Git仓库，只要是可以获取到相关代码文件就可以，可以是SVN的，也可以是zip包，区别就是在podspec中的source项填写的内容不同 创建一个pods 的描述文件 .podspec$ pod spec create MyViewExtension&lt;这个名称一般和创建的项目名称一样就可以&gt; 修改.podspec描述文件中的相关的描述信息详情可参考CocoaPods的官网的PodSpec语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Pod::Spec.new do |s| # 项目的名称 s.name &#x3D; &quot;MyViewExtension&quot; # 项目的版本号，通过项目git的tag标签进行对应，这里的标签代表的版本 s.version &#x3D; &quot;0.0.1&quot; # 项目简单的描述信息 s.summary &#x3D; &quot;Just Testing.&quot; # 项目的详细描述信息，注意，这里的文字的长度，一定要比上面的s.summary长，不然会认为格式不合格 s.description &#x3D; &lt;&lt;-DESC this project provide all kind of KeychainDeviceID for iOS developer DESC # 项目的网页主页信息，这里可以直接写自己的远程仓库的主页的地址 s.homepage &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;RunOfTheSnail&#x2F;MyViewExtension&quot; # 开源协议 s.license &#x3D; &quot;MIT&quot; # 作者信息 s.author &#x3D; &#123; &quot;zhangyan&quot; &#x3D;&gt; &quot;17***24@163.com&quot; &#125; # 这个比较重要，指的就是git的对应的远程仓库的地址以及版本号，版本号直接获取的是上面的s.version # 项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS # Supported Keys: # :git &#x3D;&gt; :tag, :branch, :commit, :submodules # :svn &#x3D;&gt; :folder, :tag, :revision # :hg &#x3D;&gt; :revision # :http &#x3D;&gt; :flatten, :type, :sha256, :sha1 s.source &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;RunOfTheSnail&#x2F;MyViewExtension.git&quot;, :tag &#x3D;&gt; s.version &#125; # 支持的平台及版本 s.platform &#x3D; :ios, &quot;11.0&quot; # 支持的ios最低版本 s.ios.deployment_target &#x3D; &quot;7.0&quot; # 如果是 Swift 的话指定 Swift 编译版本 # s.swift_version &#x3D; &quot;4.0&quot; # 必备项，代码源文件地址，如果有多个目录下则用逗号分开,否则&quot;public_header_files&quot;等不可用 s.source_files &#x3D; &quot;GSLXYKeychainDeviceID&#x2F;KeychainDeviceID&#x2F;**&#x2F;*.&#123;h,m&#125;&quot; # 公开头文件地址 # s.public_header_files &#x3D; &quot;Pod&#x2F;Classes&#x2F;**&#x2F;*.h&quot; # 所需的系统framework，多个用逗号隔开，不需要后缀名 # s.framework &#x3D; &quot;SomeFramework&quot; s.frameworks &#x3D; &quot;UIKit&quot;, &quot;AnotherFramework&quot; # 需要弱链接的框架 # s.weak_framework &#x3D; &quot;Twitter&quot; # s.weak_frameworks &#x3D; &quot;Twitter&quot;, &quot;SafariServices&quot; #项目依赖的库文件(这个是系统的库文件),不需要后缀名,比如sqlite,libz等.以lib开头的需要省略掉lib这三个字母.例如:libz需要简写为z否则报错 # s.library &#x3D; &quot;iconv&quot; # s.libraries &#x3D; &quot;iconv&quot;, &quot;xml2&quot; # 第三方或自己创建的 .Framework的名称 # s.vendored_frameworks &#x3D; &quot;YostarLib.framework&quot; # 第三方或自己创建的 .a静态库的名称 # s.vendored_libraries &#x3D; &quot;libYostarStaticLib.a&quot; # 添加资源文件 # s.resource &#x3D; &quot;XXX&#x2F;XXXX&#x2F;**&#x2F;*.bundle&quot; # s.resources &#x3D; &quot;XXX&#x2F;XXXX&#x2F;**&#x2F;*.bundle&quot; # CocoaPods会把这个库配置成static framework，同时支持Swift和Objective-C # s.static_framework &#x3D; true # 依赖关系，该项目所依赖的其他，当在加载的时候也会一块把相关的依赖的库加载下来，如果有多个需要填写多个 # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; # 是否使用ARC，如果指定具体文件，则具体的文件使用ARC s.requires_arc &#x3D; true # 指定项目配置，如HEADER_SEARCH_PATHS、OTHER_LDFLAGS等 # s.xcconfig &#x3D; &#123;&quot;OTHER_LDFLAGS&quot; &#x3D;&gt; &quot;-ObjC&quot;&#125; end 修改完毕之后进行检验一下.podspec的格式有木有问题123456789$ pod lib lint完整lint格式$ pod lib lint --allow-warnings --use-libraries --verbose --no-clean --sources&#x3D;&#39;http:&#x2F;&#x2F;10.11.180.29&#x2F;mobileDevelopers&#x2F;YZT-Loan-Pod-Spec.git&#39;--verbose:打印错误--allow-warnings:允许警告,默认有警告的podspec会验证失败--fail-fast:遇到错误马上停止，默认会完成全过程再停止--use-libraries:如果自己私有库包含library,引用了.a、.framework,在验证和提交时需要加--no-clean:检查问题--sources:如果依赖了其他不包含在官方specs里的pod，则用它来指明源，比如依赖了某个私有库。多个值以逗号分隔 将当前本地的podspec文件传到CocoaPods官方的索引库中5.1. 第一次需要上传需要注册$ pod trunk register zy_iOS2163.com &#39;zy&#39; --description=&#39;macbook air&#39; --verbose你注册的时候需要替换邮箱和名字，加上 –verbose 可以看到详细信息，然后你会收到一份邮件，需要点击验证 5.2. 使用$ pod trunk me查看注册信息是否注册成功 5.3. 如果你的pod是由多人维护的，你也可以添加其他维护者$ pod trunk add-owner JLC kyle@163.com（即：pod trunk add-owner 库名 邮箱）移除某个管理员$ pod trunk remove-owner TTLockSDK 邮箱地址（即：pod trunk remove-owner 库名 邮箱）$ pod trunk info TTLockSDK查看库当前状态，版本，所有人等5.4. 在提交 spec 文件前，如果发布的是 Swift 框架，需要指定 Swift 的版本，否则会报错，执行$ echo &quot;4.0&quot; &gt; .swift-version即可指定版本为 4.05.5. 执行命令，将 .podspec push到cocopods的trunk中$ pod trunk push MyViewExtension.podspec 测试一下，有没有上传到CocoaPods的索引库中 $ pod search SGExtension如果没有搜到，可能就是本地仓库没有更新 更新本地仓库$ pod repo update再次执行$ pod search SGExtension 如果还搜索不到，执行$ rm ~/Library/Caches/CocoaPods/search_index.json这句话是移除已经生成的搜索目录缓存文件,移除之后,执行pod search会重新生成一份最新的缓存列表 查看本地索引库:$ open ~/.cocoapods/repos 在个人项目中增加刚刚制作好的Podfile并使用新建一个测试工程测试，用CocoaPods初始化项目，编辑Podfile文件:1234567891011#CocoaPods官方spec仓库source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;#自己私有spec仓库source &#39;https:&#x2F;&#x2F;github.com&#x2F;wenmobo&#x2F;WBSpecs.git&#39;platform :ios, &#39;8.0&#39;target &#39;TestDemo&#39; do #防Crash库 pod &#39;WBAvoidCrash&#39;end 编辑好podfile文件之后，终端执行:123$ pod install 安装时使用，更新库使用update命令或$ pod update 更新时使用 后期的升级维护8.1. 更新远程公开库中的代码8.2. 修改.podspec中的配置，version升级一个版本8.3. 给当前的远程仓库的代码，重新打个tag，tag和.podspec的version一样8.4. 远程仓库的代码更新完毕，接下来执行上面的 5.将当前本地的spec文件传到CocoaPods官方的索引库中8.5. 检查使用上面的 6.测试一下，有没有上传到CocoaPods的索引库中 移除索引版本，纠正意外推送 移除该版本，然后重新push，在终端执行下面指令$ pod trunk delete TTLockSDK 2.6.4（即：pod trunk delete 库名 版本号） 也可以放弃整个pod和所有版本$ pod trunk deprecate TTLockSDK（即：pod trunk deprecate 库名）确认时，回复一个”y”(小写字母 y) 清理CocoaPods本地缓存特殊情况下，由于网络或者别的原因，通过CocoaPods下载的文件可能会有问题 手动删除(~/Library/Caches/CocoaPods/Pods/Release目录) 打开终端,输入$ pod cache list,会列出所有本地已经缓存的第三方库，在终端中输入$ pod cache clean AAA会删除AAA缓存库，使用$ pod cache clean --all清除所有缓存]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS copy相关]]></title>
    <url>%2F2019%2F08%2F08%2FiOScopy%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[strong和copy的区别当我们用@property来声明属性变量时，编译器会自动为我们生成一个以下划线加属性名命名的实例变量(@synthesize copyyStr = _copyyStr)，并且生成其对应的getter、setter方法。当我们用self.copyyStr = originStr赋值时，会调用coppyStr的setter方法，而_copyyStr = originStr赋值时给_copyyStr实例变量直接赋值，并不会调用copyyStr的setter方法，而在setter方法中有一个非常关键的语句_copyyStr = [copyyStr copy]; 结论：用self.copyyStr = originStr 赋值时，调用copyyStr的setter方法，setter方法对传入的copyyStr做了次深拷贝生成了一个新的对象赋值给_copyyStr，所以_copyyStr指向的地址和对象值都不再和originStr相同 assign与weak assign用来修饰基本数据类型，weak用来修饰OC对象 assign也能修饰OC对象，但是assign修饰的对象在该对象释放后，其指针依然存在，不会被置为nil，这就造成了一个很严重的问题：出现了野指针。当访问这个野指针时，指向了原地址，如果原地址被回收，就会造成程序的crash 用weak来修饰的话，对象释放的时候会把指针置为nil，从而避免了野指针的出现 基本数据类型为什么可以使用assign 这就要扯到堆和栈的问题了，基本数据类型会被分配到栈空间，而栈空间是由系统自动管理分配和释放的，就不会造成野指针的问题 copy和mutableCopy 容器类概念：NSArray、NSDictionary、NSSet为容器类型的对象 非容器类总结 对象类型 不可变对象 可变对象 copy 浅拷贝 深拷贝 mutableCopy 深拷贝 深拷贝 容器类型总结 对象类型 不可变对象 可变对象 copy 浅拷贝 深拷贝 mutableCopy 深拷贝 深拷贝]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS UIButton之改变有效点击区域]]></title>
    <url>%2F2019%2F08%2F07%2FiOSUIButton%E4%B9%8B%E6%94%B9%E5%8F%98%E6%9C%89%E6%95%88%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[解决方案通过重写- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;以改变按钮的有效点击区域12345678910111213141516171819- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; if (_qi_clickAreaReduceValue &gt; 0) &#123; if (_qi_clickAreaReduceValue &gt;&#x3D; CGRectGetWidth(self.bounds)&#x2F;2) &#123; _qi_clickAreaReduceValue &#x3D; CGRectGetWidth(self.bounds)&#x2F;2; &#125; CGRect bounds &#x3D; CGRectInset(self.bounds, _qi_clickAreaReduceValue, _qi_clickAreaReduceValue); return CGRectContainsPoint(bounds, point); &#125; &#x2F;&#x2F; 获取bounds 实际大小 CGRect bounds &#x3D; self.bounds; &#x2F;&#x2F; 若热区小于 44 * 44 则放大热区 否则保持原大小不变 CGFloat widthDelta &#x3D; MAX(44.f - bounds.size.width, 0.f); CGFloat heightDelta &#x3D; MAX(44.f - bounds.size.height, 0.f); &#x2F;&#x2F; 扩大bounds bounds &#x3D; CGRectInset(bounds, -0.5 * widthDelta, -0.5 * heightDelta); &#x2F;&#x2F; 点击的点在新的bounds 中 就会返回YES return CGRectContainsPoint(bounds, point);&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS OTA无线分发安装App内测下载]]></title>
    <url>%2F2019%2F08%2F01%2FiOSOTA%E6%97%A0%E7%BA%BF%E5%88%86%E5%8F%91%E5%AE%89%E8%A3%85App%E5%86%85%E6%B5%8B%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[搭建步骤 应用.ipa文件，可以是企业级签名，也可以是dev签名包 manifest.plist文件，plist文件和ipa文件必须放在支持https://服务器上，而且必须是公网ssl，自签名及免费的https不可用（本文以GitHub为例） 下载应用的html页面 manifest.plist内容如下12345678910111213141516171819202122232425262728293031&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;&lt;plist version&#x3D;&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;items&lt;&#x2F;key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;assets&lt;&#x2F;key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;&#x2F;key&gt; &lt;string&gt;software-package&lt;&#x2F;string&gt; &lt;key&gt;url&lt;&#x2F;key&gt; &lt;string&gt;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;***&#x2F;testIPA&#x2F;master&#x2F;Unity-iPhone.ipa&lt;&#x2F;string&gt; &lt;&#x2F;dict&gt; &lt;&#x2F;array&gt; &lt;key&gt;metadata&lt;&#x2F;key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;&#x2F;key&gt; &lt;string&gt;com.*****EN.****&lt;&#x2F;string&gt; &lt;key&gt;bundle-version&lt;&#x2F;key&gt; &lt;string&gt;0.1&lt;&#x2F;string&gt; &lt;key&gt;kind&lt;&#x2F;key&gt; &lt;string&gt;software&lt;&#x2F;string&gt; &lt;key&gt;title&lt;&#x2F;key&gt; &lt;string&gt;应用名称&lt;&#x2F;string&gt; &lt;&#x2F;dict&gt; &lt;&#x2F;dict&gt; &lt;&#x2F;array&gt;&lt;&#x2F;dict&gt;&lt;&#x2F;plist&gt; 将应用的.ipa文件，manifest.plist文件以及html下载页面，上传到GitHub上（支持https://服务器上） 注意：获取文件路径正确姿势 修改manifest.plist文件，将获取的下载路径，填写到manifest.plist文件中对应位置 html简易下载页面，下载链接必须是这样的格式itms-services://?action=download-manifest&amp;url=一个plist文件的地址1234567891011121314&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; &#x2F;&gt; &lt;title&gt;Install&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;p align&#x3D;center&gt; &lt;font size&#x3D;&quot;10&quot;&gt; &lt;a style&#x3D;&quot;color:#69DEDA&quot; href&#x3D;&quot;itms-services:&#x2F;&#x2F;?action&#x3D;download-manifest&amp;url&#x3D;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;***&#x2F;testIPA&#x2F;master&#x2F;DownloadPlist.plist&quot;&gt;点击安装&lt;&#x2F;a&gt; &lt;&#x2F;font&gt; &lt;&#x2F;p&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 附：如何直接在github上预览html网页效果 将github上demo的html文件链接复制到，打开下面网址后出现的输入栏中，点击按钮即可。1http:&#x2F;&#x2F;htmlpreview.github.io&#x2F; GitHub &amp; BitBucket HTML Preview 在HTML文件的地址前面加上htmlpreview.github.io/? 1htmlpreview.github.io&#x2F;?文件地址 在github上demo的仓库页面，点击setting按钮，找到GitHub Pages版块，选择Source为master branch，然后保存（或者在Theme Chooser处，点击Change theme，进入页面后选择主题保存，这样也可以）页面会出现一个新链接，在链接后面加上demo的HTML文件名，即可跳转到demo显示的页面 附：Github如何上传超过100M的大文件(使用 Git LFS)使用方式：先安装Git LFS的客户端，然后在将要push的仓库里重新打开一个bash命令行： 只需设置1次LFS：git lfs install 然后跟踪一下你要push的大文件的文件或指定文件类型git lfs track &quot;*.pdf&quot;当然还可以直接编辑.gitattributes文件 以上已经设置完毕，其余的工作就是按照正常的add, commit, push流程就可以了注：sourcetree集成的有LFS使用也非常方便 附：使用的SourceTree提交到git远程仓库的时候时出现了问题，一直处于这种状态POST Git-receive-pack (chunked) 解决办法打开SourceTree右上角的，设置 -&gt; 高级 -&gt; 编辑配置文件，来打开配置文件，在配置文件中添加如下配置，最后保存，重新尝试推送到仓库就可以了12[http] postBuffer &#x3D; 524288000]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 使用自定义字体]]></title>
    <url>%2F2019%2F07%2F24%2FiOS%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[1. 动态下载系统提供的中文字体 为了实现更好的字体效果，在应用中加入字体包问题： 字体文件比较大，会造成应用体积剧增 中文字体通常都是有版权的 动态下载中文字体的API可以动态的向iOS系统中添加字体文件，这些字体文件都是下载到系统的目录中，所以不会造成应用体积增加，字体文件下载后还可以在所有应用间共享。并且字体文件是iOS系统提供的，也免去了字体使用版权的问题 下载的时候需要使用的名字是 PostScript 名称，所以你要动态下载相应的字体的话，还需要使用 Mac 内自带的应用 “字体册 “来获得相应字体的 PostScript 名称。如下显示了从” 字体册 “中获取字体的 PostScript 名称的截图 苹果提供的动态下载代码的 Demo 工程 链接在这里。将此 Demo 工程下载下来，即可学习相应 API 的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#x2F;&#x2F; 1. 先判断该字体是否已经被下载下来了- (BOOL)isFontDownloaded:(NSString *)fontName &#123; UIFont* aFont &#x3D; [UIFont fontWithName:fontName size:12.0]; if (aFont &amp;&amp; ([aFont.fontName compare:fontName] &#x3D;&#x3D; NSOrderedSame || [aFont.familyName compare:fontName] &#x3D;&#x3D; NSOrderedSame)) &#123; return YES; &#125; else &#123; return NO; &#125;&#125;&#x2F;&#x2F; 2. 如果该字体下载过了，则可以直接使用。否则需要先准备下载字体 API 需要的一些参数&#x2F;&#x2F; 用字体的 PostScript 名字创建一个 DictionaryNSMutableDictionary *attrs &#x3D; [NSMutableDictionary dictionaryWithObjectsAndKeys:fontName, kCTFontNameAttribute, nil];&#x2F;&#x2F; 创建一个字体描述对象 CTFontDescriptorRefCTFontDescriptorRef desc &#x3D; CTFontDescriptorCreateWithAttributes((__bridge CFDictionaryRef)attrs);&#x2F;&#x2F; 将字体描述对象放到一个 NSMutableArray 中NSMutableArray *descs &#x3D; [NSMutableArray arrayWithCapacity:0];[descs addObject:(__bridge id)desc];CFRelease(desc);&#x2F;&#x2F; 3. 准备好上面的descs变量后，则可以进行字体的下载了__block BOOL errorDuringDownload &#x3D; NO;CTFontDescriptorMatchFontDescriptorsWithProgressHandler((CFArrayRef)descs, NULL, ^bool(CTFontDescriptorMatchingState state, CFDictionaryRef _Nonnull progressParameter)&#123; double progressValue &#x3D; [[(__bridge NSDictionary *)progressParameter objectForKey:(id)kCTFontDescriptorMatchingPercentage] doubleValue]; if (state &#x3D;&#x3D; kCTFontDescriptorMatchingDidBegin) &#123; NSLog(@&quot; 字体已经匹配 &quot;); &#125; else if (state &#x3D;&#x3D; kCTFontDescriptorMatchingDidFinish) &#123; if (!errorDuringDownload) &#123; NSLog(@&quot; 字体 %@ 下载完成 &quot;, fontName); &#125; &#125; else if (state &#x3D;&#x3D; kCTFontDescriptorMatchingWillBeginDownloading) &#123; NSLog(@&quot; 字体开始下载 &quot;); &#125; else if (state &#x3D;&#x3D; kCTFontDescriptorMatchingDidFinishDownloading) &#123; NSLog(@&quot; 字体下载完成 &quot;); dispatch_async( dispatch_get_main_queue(), ^ &#123; &#x2F;&#x2F; 可以在这里修改 UI 控件的字体 &#x2F;&#x2F; self.label.font &#x3D; [UIFont fontWithName:fontName size:12]; &#125;); &#125; else if (state &#x3D;&#x3D; kCTFontDescriptorMatchingDownloading) &#123; NSLog(@&quot; 下载进度 %.0f%%&quot;, progressValue); &#125; else if (state &#x3D;&#x3D; kCTFontDescriptorMatchingDidFailWithError) &#123; NSError *error &#x3D; [(__bridge NSDictionary *)progressParameter objectForKey:(id)kCTFontDescriptorMatchingError]; if (error !&#x3D; nil) &#123; _errorMessage &#x3D; [error description]; &#125; else &#123; _errorMessage &#x3D; @&quot;ERROR MESSAGE IS NOT AVAILABLE!&quot;; &#125; &#x2F;&#x2F; 设置标志 errorDuringDownload &#x3D; YES; NSLog(@&quot; 下载错误: %@&quot;, _errorMessage); &#125; return YES;&#125;); 2. 导入TTF字体文件使用自定义字体 下载字体导入工程（注意上文说的字体版权问题） 在 info.plist文件中告诉系统你想导入的字体文件 设置字体到相应控件上（使用的字体名字是 PostScript 名称，上文已说过怎样获取 PostScript 名称） 12345UILabel *label &#x3D; [[UILabel alloc] initWithFrame:CGRectMake(10, 100, 300, 400)];label.text &#x3D; @&quot;汉体书写信息技术标准相容档案下载使用界面简单&quot;;label.numberOfLines &#x3D; 0;UIFont *font &#x3D; [UIFont fontWithName:@&quot;FZLTXHK--GBK1-0&quot; size:40];[self.view addSubview:label];]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPhone 手机官方查询网站]]></title>
    <url>%2F2019%2F07%2F22%2FiPhone%E6%89%8B%E6%9C%BA%E5%AE%98%E6%96%B9%E6%9F%A5%E8%AF%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[今天给大家分享一些苹果官方网站，一定要收藏起来，以备不时之需。例如激活查询、苹果服务器状态等等。 查看激活日期当你新入手iPhone 或其他苹果设备，可以通过官方查看保障状态页面，在线查看激活日期，由此判断新设备是否被提前激活。苹果官方保修服务查询页面首先，打开手机设置 → 通用 → 关于本机，长按序列号，拷贝备用。然后，在Safari浏览器打开苹果官方保修服务查询页面，填入序列号进行查询。 查询结果包含你的设备名称，购买日期是否有效，电话技术支持是否有效。最重要的是维修和服务保障情况，会显示你的保修日期，这个日期往前一年，就是你设备的激活日期。 示例图片保修日期是2020年6月29日，说明该设备激活日期是2019 年6月29日 查看系统状态使用iPhone过程中，有时候会遇到网络服务问题，例如App Store无法打开、iCloud无法同步等等。我们可以通过苹果的系统状态页面查看。苹果官方服务系统状态在苹果的系统状态页面，可以看到可用服务、有故障的服务，以及已经修复的服务。这些数据实时更新，可以清晰的了解当前苹果服务状态。 链接为查看中国的苹果系统状态，你可以将链接中的cn换成其他国家代码，查看其他国家或地区的系统状态。例如cn换成us，查询美国的苹果系统状态 官方维修查询如果你的iPhone出现了问题，需要送官方维修，在这之前，一定要在iPhone维修页面先了解一下情况。苹果官方iPhone 维修页面，这里可以查看送修前的准备，以及一些项目的官方维修费用等等。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 后台运行方法]]></title>
    <url>%2F2019%2F07%2F19%2FiOS%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[应用可以调用UIApplication的beginBackgroundTaskWithExpirationHandler方法，让应用最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存、发送统计数据等工作。代码如下：1234567891011121314151617181920&#x2F;&#x2F; AppDelegate.h文件@property (nonatomic, assign) UIBackgroundTaskIdentifier backgroundUpdateTask;&#x2F;&#x2F; AppDelegate.m文件- (void)applicationDidEnterBackground:(UIApplication *)application &#123; [self beginBackgroundUpdateTask]; &#x2F;&#x2F; 在这里加上你需要长久运行的代码 [self endBackgroundUpdateTask];&#125;- (void)beginBackgroundUpdateTask&#123; self.backgroundUpdateTask &#x3D; [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123; [self endBackgroundUpdateTask]; &#125;];&#125;- (void)endBackgroundUpdateTask&#123; [[UIApplication sharedApplication] endBackgroundTask:self.backgroundUpdateTask]; self.backgroundUpdateTask &#x3D; UIBackgroundTaskInvalid;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Core Foundation对象的内存管理]]></title>
    <url>%2F2019%2F07%2F18%2FCoreFoundation%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Foundation对象和Core Foundation对象重要的区别是ARC下的内存管理问题，在非ARC下两者都需要开发者手动管理内存，没有区别，但是在ARC下系统只会自动管理Foundation对象的释放，而不支持Core Foundation对象的管理，因此在ARC下两者进行转换后必须要确定对象是由开发者手动管理还是ARC系统管理，否则可能导致内存泄露 由于ARC不能管理Core Foundation对象的生命周期，所以Core Foundation对象和Foundation对象转换时，需要使用到__bridge、__bridge_retained和__bridge_transfer三个转换关键字 __bridgeCF和OC对象转化时只涉及对象类型，不涉及对象所有权的转化，他的含义是，不改变对象的管理权所有者，本来由ARC管理的Foundation对象，转换成Core Foundation对象后依旧由ARC管理，本来有开发者手动管理的Core Foundation对象转换成Foundation对象后，继续由开发者手动管理 __bridge_transfer也可以使用CFBridgingRelease用在将Core Foundation对象转换为Foundation对象，同时将对象内存管理权交给ARC，由ARC来代替我们管理内存 __bridge_retained也可以使用CFBridgingRetain用在将Foundation对象转换为Core Foundation对象，同时将对象内存管理权交给我们，后续需要使用CFRelease或者相关方法来释放对象，需要我们手动来管理内存 如下例子为，网络请求中包含特殊字符的处理，报错信息为Error Domain=NSURLErrorDomain Code=-1002 &quot;unsupported URL&quot; UserInfo=&#123;NSLocalizedDescription=unsupported URL, NSUnderlyingError=0x7fa9b1d06120 &#123;Error Domain=kCFErrorDomainCFNetwork Code=-1002 &quot;(null)&quot;&#125;&#125;123NSString * resultUrl &#x3D; @&quot;网络请求字段或者地址&quot;;&#x2F;&#x2F; 处理请求中包含的特殊字符，如“+”NSString *endResutl &#x3D; (__bridge_transfer NSString *)CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (CFStringRef)resultUrl, NULL, CFSTR(&quot;+&quot;), kCFStringEncodingUTF8);]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods安装与使用步骤详解]]></title>
    <url>%2F2019%2F07%2F17%2FCocoaPods%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[目录 CocoaPods安装过程 CocoaPods的使用 删除cocoapods已导入项目的第三方库和移除项目中的cocoapods CocoaPods安装过程 安装并载入rvm环境 打开终端，输入指令$ rvm -v 安装rvm安装指令是$ curl -L https://get.rvm.io | bash -s stable载入RVM环境：$ source ~/.rvm/scripts/rvm检查是否安装成功：$ rvm -v rvm命令安装Ruby环境查看当前ruby版本$ ruby -v（检查当前版本,当ruby版本低于2.2.2时，安装cocoapods会报错）查看所有ruby版本$ rvm list known$ rvm list known命令会查询所有的ruby版本，找到最高版本号进行安装；若版本库里没有最新版本，输入：$ rvm get head升级到最新的存储库源版本安装指定版本，输入指令：$ rvm install 2.5.1 (选择较高版本)等待漫长的下载，编译过程，完成以后，Ruby, Ruby Gems 就自动安装好了注意：如果安装失败请手动安装 Homebrew $ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;再执行该$ rvm install 2.5.1命令，查询Homebrew是否安装成功的命令$ brew -v查看已经安装的ruby版本$ rvm list 卸载一个已安装版本$ rvm remove 2.5.1 设置默认Ruby版本安装好rvm之后可以指定特定Ruby版本为系统默认版本，输入命令：$ rvm 2.5.1 --default也可以指定其他版本号，前提是有用rvm install 安装过那个版本 检查更新ruby版本环境cocoapods是用gem ruby实现的，想要使用它首先需要有gem ruby的环境。且Mac的macos系统默认已经可以运行ruby。建议gem ruby包环境升级到2.6.x以上 检查gem ruby版本号：$ ruby -v $ gem -vGem是管理Ruby库和程序的标准包，如果它的版本过低也可能导致安装失败，解决的办法是更新gem版本 更新gem ruby版本$ gem update --system 检查ruby源并移除 检查ruby源$ gem sources -l因为Ruby环境默认的的软件源rubygems.org被屏蔽了，国内那面永远需要翻越的墙，我们需要来修改更换源，把源切换至ruby-china 移除掉原有的源$ gem sources --remove https://rubygems.org/ 添加国内最新的源$ gem sources -a https://gems.ruby-china.com 检查是否添加成功$ gem sources -l到这里就已经把Ruby环境安装成功 安装CocoaPods$ gem install -n /usr/local/bin cocoapods 查看是否安装成功并更新 查看是否成功$ pod --version 更新Podspec索引文件，创建本地索引库,如果没有报错，就说明一切安装成功了；这个过程需要一些时间$ pod setup查看本地索引库:$ open ~/.cocoapods/repos CocoaPods的使用 用Xcode创建一个工程，并创建podfile配置文件 进入项目目录$ cd ~ 创建Podfile文件$ touch Podfile 打开编辑，使用$ vi Podfile输入i进入编辑，编辑完成后按 esc 然后输入:wq按回车键 ，保存并退出 编辑Podfile文件我们可以在Podfile文件中写入需要用到的第三方库按如下格式：123456platform :ios, &#39;9.0&#39;use_frameworks!target &#39;TestDemo&#39; dopod &#39;Alamofire&#39;, &#39;~&gt; 4.0.1&#39;pod &#39;Kingfisher&#39;, &#39;~&gt; 3.1.1&#39;end Swift的pod文件在于use_frameworks! 这一句是必须的，作用是把三方库打包成静态库，而oc是不需要的 安装依赖库$ pod install (后续添加框架可直接pod update) 删除cocoapods已导入项目的第三方库和移除项目中的cocoapods 删除项目中已经由cocoapods配置好的第三方 打开项目中的Podfile文件 删除选中的pod Snapkit的命令行 打开终端cd到当前项目的根目录下重新执行$ pod install --verbose --no-repo-update或者直接$ pod install 删除项目中的cocoapods 手动删除 删除本地文件(Podfile、Podfile.lock、Pods文件夹、xcworkspace文件) 打开项目，在Frameworks文件夹下，删除Pods.xcconfig和libPods.a 进入项目Build Phases，删除Copy Pods Resources、Embed Pods Frameworks和Check Pods Manifest.lock 三项 删除了CocoaPod管理的第三方代码，在工程里面引用的第三方代码都会报错，需要删除对应的代码 通过第三方插件删除 安装cocoapods-deintegrate命令：$ sudo gem install cocoapods-deintegrate 然后到工程目录下面执行命令：$ pod deintegrate 手动删除.xcworkspace，libPods.a，Podfile，Podfile.lock文件 如果想要重装的话保留Podfile，再执行命令：$ pod install就好了 附：最新CocoaPods安装与使用步骤详解附：RubyGems 镜像]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS timer定时器正确使用方式]]></title>
    <url>%2F2019%2F07%2F11%2FiOStimer%E5%AE%9A%E6%97%B6%E5%99%A8%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 初始化，添加定时器前先移除1234[self.timer invalidate];self.timer &#x3D; nil;self.timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:2.f target:self selector:@selector(lookforCard:) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];2. 释放timer12[self.timer invalidate];self.timer &#x3D; nil;3. NSTimer不释放原因 原因是 Timer 添加到 Runloop 的时候，会被 Runloop 强引用；然后 Timer 又会有一个对 Target 的强引用（也就是 self ） 注意target参数的描述：The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated.注意：文档中写的很清楚，timer对target会有一个强引用，直到timer is invalidated。也就是说，在timer调用 invalidate方法之前，timer对target一直都有一个强引用。这也是为什么控制器的dealloc 方法不会被调用的原因。方法的文档介绍：The receiver retains aTimer. To remove a timer from all run loop modes on which it is installed, send an invalidate message to the timer.也就是说，runLoop会对timer有强引用，因此，timer修饰符是weak，timer还是不能释放，timer的target也就不能释放。 4. 解决办法 viewWillDisappear或viewDidDisappear中 invalidate这种方式是可以释放掉的，但如果我只是想在离开此页时要释放，进入下一页时不要释放，场景就不适用了12- (void)viewWillDisappear:(BOOL)animated- (void)viewDidDisappear:(BOOL)animated 添加一个NSTimer的分类，把target指给[NSTimer class]，事件由加方法接收，然后把事件通过block传递出来123456789101112131415161718192021@interface NSTimer (Block)+ (instancetype)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void(^)(NSTimer *timer))block;@end@implementation NSTimer (Block)+ (instancetype)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void(^)(NSTimer *timer))block&#123; NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:interval target:self selector:@selector(trigger:) userInfo:[block copy] repeats:repeats]; return timer;&#125;+ (void)trigger:(NSTimer *)timer&#123; void(^block)(NSTimer *timer) &#x3D; [timer userInfo]; if (block) &#123; block(timer); &#125;&#125;@end 使用示例12345678910111213141516171819202122@interface SecondViewController ()@property (nonatomic, strong) NSTimer *timer;@end@implementation SecondViewController- (void)viewDidLoad &#123; [super viewDidLoad]; __weak typeof(self) weakSelf &#x3D; self; self.timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:0.5 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; [weakSelf doSomeThing]; &#125;]; [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&#125;- (void)dealloc &#123; [self.timer invalidate];&#125;@end 5. invalidate方法注意事项 invalidate方法的介绍：（1）This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point.（2）You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.两点：（1）invalidate方法是唯一能从runloop中移除timer的方式，调用invalidate方法后，runloop会移除对timer的强引用（2）timer的添加和timer的移除（invalidate）需要在同一个线程中，否则timer可能不能正确的移除，线程不能正确退出]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 简单日志系统]]></title>
    <url>%2F2019%2F07%2F03%2FiOS%E7%AE%80%E5%8D%95%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425#define YostarDebugLogLevel(level, fmt, ...) \[YostarDebugLog logLevel:level file:__FILE__ function:__PRETTY_FUNCTION__ line:__LINE__ format:(fmt), ##__VA_ARGS__]#define YostarDebugLog(fmt, ...) \YostarDebugLogLevel(YostarDebugLogLevelInfo, (fmt), ##__VA_ARGS__)#define YostarDebugWarningLog(fmt, ...) \YostarDebugLogLevel(YostarDebugLogLevelWarning, (fmt), ##__VA_ARGS__)#define YostarDebugErrorLog(fmt, ...) \YostarDebugLogLevel(YostarDebugLogLevelError, (fmt), ##__VA_ARGS__)typedef NS_ENUM(NSUInteger, YostarDebugLogLevel) &#123; YostarDebugLogLevelInfo &#x3D; 1, YostarDebugLogLevelWarning, YostarDebugLogLevelError&#125;;@interface YostarDebugLog : NSObject+ (BOOL)isDebugLogEnabled;+ (void)enableDebugLog:(BOOL)enableLog;+ (void)logLevel:(NSInteger)level file:(const char *)file function:(const char *)function line:(NSUInteger)line format:(NSString *)format, ...; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static BOOL _enableLog;+ (void)initialize&#123; _enableLog &#x3D; NO;&#125;+ (BOOL)isDebugLogEnabled&#123; return _enableLog;&#125;+ (void)enableDebugLog:(BOOL)enableLog&#123; _enableLog &#x3D; enableLog;&#125;static id sharedInstance &#x3D; nil;+ (instancetype)sharedInstance&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedInstance &#x3D; [[self alloc] init]; &#125;); return sharedInstance;&#125;+ (void)logLevel:(NSInteger)level file:(const char *)file function:(const char *)function line:(NSUInteger)line format:(NSString *)format, ...&#123; @try &#123; &#x2F;&#x2F;参数链表指针 va_list args; &#x2F;&#x2F;遍历开始 va_start(args, format); NSString *message &#x3D; [[NSString alloc] initWithFormat:format arguments:args]; [self.sharedInstance logMessage:message level:level file:file function:function line:line]; &#x2F;&#x2F;结束遍历 va_end(args); &#125; @catch (NSException *exception) &#123; NSLog(@&quot;⚠️WARN::%@&quot;, exception); &#125; @finally &#123; &#125;&#125;- (void)logMessage:(NSString *)message level:(NSInteger)level file:(const char *)file function:(const char *)function line:(NSUInteger)line&#123; NSString *logMessage &#x3D; [NSString stringWithFormat:@&quot;[YostarLog][%@][line:%lu]: %s %s %@&quot;, [self descriptionForLevel:level], (unsigned long)line, function, &quot;&quot;, message]; if (_enableLog) &#123; NSLog(@&quot;%@&quot;, logMessage); &#125;&#125;- (NSString *)descriptionForLevel:(YostarDebugLogLevel)level&#123; NSString *desc &#x3D; nil; switch (level) &#123; case YostarDebugLogLevelInfo: desc &#x3D; @&quot;INFO&quot;; break; case YostarDebugLogLevelWarning: desc &#x3D; @&quot;⚠️WARN&quot;; break; case YostarDebugLogLevelError: desc &#x3D; @&quot;❌ERROR&quot;; break; default: desc &#x3D; @&quot;UNKNOW&quot;; break; &#125; return desc;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS IAP安全性问题汇总]]></title>
    <url>%2F2019%2F06%2F26%2FiOSIAP%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. 常用的攻击方式 劫持apple server攻击 重复验证攻击 跨app攻击 换价格攻击 歧义攻击 中间人攻击 2. 讲解攻击方式及处理 劫持apple server攻击 通过dns污染,让客户端通过假的apple_server进行verify,从而认为自己支付成功。这个主要针对客户端验证发货的方式,如果是服务端验证,就没效果了 重复验证攻击 因为同一个receipt,如果第一次验证成功,那么之后每次验证都会成功。如果服务端没有判重机制,就会导致一个receipt被当做多次充值处理。 为了预防这种情况,我们可以将receipt做一次md5得到receipt_md5, 每次发送充值请求的时候就按照receipt_md5判重,如果重复就停止商品发放；或者根据解析得到的信息进行判重 跨app攻击 通过在别的app中拿到receipt,然后发送到我们app中。因为这个receipt是合法的而且apple不会验证请求的源,所以这个receipt是可以验证通过的 对于这种情况,我们可以判断apple verify的返回值apple_callback_data中对应的bundle_id和我们app的bundle_id是否一样来进行验证 换价格攻击 在同一个app中,用低价商品的receipt伪造购买高价商品。这时候bundle_id和我们app的bundle_id是一致的 针对这种情况, 我们可以从apple verify的返回值apple_callback_data中拿到对应的product_id, 并按照product_id来进行充值。不要信任客户端的product_id 歧义攻击 在iOS6的时候,status=0表示此次支付成功,而现在变为status=0只表示receipt整体上合法。对iOS7即使是一个过期订单,也会返回status=0,如果还按照iOS6的逻辑处理,就会导致假充值 针对iOS7,我们应该不只通过status,还要通过in_app中的内容,来决定如何发放商品 For iOS 6 style transaction receipts, the status code reflects the status of the specific transaction’s receipt.For iOS 7 style app receipts, the status code is reflects the status of the app receipt as a whole. For example, if you send a valid app receipt that contains an expired subscription, the response is 0 because the receipt as a whole is valid. 中间人攻击 伪造apple server,将我们的支付请求转发到真的apple_server,拿到合法的receipt,并弄个假的receipt给客户端。这样就拿到一个合法的凭证。利用这个合法的receipt,伪造别人充值的请求,从而达到帮别人充值的目的 针对中间人攻击,最重要的是保证a用户的支付receipt,不能被b用户使用。但是apple为了保护隐私,receipt中没有任何用户的个人信息,这就需要我们自己来保证。目前我们可以用加密的手段来做这个保证 最后给出一个apple_callback_data的例子1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;status&quot;: 0, &quot;environment&quot;: &quot;Production&quot;, &quot;receipt&quot;: &#123; &quot;download_id&quot;: 75017873837267, &quot;adam_id&quot;: 1149703708, &quot;request_date&quot;: &quot;2017-01-13 06:57:20 Etc&#x2F;GMT&quot;, &quot;app_item_id&quot;: 1149703708, &quot;original_purchase_date_pst&quot;: &quot;2016-11-17 18:57:09 America&#x2F;Los_Angeles&quot;, &quot;version_external_identifier&quot;: 820252187, &quot;receipt_creation_date&quot;: &quot;2017-01-13 05:04:52 Etc&#x2F;GMT&quot;, &quot;in_app&quot;: [ &#123; &quot;is_trial_period&quot;: &quot;false&quot;, &quot;purchase_date_pst&quot;: &quot;2017-01-12 21:04:52 America&#x2F;Los_Angeles&quot;, &quot;original_purchase_date_pst&quot;: &quot;2017-01-12 21:04:52 America&#x2F;Los_Angeles&quot;, &quot;product_id&quot;: &quot;com.lucky917.live.gold.1.555&quot;, &quot;original_transaction_id&quot;: &quot;350000191094279&quot;, &quot;original_purchase_date&quot;: &quot;2017-01-13 05:04:52 Etc&#x2F;GMT&quot;, &quot;original_purchase_date_ms&quot;: &quot;1484283892000&quot;, &quot;purchase_date&quot;: &quot;2017-01-13 05:04:52 Etc&#x2F;GMT&quot;, &quot;purchase_date_ms&quot;: &quot;1484283892000&quot;, &quot;transaction_id&quot;: &quot;350000191094279&quot;, &quot;quantity&quot;: &quot;1&quot; &#125; ], &quot;original_purchase_date_ms&quot;: &quot;1479437829000&quot;, &quot;original_application_version&quot;: &quot;26&quot;, &quot;original_purchase_date&quot;: &quot;2016-11-18 02:57:09 Etc&#x2F;GMT&quot;, &quot;request_date_ms&quot;: &quot;1484290640800&quot;, &quot;bundle_id&quot;: &quot;com.lucky917.ios.Live&quot;, &quot;receipt_creation_date_pst&quot;: &quot;2017-01-12 21:04:52 America&#x2F;Los_Angeles&quot;, &quot;application_version&quot;: &quot;32&quot;, &quot;request_date_pst&quot;: &quot;2017-01-12 22:57:20 America&#x2F;Los_Angeles&quot;, &quot;receipt_creation_date_ms&quot;: &quot;1484283892000&quot;, &quot;receipt_type&quot;: &quot;Production&quot; &#125;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS IAP支付常见问题汇总与解决]]></title>
    <url>%2F2019%2F06%2F19%2FiOSIAP%E6%94%AF%E4%BB%98%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%E4%B8%8E%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[1. 获取不到商品信息的原因 沙盒的测试账号和你请求商品信息没有关系 iTunes Connect里面对应账号的协议、税务和银行业务信息有没有填完整，填好的应该是这个样子这个很容易疏忽，务必检查 确认证书是否添加IAP支付功能默认创建的证书是包含该项的 确定是真机测试且手机没有越狱大部分越狱手机也可以测试，深度越狱破坏系统的可能无法调起支付 确定内购商品添加到了需要内购功能的App中 确定当前运行的App的Bundle ID和后台配置的App的Bundle ID是一致的 可以尝试先删除旧App，再重新编译生成新的，避免新App未覆盖错误 如果上线后发现线上包请求不到商品信息，一般发生于首次提交App或添加新商品，可能是苹果缓存的bug，当你的App通过审核以后，你发现在生产环境下获取不到商品，这是因为App虽然过审核了，但是内购商品还没有正式添加到苹果的服务器里，耐心等待一段时间就可以啦，或者去苹果后台刷新配置商品信息列表，然后等待一天左右时间大概就可以了 2. 如果请求到了商品信息，也发送了购买请求，但是监听购买结果的方法就是不执行 可以检查一下，是否在工具类初始化的时候，添加了监听，添加监听代码如下 注：支付工具类一般用单例模式，避免创建多个对象或者对象提前释放，导致苹果回调不会调用支付失败，或者使用self全局化支付工具类对象，不可使支付工具类对象局部变量化123456789101112131415161718#pragma mark - 单例方法static IAPPayManager* instance &#x3D; nil;+ (instancetype)sharedInstance&#123; static dispatch_once_t onceToken &#x3D; 0; dispatch_once(&amp;onceToken, ^&#123; instance &#x3D; [[IAPPayManager alloc] init]; &#125;); return instance;&#125;#pragma mark - 重载初始化方法，注册用于处理支付回调的Observer- (instancetype)init&#123; self &#x3D; [super init]; if (self) &#123; [[SKPaymentQueue defaultQueue] addTransactionObserver:self]; &#125; return self;&#125; 3. IAP审核环境 苹果在审核App时，只会在sandbox环境购买，其产生的购买凭证，也只能连接苹果的测试验证服务器，审核时后台要保证沙盒测试环境开放，以免服务器无法验证通过IAP购买，造成App审核被拒 TestFlight测试时也是走的sandbox环境购买 4. 只要不是红色的状态都是可以进行支付测试的，元数据丢失是因为，在增加内购项目的时候，没有填写完全，产品ID是唯一的，假如你删除了一个内购项目，那么这个产品ID就不能用了，所以填写要慎重 5. 沙盒测试账号相关用沙盒账号测试支付的包，只能是adhoc签名证书或者develop签名证书打的包，不能是从AppStore或者TestFlight上下载的，还没上线之前App并没有地区之分，沙盒账号随便哪个地区都可以用来测试，弹出的购买提示框会根据当前沙盒账号AppleID的地区显示语言的 注册沙盒测试账号时，提示报错Unknown Errors while creating Sandbox Tester, Please check Error Log, email=a***st@qq.com解决方案：把你的密码设置的复杂点，比如包含数字、字母混大小写等 6. 支付时提示您已购买此App内购买项目。此项目将免费恢复问题 此提示说明iTunes订单被卡住，属于苹果ID支付问题，暂时可先选择其他额度进行支付，也可联系苹果的客服人员删除你异常的订单，打开浏览器进入Apple官方支持 7. 验证服务器地址和需要的参数说明 Key Value 是否必须 receipt-data The base64 encoded receipt data 是 password Only used for receipts that contain auto-renewable subscriptions. Your app’s shared secret (a hexadecimal string) 否，仅用于自动续订，获取方法见共享密钥附录 exclude-old-transactions Only used for iOS7 style app receipts that contain auto-renewable or non-renewing subscriptions. If value is true, response includes only the latest renewal transaction for any subscriptions 否，仅用于自动续订或非续订订阅的iOS 7样式的应用收据 在测试服务器中，发送receipt到苹果的测试服务器https://sandbox.itunes.apple.com/verifyReceipt验证 在正式服务器中已上线Appstore，发送receipt到苹果的正式服务器https://buy.itunes.apple.com/verifyReceipt验证 当我们把应用提交给苹果审核时，苹果也是在sandbox环境购买，其产生的购买凭证，也只能连接苹果的测试验证服务器，所以我们可以先发到苹果的正式服务器验证，如果苹果返回21007，则再一次连接测试服务器进行验证 8. 苹果返回状态码 Status 描述 0 App Store 验证成功 21000 App Store不能读取你提供的JSON对象 21002 receipt-data属性中的数据格式错误或丢失 21003 receipt无法通过验证 21004 提供的共享密码与帐户的文件共享密码不匹配 21005 receipt服务器当前不可用 21006 该收据有效，但订阅已过期，当此状态代码返回到您的服务器时，收据数据也会被解码并作为响应的一部分返回，仅针对自动续订的iOS 6样式交易收据返回 21007 receipt是Sandbox receipt，但却发送至生产系统的验证服务 21008 receipt是生产receipt，但却发送至Sandbox环境的验证服务 21010 此收据无法授权，就像从未进行过购买一样对待 关于苹果服务器验证返回21004的问题说明在购买类型是自动续订时，服务端做验证就要传入这个共享密钥，传入字段为password，共享密钥获取见附录，如果你们的商品不是自动续订，建议不要传入该字段，否则传入内容不正确可能会导致苹果返回21004 9. 国内连接苹果服务器的稳定性开发之初，苹果方就很负责的告知:我们的服务器不稳定。真正开发之后，发现苹果方果然是很负责的，不仅是不稳定，而且足够慢。app store server验证一个收据需要3-6s时间 10. 经验总结，如下内容已经过验证 程序加入支付队列使用SKMutablePayment和SKPayment的区别两者拥有的属性一样，唯一区别是属性读写权限不同，SKMutablePayment属性具有读写权限，SKPayment属性只读，如果你要使用applicationUsername透传字段，那么就一定要使用SKMutablePayment加入支付队列 透传字段applicationUsername可能返回的是nil在支付完成后，每笔订单都不调用finishTransaction，如此测试四五笔订单后，重新启动该应用，苹果自动补单会进行，在有些时候该字段就会为空，需要开发者注意 updatedTransactions:在App整个生命周期只会走一次，所以只要不把订单finishTransaction掉，重启App就会重新走苹果的补单流程(自动调用updatedTransactions:注意需要[[SKPaymentQueue defaultQueue] addTransactionObserver:instance];添加观察者才可以)，逻辑需要自己根据项目实现 SKPaymentTransaction *transaction属性官方说明 transaction.transactionDate将订单交易添加到服务器队列的日期，仅当状态为SKPaymentTransactionStatePurchased或SKPaymentTransactionStateRestored时有效 transaction.transactionIdentifiertransactionIdentifier是唯一标识交易支付成功的字符串，此值的格式与收据中的事务transaction_id相同，但是值可能不相同，仅当状态为SKPaymentTransactionStatePurchased或SKPaymentTransactionStateRestored时有效 transaction.originalTransaction原始交易id，仅当状态为SKPaymentTransactionStateRestored时有效有值 transaction.payment.applicationUsername获取之前设置的applicationUsername 注意：凭证验证后返回的original_transaction_id和transaction_id一般情况下是相同的，只会在恢复购买时不一样 transactionReceiptData可以无限验证通过，也就是说一个凭证可以被校验多次，这是刷单方法之一，需要开发者注意，苹果补单流程返回的transactionReceiptData即使同一笔订单也会变 transactionReceiptData验证解析后，in_app字段出现为空或者多个购买项目，只要不finishTransaction掉订单，下次再支付成功后，返回的transactionReceiptData凭证，就是包含之前的购买记录，最近购买的商品会在列表的第一个 验证凭证，苹果服务器返回的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; &quot;receipt&quot;: &#123; &quot;receipt_type&quot;: &quot;ProductionSandbox&quot;, &quot;adam_id&quot;: 0, &quot;app_item_id&quot;: 0, &quot;bundle_id&quot;: &quot;com.Yo***ights&quot;, &quot;application_version&quot;: &quot;1&quot;, &quot;download_id&quot;: 0, &quot;version_external_identifier&quot;: 0, &quot;receipt_creation_date&quot;: &quot;2020-06-01 09:37:57 Etc&#x2F;GMT&quot;, &quot;receipt_creation_date_ms&quot;: &quot;1591004277000&quot;, &quot;receipt_creation_date_pst&quot;: &quot;2020-06-01 02:37:57 America&#x2F;Los_Angeles&quot;, &quot;request_date&quot;: &quot;2020-06-01 09:38:55 Etc&#x2F;GMT&quot;, &quot;request_date_ms&quot;: &quot;1591004335844&quot;, &quot;request_date_pst&quot;: &quot;2020-06-01 02:38:55 America&#x2F;Los_Angeles&quot;, &quot;original_purchase_date&quot;: &quot;2013-08-01 07:00:00 Etc&#x2F;GMT&quot;, &quot;original_purchase_date_ms&quot;: &quot;1375340400000&quot;, &quot;original_purchase_date_pst&quot;: &quot;2013-08-01 00:00:00 America&#x2F;Los_Angeles&quot;, &quot;original_application_version&quot;: &quot;1.0&quot;, &quot;in_app&quot;: [ &#123; &quot;quantity&quot;: &quot;1&quot;, &quot;product_id&quot;: &quot;com.yo***thlycard&quot;, &quot;transaction_id&quot;: &quot;10***4780&quot;, &quot;original_transaction_id&quot;: &quot;10***4780&quot;, &quot;purchase_date&quot;: &quot;2020-06-01 09:36:56 Etc&#x2F;GMT&quot;, &quot;purchase_date_ms&quot;: &quot;1591004216000&quot;, &quot;purchase_date_pst&quot;: &quot;2020-06-01 02:36:56 America&#x2F;Los_Angeles&quot;, &quot;original_purchase_date&quot;: &quot;2020-06-01 09:36:56 Etc&#x2F;GMT&quot;, &quot;original_purchase_date_ms&quot;: &quot;1591004216000&quot;, &quot;original_purchase_date_pst&quot;: &quot;2020-06-01 02:36:56 America&#x2F;Los_Angeles&quot;, &quot;is_trial_period&quot;: &quot;false&quot; &#125;, &#123; &quot;quantity&quot;: &quot;1&quot;, &quot;product_id&quot;: &quot;com.yo***iteprime1&quot;, &quot;transaction_id&quot;: &quot;10***3950&quot;, &quot;original_transaction_id&quot;: &quot;10***3950&quot;, &quot;purchase_date&quot;: &quot;2020-06-01 09:35:30 Etc&#x2F;GMT&quot;, &quot;purchase_date_ms&quot;: &quot;1591004130000&quot;, &quot;purchase_date_pst&quot;: &quot;2020-06-01 02:35:30 America&#x2F;Los_Angeles&quot;, &quot;original_purchase_date&quot;: &quot;2020-06-01 09:35:30 Etc&#x2F;GMT&quot;, &quot;original_purchase_date_ms&quot;: &quot;1591004130000&quot;, &quot;original_purchase_date_pst&quot;: &quot;2020-06-01 02:35:30 America&#x2F;Los_Angeles&quot;, &quot;is_trial_period&quot;: &quot;false&quot; &#125; ] &#125;, &quot;status&quot;: 0, &quot;environment&quot;: &quot;Sandbox&quot;&#125; 附：[官方文档] Validating Receipts With the App Store附：[官方文档] 配置自动续期订阅共享密钥附：iOS开发内购流程]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Toast 实现]]></title>
    <url>%2F2019%2F06%2F05%2FiOSToast%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[123&#x2F;&#x2F; 对外暴露两个方法供调用+ (void)showToast:(NSString *)text;+ (void)showToast:(NSString *)text inView:(UIView *)superView; 123456789101112131415161718192021222324&#x2F;&#x2F; 实现方法+ (void)showToast:(NSString *)text&#123; [ToastUtil showToast:text inView:[UIApplication sharedApplication].windows.lastObject];&#125;+ (void)showToast:(NSString *)text inView:(UIView *)superView &#123; if (!superView) &#123; return; &#125; CGSize labelSize &#x3D; [text sizeWithAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20.f]&#125;]; UILabel *label &#x3D; [[UILabel alloc] init]; label.font &#x3D; [UIFont systemFontOfSize:18.f]; label.text &#x3D; text; label.textAlignment &#x3D; NSTextAlignmentCenter; label.layer.cornerRadius &#x3D; labelSize.height&#x2F;4; label.layer.masksToBounds &#x3D; YES; label.backgroundColor &#x3D; [UIColor colorWithRed:38&#x2F;255.f green:187&#x2F;255.f blue:251&#x2F;255.f alpha:1.f]; label.textColor &#x3D; [UIColor whiteColor]; label.frame &#x3D; CGRectMake((superView.bounds.size.width - labelSize.width)&#x2F;2, 0, labelSize.width, labelSize.height); [superView addSubview:label]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [label removeFromSuperview]; &#125;);&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 系统自带分享]]></title>
    <url>%2F2019%2F05%2F22%2FiOS%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[注意：国行手机无法使用系统自带的facebook分享，国行手机facebook被阉割导致分享失败。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#x2F;*** 分享* 多图分享，items里面直接放图片* 分享链接* NSString *textToShare &#x3D; @&quot;mq分享&quot;;* UIImage *imageToShare &#x3D; [UIImage imageNamed:@&quot;imageName&quot;];* NSURL *urlToShare &#x3D; [NSURL URLWithString:@&quot;https:www.baidu.com&quot;];* NSArray *items &#x3D; @[urlToShare,textToShare,imageToShare];*&#x2F;- (void)yoShare:(NSArray *)items success:(ShareSuccessBlock)successBlock fail:(ShareFailBlock)failBlock&#123; if (0 &#x3D;&#x3D; items.count) &#123; return; &#125; UIActivityViewController *activityVC &#x3D; [[UIActivityViewController alloc] initWithActivityItems:items applicationActivities:nil]; if (@available(iOS 11.0, *)) &#123; &#x2F;&#x2F;UIActivityTypeMarkupAsPDF是在iOS 11.0 之后才有的 activityVC.excludedActivityTypes &#x3D; @[UIActivityTypeMessage, UIActivityTypeMail, UIActivityTypeOpenInIBooks, UIActivityTypeMarkupAsPDF]; &#125;else if (@available(iOS 9.0, *))&#123; &#x2F;&#x2F;UIActivityTypeOpenInIBooks是在iOS 9.0 之后才有的 activityVC.excludedActivityTypes &#x3D; @[UIActivityTypeMessage, UIActivityTypeMail, UIActivityTypeOpenInIBooks]; &#125;else&#123; activityVC.excludedActivityTypes &#x3D; @[UIActivityTypeMessage, UIActivityTypeMail]; &#125; activityVC.completionWithItemsHandler &#x3D; ^(UIActivityType _Nullable activityType, BOOL completed, NSArray * _Nullable returnedItems, NSError * _Nullable activityError) &#123; if (completed) &#123; if (successBlock) &#123; NSNumber *codeNum &#x3D; [NSNumber numberWithInteger:YoErrorCodeSuccess]; NSDictionary *result &#x3D; @&#123;RCODEKEY:codeNum, RMSGKEY:SuccessMsg, METHODKEY:SysShareMethod&#125;; successBlock(result); &#125; &#125;else&#123; if (failBlock) &#123; NSNumber *codeNum &#x3D; [NSNumber numberWithInteger:YoErrorCodeShareFail]; NSDictionary *result &#x3D; @&#123;RCODEKEY:codeNum, RMSGKEY:ShareFailMsg, METHODKEY:SysShareMethod&#125;; failBlock(result); &#125; &#125; &#125;; &#x2F;&#x2F;这儿一定要做iPhone与iPad的判断，因为这儿只有iPhone可以present，iPad需pop，所以这儿actVC.popoverPresentationController.sourceView &#x3D; self.view;在iPad下必须有，不然iPad会crash，self.view你可以换成任何view，你可以理解为弹出的窗需要找个依托。 UIViewController *vc &#x3D; [UIApplication sharedApplication].keyWindow.rootViewController; if (UI_USER_INTERFACE_IDIOM() &#x3D;&#x3D; UIUserInterfaceIdiomPad) &#123; activityVC.popoverPresentationController.sourceView &#x3D; vc.view; activityVC.popoverPresentationController.sourceRect &#x3D; CGRectMake([UIScreen mainScreen].bounds.size.width&#x2F;2, [UIScreen mainScreen].bounds.size.height, 0, 0); [vc presentViewController:activityVC animated:YES completion:nil]; &#125;else&#123; [vc presentViewController:activityVC animated:YES completion:nil]; &#125;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 应用商店评分StoreReview]]></title>
    <url>%2F2019%2F05%2F15%2FiOS%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E8%AF%84%E5%88%86StoreReview%2F</url>
    <content type="text"><![CDATA[应用中引导用户去进行应用评论常用的方法大概有以下几种： 使用deepLink；在app地址链接后边拼接上action=write-review可以直接跳转到App Store应用中对应的应用评价界面进行评价 使用SKStoreReviewController；在iOS 10.3之后，iOS提供了一种新的评价方式，可以不用跳转出应用在应用内就完成应用的星级评价 从这段说明里，我们看出官方给出的注意点： 该方法在iOS 10.3之后才可以使用，所以在使用时需要进行版本判断 该方法主要用于申请用户评分，但这个方法不一定会显示UI，也就是说即使调用了该方法也不一定会有评级弹窗显示，最终是否有显示主要由App Store的相关政策决定，所以这个方法不适用于任何来自按钮或者其他用户直接交互的操作 该方法在开发模式下可以弹出交互界面，但是不能进行进行信息提交；在TestFlight模式下，调用该方法不会有任何反应 同一用户在同一个应用内每年只能提交三次评论，超出次数之后调用该方法就不会有任何反应，但未找到官方文档说明 代码如下：导入头文件#import &lt;StoreKit/StoreKit.h&gt;12345678910111213141516+ (void)yoStoreReview&#123; if (@available(iOS 10.3, *)) &#123; if ([SKStoreReviewController respondsToSelector:@selector(requestReview)])&#123; &#x2F;&#x2F;防止键盘遮挡 [[UIApplication sharedApplication].keyWindow endEditing:YES]; &#x2F;&#x2F; iOS10.3+ 直接在App内弹出评分框 &#x2F;&#x2F; 此方式苹果允许的调用频率为3次&#x2F;年 [SKStoreReviewController requestReview]; &#125; &#125; else &#123; &#x2F;&#x2F; &lt;iOS10.3 跳转AppStore的评论页面 NSString *appIDStr &#x3D; [NSString stringWithFormat:@&quot;%@&quot;, [YostarUtilits getUserDefaultsForKey:@&quot;APPLEID&quot;]]; NSString *appStoreReviewStr &#x3D; [NSString stringWithFormat:@&quot;https:&#x2F;&#x2F;itunes.apple.com&#x2F;app&#x2F;id%@?action&#x3D;write-review&quot;, appIDStr]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:appStoreReviewStr]]; &#125;&#125;附：[官方文档] requestReview]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS KVC]]></title>
    <url>%2F2019%2F05%2F10%2FiOSKVC%2F</url>
    <content type="text"><![CDATA[1. KVC简介 键/值编码中的基本调用是-valueForKey:和-setValue:forKey:方法12345NSString *name &#x3D; [car valueForKey:@&quot;name&quot;];valueForKey:会首先查找以参数名命名(格式为_name或_isName)的getter方法如果没有这样的getter方法，它将会在对象内寻找名称格式为_name或name的实例变量另外KVC会自动装箱和开箱标量值，也就是说，当使用-setValue:forKey:，它自动将标量值(int、float和struct)放入NSNumber或NSValue中；当时用-valueForKey:时，它自动将标量值从这些对象中取出，仅KVC具有这种自动装箱功能，常规方法调用和属性语法不具备该功能 2. KVC键路径 键路径的基本调用是-valueForKeyPath:和-setValue:forKeyPath:方法12[car setValue:[NSNumber numberWithInt:155] forKeyPath:@&quot;engine.horsepower&quot;];NSLog(@&quot;horsepower is %@&quot;, [car valueForKeyPath:@&quot;engine.horsepower&quot;]); 3. KVC快速运算 键路径不仅能引用对象值，还可以引用一些运算符来进行一些运算，例如能获取一组值的平均值或返回这组值中的最小值和最大值12345[garage valueForKeyPath:@&quot;cars.@count&quot;];[garage valueForKeyPath:@&quot;cars.@sum.mileage&quot;];[garage valueForKeyPath:@&quot;cars.@avg.mileage&quot;];[garage valueForKeyPath:@&quot;cars.@min.mileage&quot;];[garage valueForKeyPath:@&quot;cars.@max.mileage&quot;]; 4. setter和getter方法命名规则 setter方法根据它所更改的属性名称来命名，并加上前缀set，如：setName: 、setEngine: 等 getter方法则是以其返回的属性名称命名，如：name、engine等，不要将get用作getter方法的前缀 补充知识：get这个词在Cocoa中有着特殊的含义，如果get出现在Cocoa的方法名称中，就意味着这个方法会将你传递的参教作为指针来返回数值。例如，NSData中有一个getBytes:方法，它的参数就是用来存储字节的内存缓冲区的地址。如果你在存取方法的名称中使用了get，那么有经验的Cocoa编程人员就会习惯性地将指针当做参数传入这个方法，当他们发现这不过是一个简单的存取方法时就会感到困惑 5. setValue和setObject的区别 setObject:ForKey: 是NSMutableDictionary特有的；setValue:ForKey:是KVC的主要方法 总结两者的区别： setObject: forkey:中object是不能够为nil setValue: forKey:中value能够为nil，但是当value为nil的时候，会自动调用removeObject: forKey:方法 setValue: forKey:中key的参数只能够是NSString类型 setObject: forKey:的key可以是任何类型 注意：setObject: forKey:对象不能存放nil要与下面的这种情况区分：[imageDictionary setObject:[NSNullnull] forKey:indexNumber];[NSNull null]表示的是一个空对象，并不是nil 当setValue: forKey:方法调用者是对象的时候, setValue: forKey:方法是在NSObject对象中创建的，也就是说所有的OC对象都有这个方法，所以可以用于任何类 6. 正确比较字符串 比较字符串是否相等，应该使用isEqualToString:，而不能仅仅比较字符串的指针值；==运算符只判断两个字符串的指针数值，而不是它们所指的对象]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS APNS device token特性]]></title>
    <url>%2F2019%2F05%2F09%2FiOSAPNSdevicetoken%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[device token的一些特性： 开发环境获取的deviceToken和发布环境获取的deviceToken是不一样的 在一台设备中，deviceToken是系统级别的，不同App获得的deviceToken是相同的 deviceToken会过期 单个App的更新deviceToken不会发生改变 当进行备份恢复、或恢复出厂设置之类的操作时，deviceToken会发生改变，建议App在每次启动时都获取deviceToken 用户抹除iPhone的数据时，为了保护隐私，deviceToken会改变 升级系统deviceToken有可能变化，猜测是升级大的系统版本后deviceToken会变化 在删除手机上的App之后，再次下载安装，deviceToken在部分系统上会改变 注意： 推送相关证书只用在推送的后台即服务端使用，工程中只需打开推送相关开关即可，不需要推送证书 device token在iOS 13的变化 在iOS 13之前的版本中，大部分这样处理1234567- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; NSString *dt &#x3D; [deviceToken description]; dt &#x3D; [dt stringByReplacingOccurrencesOfString: @&quot;&lt;&quot; withString: @&quot;&quot;]; dt &#x3D; [dt stringByReplacingOccurrencesOfString: @&quot;&gt;&quot; withString: @&quot;&quot;]; dt &#x3D; [dt stringByReplacingOccurrencesOfString: @&quot; &quot; withString: @&quot;&quot;]; NSLog(@&quot;**发送给服务器的token字符串***:%@\n&quot;, dt);&#125; 在iOS 13之后的版本中，必须用以下方法处理（该方法在iOS 13之前也兼容）123456789- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; NSMutableString *deviceTokenString &#x3D; [NSMutableString string]; const char *bytes &#x3D; (const char *)deviceToken.bytes; NSInteger count &#x3D; deviceToken.length; for (int i &#x3D; 0; i &lt; count; i++) &#123; [deviceTokenString appendFormat:@&quot;%02x&quot;, bytes[i]&amp;0x000000FF]; &#125; NSLog(@&quot;**发送给服务器的token字符串***:%@\n&quot;, deviceTokenString);&#125; 或者123456789- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; if (![deviceToken isKindOfClass:[NSData class]]) return; const unsigned *tokenBytes &#x3D; (const unsigned *)[deviceToken bytes]; NSString *hexToken &#x3D; [NSString stringWithFormat:@&quot;%08x%08x%08x%08x%08x%08x%08x%08x&quot;, ntohl(tokenBytes[0]), ntohl(tokenBytes[1]), ntohl(tokenBytes[2]), ntohl(tokenBytes[3]), ntohl(tokenBytes[4]), ntohl(tokenBytes[5]), ntohl(tokenBytes[6]), ntohl(tokenBytes[7])]; NSLog(@&quot;**发送给服务器的token字符串***:%@\n&quot;,hexToken);&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 接入Twitter 相关注意点]]></title>
    <url>%2F2019%2F04%2F23%2FiOS%E6%8E%A5%E5%85%A5Twitter%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[1. 接入前配置 Download and unzip Twitter Kit Add TwitterKit to “Embedded Binaries” in your Xcode project settings(测试发现不添加也可以) Add TwitterKit and TwitterCore to “Linked Frameworks and Libraries” in your Xcode project settings Add SafariServices.framework to use SFSafariViewController In your app’s Info.plist, add URL Schemes by adding code below after1234567891011121314&lt;key&gt;CFBundleURLTypes&lt;&#x2F;key&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleURLSchemes&lt;&#x2F;key&gt; &lt;array&gt; &lt;string&gt;twitterkit-&lt;consumerKey&gt;&lt;&#x2F;string&gt; &lt;&#x2F;array&gt; &lt;&#x2F;dict&gt;&lt;&#x2F;array&gt;&lt;key&gt;LSApplicationQueriesSchemes&lt;&#x2F;key&gt;&lt;array&gt; &lt;string&gt;twitter&lt;&#x2F;string&gt; &lt;string&gt;twitterauth&lt;&#x2F;string&gt;&lt;&#x2F;array&gt; Make sure to import the framework header: #import &lt;TwitterKit/TWTRKit.h&gt;123- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [[Twitter sharedInstance] startWithConsumerKey:@&quot;hTpkPVU4pThkM0&quot; consumerSecret:@&quot;ovEqziMzLpUOF163Qg2mj&quot;];&#125; Implement the application:openURL:options method in your Application Delegate, and pass along the redirect URL to Twitter Kit123- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options &#123; return [[Twitter sharedInstance] application:app openURL:url options:options];&#125; 2. Twitter后台配置 https://apps.twitter.com/app From June 12th 2018 callback locking will no longer be optional. The correct callback format for iOS apps is:twitterkit-MY_CONSUMER_KEY:// 3. 接入相关功能 Log In Button123456789TWTRLogInButton *logInButton &#x3D; [TWTRLogInButton buttonWithLogInCompletion:^(TWTRSession *session, NSError *error) &#123; if (session) &#123; NSLog(@&quot;signed in as %@&quot;, [session userName]); &#125; else &#123; NSLog(@&quot;error: %@&quot;, [error localizedDescription]); &#125;&#125;];logInButton.center &#x3D; self.view.center;[self.view addSubview:logInButton]; Log In Method1234567[[Twitter sharedInstance] logInWithCompletion:^(TWTRSession *session, NSError *error) &#123; if (session) &#123; NSLog(@&quot;signed in as %@&quot;, [session userName]); &#125; else &#123; NSLog(@&quot;error: %@&quot;, [error localizedDescription]); &#125;&#125;]; Request User Email Address12345678TWTRAPIClient *client &#x3D; [TWTRAPIClient clientWithCurrentUser];[client requestEmailForCurrentUser:^(NSString *email, NSError *error) &#123; if (email) &#123; NSLog(@&quot;signed in as %@&quot;, email); &#125; else &#123; NSLog(@&quot;error: %@&quot;, [error localizedDescription]); &#125;&#125;];]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS runtime 相关实例]]></title>
    <url>%2F2019%2F04%2F19%2FiOSruntime%E7%9B%B8%E5%85%B3%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[避免按钮快速点击多次相应问题 创建UIButton 分类 123456789101112&#x2F;&#x2F;&#x2F;&#x2F; UIButton+time.h&#x2F;&#x2F;#import &lt;UIKit&#x2F;UIKit.h&gt;@interface UIButton (time)&#x2F;* 防止button重复点击，设置间隔 *&#x2F;@property (nonatomic, assign) NSTimeInterval acceptEventInterval;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&#x2F;&#x2F;&#x2F;&#x2F; UIButton+time.m&#x2F;&#x2F;#import &quot;UIButton+time.h&quot;#import &lt;objc&#x2F;runtime.h&gt;@implementation UIButton (time)static const char *UIButton_acceptEventInterval &#x3D; &quot;UIButton_acceptEventInterval&quot;;static const char *UIButton_acceptEventTime &#x3D; &quot;UIButton_acceptEventTime&quot;;&#x2F;&#x2F; get方法 获取时间间隔- (NSTimeInterval)acceptEventInterval&#123; return [objc_getAssociatedObject(self, UIButton_acceptEventInterval) doubleValue];&#125;&#x2F;&#x2F; set方法 赋值时间间隔- (void)setAcceptEventInterval:(NSTimeInterval)mm_acceptEventInterval&#123; objc_setAssociatedObject(self, UIButton_acceptEventInterval, @(mm_acceptEventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;&#x2F;&#x2F; get方法 获取时间- (NSTimeInterval)acceptEventTime&#123; return [objc_getAssociatedObject(self, UIButton_acceptEventTime) doubleValue];&#125;&#x2F;&#x2F; set方法 赋值时间- (void)setAcceptEventTime:(NSTimeInterval)mm_acceptEventTime&#123; objc_setAssociatedObject(self, UIButton_acceptEventTime, @(mm_acceptEventTime), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;&#x2F;**class_addMethod:如果发现方法已经存在，会失败返回，也可以用来做检查用,我们这里是为了避免源方法没有实现的情况;如果方法没有存在,我们则先尝试添加被替换的方法的实现1.如果返回成功:则说明被替换方法没有存在.也就是被替换的方法没有被实现,我们需要先把这个方法实现,然后再执行我们想要的效果,用我们自定义的方法去替换被替换的方法. 这里使用到的是&#39;class_replaceMethod&#39;这个方法. class_replaceMethod本身会尝试调用class_addMethod和method_setImplementation，所以直接调用class_replaceMethod就可以了)2.如果返回失败:则说明被替换方法已经存在.直接将两个方法的实现交换即*&#x2F;&#x2F;&#x2F;分类中重写load方法，实现方法的交换（只要能让其执行一次方法交换语句，load再合适不过了）+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; &#x2F;&#x2F;获取这两个方法 Method systemMethod &#x3D; class_getInstanceMethod(self, @selector(sendAction:to:forEvent:)); SEL sysSEL &#x3D; @selector(sendAction:to:forEvent:); Method myMethod &#x3D; class_getInstanceMethod(self, @selector(mm_sendAction:to:forEvent:)); SEL mySEL &#x3D; @selector(mm_sendAction:to:forEvent:); &#x2F;&#x2F;添加方法进去 BOOL isAddMethod &#x3D; class_addMethod(self, sysSEL, method_getImplementation(myMethod), method_getTypeEncoding(myMethod)); &#x2F;&#x2F;如果添加方法成功 if (isAddMethod) &#123; class_replaceMethod(self, mySEL, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod)); &#125;else&#123; method_exchangeImplementations(systemMethod, myMethod); &#125; &#125;); &#x2F;*-----以上主要是实现两个方法的互换,load是gcd的只shareinstance，果断保证执行一次-------*&#x2F;&#125;- (void)mm_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event&#123; if ([NSDate date].timeIntervalSince1970 - self.acceptEventTime &lt; self.acceptEventInterval) &#123; return; &#125; if (self.acceptEventInterval &gt; 0) &#123; self.acceptEventTime &#x3D; [NSDate date].timeIntervalSince1970; &#125; [self mm_sendAction:action to:target forEvent:event];&#125;@end]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++传递字符串给c#使用问题]]></title>
    <url>%2F2019%2F04%2F18%2FC%E4%BC%A0%E9%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[C++里，字符串要占用内存的。C++创建字符串，并传给C#，就会造成内存泄露（因为C#不知道C++如何创建，也就不知道如何销毁）。因此，通常的做法（甚至是C++互相调用的惯例），是 调用者（这里是C#）准备好一段内存缓冲区（这里是StringBuilder）； 被调用者C++把字符串内容，填充到指定缓冲区去； 调用者从缓冲区能得到结果，也知道如何清理缓冲（C#自己会用垃圾回收），没有内存泄露问题。]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS和Unity交互之参数传递]]></title>
    <url>%2F2019%2F03%2F07%2FiOS%E5%92%8CUnity%E4%BA%A4%E4%BA%92%E4%B9%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[1. 调用方法一 Unity调方法传参,有返回值1234&#x2F;&#x2F; Unity代码[DllImport(&quot;__Internal&quot;)]&#x2F;&#x2F; 给iOS传string参数,有返回值,返回值通过iOS的return方法返回给Unityprivate static extern string getIPv6(string mHost, string mPort) 1234567891011121314151617&#x2F;&#x2F; iOS代码extern &quot;C&quot; const char * getIPv6(const char *mHost, const char *mPort)&#123; &#x2F;&#x2F; strdup(const char *__s1) 复制mHost字符串,通过Malloc()进行空间分配 &#x2F;&#x2F; return strdup(mHost); return makeStringCopy(mHost);&#125;char* makeStringCopy(const char* string)&#123; if (NULL &#x3D;&#x3D; string) &#123; return NULL; &#125; char* res &#x3D; (char*)malloc(strlen(string)+1); strcpy(res, string); return res;&#125; 如果Unity传参为string类型,不执行strdup()方法而直接使用return方法,导致mHost没有分配内存空间而报错 这里的const char* 会被C#自动转换成string因为在.m文件中使用了内存申请，该段内存自然是处在堆内存中，这样转成string符合c#的内存管理机制，我们不用担心它的释放问题 如果Unity传参为int等基础数据类型,可以直接使用return方法 调用DllImport(“”)方法,需要引入命名空间:using System.Runtime.InteropServices 2. 调用方法二 Unity调方法传参,无返回值12345678910&#x2F;&#x2F; Unity代码&#x2F;&#x2F; 传数据给iOS[DllImport(&quot;__Internal&quot;)]&#x2F;&#x2F; 给iOS传string参数,无返回值,返回值通过iOS的UnitySendMessage方法返回给Unityprivate static extern void setDate(string date);&#x2F;&#x2F; 接收iOS的数据public void GetDate(string date)&#123;&#125; 123456789101112&#x2F;&#x2F; iOS代码extern &quot;C&quot; void setDate(const char *date)&#123; &#x2F;** 发送数据给Unity @param obj 模型名 @param method Unity接收iOS数据的方法名 @param msg 传给Unity的数据 UnitySendMessage(const char* obj, const char* method, const char* msg); *&#x2F; UnitySendMessage(&quot;PublicGameObject&quot;, &quot;GetDate&quot;, date);&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS iPhone X适配HomeIndicator相关实践]]></title>
    <url>%2F2019%2F03%2F06%2FiOSiPhoneX%E9%80%82%E9%85%8DHomeIndicator%E7%9B%B8%E5%85%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[1. 隐藏HomeIndicator一般情况只有视频全屏播放和游戏界面需要设置自动隐藏Home键指示器，隐藏HomeIndicator的方法，如下，123- (BOOL)prefersHomeIndicatorAutoHidden &#123; return YES;&#125;在VC 里边重写 prefersHomeIndicatorAutoHidden 返回 YES(默认是NO)，Home指示条就能自动隐藏了，此方法是在控制器push之后就会回调，屏幕若无交互事件响应时，延迟2秒左右会自动隐藏。经过测试发现，只要触摸页面就会重新出现，不操作页面一会儿会自动消失。主要适用于视频类等长时间不对页面做出交互的应用使用。 2. 屏幕边缘手势冲突有时候你的App需要控制从状态栏下拉或者底部栏上滑，这个会跟系统的下拉通知中心手势和上滑控制中心手势冲突。如果你要优先自己处理手势可以将系统手势延迟。方法如下：123- (UIRectEdge)preferredScreenEdgesDeferringSystemGestures&#123; return UIRectEdgeAll;&#125;然后其他地方不要修改(比如prefersHomeIndicatorAutoHidden)；就可以像王者荣耀那样,一直显示白条,但是点击一次不会到桌面,也不会到多任务]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Xcode 添加调试真机设备和模拟器]]></title>
    <url>%2F2019%2F03%2F05%2FiOSXcode9%E8%B0%83%E8%AF%95iOS7.0%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[高版本Xcode调试低版本真机设备 前往文件夹或者找到Xcode安装包右键显示包内容查找路径1&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneOS.platform&#x2F;DeviceSupport 最新的Xcode默认是没有7.0和7.1文件夹，我们可以从Xcode 7的DeviceSupport文件夹下拷贝出来，然后复制进去 前往文件夹或者找到Xcode安装包右键显示包内容查找路径1&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneOS.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneOS.sdk&#x2F;SDKSettings.plist 查找到SDKSettings.plist文件，在DEPLOYMENT_TARGET_SUGGESTED_VALUES字段下面添加7.0和7.1，如果第一步添加了更老的版本，这里也一起添加了 如果是Xcode 8以下的版本调试适配iOS 10，方法是一样的，只不过需要在高版本的Xcode里面把配置文件拷贝出来 如果SDKSettings.plist这个文件提示无法修改的话，可以先将这个文件拷贝一份到桌面，修改后再覆盖进去即可 Xcode添加模拟器 首先打开Xcode，找到Add Additional Simulators点击 点击+号选择Add Simulator 这里选择你需要的模拟器Type和Version后点击Create就可以了]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 模态跳转推出透明背景方法]]></title>
    <url>%2F2019%2F03%2F04%2FiOS%E6%A8%A1%E6%80%81%E8%B7%B3%E8%BD%AC%E6%8E%A8%E5%87%BA%E9%80%8F%E6%98%8E%E8%83%8C%E6%99%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. OS &gt;= iOS 8.0123FZLoginViewController *fzLoginViewController &#x3D; [[FZLoginViewController alloc] init];fzLoginViewController.modalPresentationStyle &#x3D; UIModalPresentationOverCurrentContext;[[UIApplication sharedApplication].keyWindow.rootViewController presentViewController:fzLoginViewController animated:NO completion:nil];2. 若系统需兼容7.0 需要加处理12345678if ([[UIDevice currentDevice].systemVersion floatValue] &gt;&#x3D; 8.0) &#123; controller.modalPresentationStyle &#x3D; UIModalPresentationOverCurrentContext; [self presentViewController:controller animated:YES completion:nil];&#125; else &#123; self.view.window.rootViewController.modalPresentationStyle &#x3D; UIModalPresentationCurrentContext; [self presentViewController:controller animated:NO completion:nil]; self.view.window.rootViewController.modalPresentationStyle &#x3D; UIModalPresentationFullScreen;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 静态库开发]]></title>
    <url>%2F2019%2F03%2F01%2FiOS%E9%9D%99%E6%80%81%E5%BA%93%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[本文旨在说明静态库制作中的一些常见问题和特殊处理1. 打包静态库需要的相关问题和设置 静态库中用到分类的需要在项目中设置这个参数：Other Linker Flags为-ObjC或者-all_load 静态库中用到了NSClassFromString或者runtime的objc_getClass，但是转换出来的Class 一直为nil。解决方法：在主工程的Other Linker Flags需要添加参数-ObjC即可 如果Xcode找不到框架的头文件，可能是忘记将它们声明为public了 Base SDK指的是当前编译所用的SDK 版本，一般默认为当前xocde的最新版 Build Active Architecture Only设置成No Deployment Target它控制着运行应用需要的最低操作系统版本 Skip Install设置为Yes Mach-O Type静态库设置为Static Library，动态库设置为Dynamic Library，制作bundle文件设置为Bundle 静态库中最好不要用xib，要用的话就将xib放到bundle文件中编译，然后xib就会变成.nib的文件 如果开发的静态库里面有C或者C++，在使用的时候需要添加libc++.tbd或者libstdc++.tbd 关于C语言中Implicit declaration of function ‘XXXX’ is invalid in C99警告：C语言是过程化的编程语言，程序执行顺序是从上到下。如果在调用某函数的时候，函数在调用之前没有定义也没有声明，而是在调用之后定义，那么编译时Implicit declaration of function ‘XXXX’ is invalid in C99警告就产生了。这是有别于面向对象编程语言的地方 2. framework中Optional和Required的区别 Required：强引用，一定会被加载到内存中，即使不使用也会被加载到内存中 Optional：弱引用，开始并不会加载，在使用的时候才会加载，会节省加载时的时间。有一些库，如Social.framework和AdSupport.framework，是在iOS 6之后才被引入的，更新了一些新的特性，如果运行在5.0甚至更低的设备上，这些库不支持，会编译通不过，这时候就要使用弱引用了 当你遇到了dyld:Library not found ……说明你可能使用了不该有的强引用，根据日志将这个库的引用形式修改一下；或者是使用了动态库，就需要在Embeded Binaries选项中添加这个动态库 3. 如何看一个framework中的二进制文件是静态库还是动态库 使用file命令，如：$ file /Users/yostar/Desktop/ProjectTest/YostarSDK/ThirdPath/TwitterKit.framework/TwitterKit；见下面的截图，一个是静态库，一个是动态库 4. 查看静态库是否支持bitcode$ otool -l /Users/yostar/Desktop/UnityLib/libYostarSDK.a | grep __LLVM如果上述命令的输出结果有__LLVM，那么就说明，所用的framework或.a支持设置Enable bitcode为YES，否则不支持 5. 静态库相关操作 查看一个库文件支持的指令集：12$ lipo -info .&#x2F;XXXX.a$ lipo -info .&#x2F;XXXX.framework&#x2F;XXXX 合成指令集：12$ lipo -create XXXX_iphoneos.a XXXX_iphonesimulator.a -output XXXX_all.a$ lipo -create XXXX_iphoneos.framework&#x2F;XXXX_iphoneos XXXX_iphonesimulator.framework&#x2F;XXXX_iphonesimulator -output XXXX_all 拆分特定指令集：12$ lipo -thin libname.a armv7(CPU架构名称) -output libname-armv7.a$ lipo -thin XXXX.framework&#x2F;XXXX arm64 -output XXXX.framework&#x2F;XXXX-arm64 注意framework和.a处理不同，.a可以直接使用，framework需要做替换处理；framework合并或者拆分完成后，再把输出的文件替换上面simulator文件夹或者iphoneos对应目录下的framework文件 6. 打包framework之嵌套另一静态库产生类文件重复问题将打包好的framework和第三方静态库引入项目，运行，产生两个静态库文件类名重复的问题。如下： 这就说明在封装framework时将第三方静态库中的文件给引入了，从而造成两个库中有多个相同类名文件。 这样编译生成的framework就不会和引入的静态库有相同的类文件了 7. 打包 C,C++文件及和OC混编，接口代码 静态库打包C代码xcode新建文件YostarUtilits.h和YostarUtilits.m，例子如下：1234567#import &lt;Foundation&#x2F;Foundation.h&gt;const char * getIDFA();@interface YostarUtilits : NSObject@end 12345678910111213141516#import &quot;YostarUtilits.h&quot;const char * getIDFA()&#123; NSString *str &#x3D; @&quot;123&quot;; const char *strC &#x3D; [IDFAStr UTF8String]; char *result &#x3D; (char *)calloc(10, sizeof(char *)); if (result) &#123; strcpy(result, strC); &#125; return result;&#125;@implementation YostarUtilits@end 静态类库打包C++代码xcode新建文件YostarUtilits.h和YostarUtilits.mm，例子如下：12345#import &lt;Foundation&#x2F;Foundation.h&gt;@interface YostarUtilits : NSObject@end 12345678910111213141516171819202122232425#import &quot;YostarUtilits.h&quot;#if defined(__cplusplus)extern &quot;C&quot;&#123;#endifconst char * getIDFA()&#123; NSString *str &#x3D; @&quot;123&quot;; const char *strC &#x3D; [IDFAStr UTF8String]; char *result &#x3D; (char *)calloc(10, sizeof(char *)); if (result) &#123; strcpy(result, strC); &#125; return result;&#125; #if defined(__cplusplus)&#125;#endif@implementation YostarUtilits@end]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tableViewCell相关设置]]></title>
    <url>%2F2019%2F02%2F28%2FiOStableViewCell%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 去掉底部多余的表格线1[tableView setTableFooterView:[[UIView alloc] initWithFrame:CGRectZero]];2. 在自定义tableViewCell中设置分割线 顶头显示 self代表cell1234567891011if ([self respondsToSelector:@selector(setSeparatorInset:)]) &#123; [self setSeparatorInset:UIEdgeInsetsZero];&#125;if ([self respondsToSelector:@selector(setLayoutMargins:)]) &#123; [self setLayoutMargins:UIEdgeInsetsZero];&#125;if([self respondsToSelector:@selector(setPreservesSuperviewLayoutMargins:)])&#123; [self setPreservesSuperviewLayoutMargins:NO];&#125;3. 代码布局tableview改变cell间隙布局，重写UITableViewCell的frame方法1234567- (void)setFrame:(CGRect)frame&#123; frame.origin.x +&#x3D; 5; frame.origin.y +&#x3D; 5; frame.size.height -&#x3D; 5; frame.size.width -&#x3D; 10; [super setFrame:frame];&#125;4. 动态计算tableviewCell高度12345678910111213&#x2F;&#x2F; 获取最底部view 的bottom值&#x2F;&#x2F; NSArray *views &#x3D; [self.contentView.subviews sortedArrayUsingComparator:^NSComparisonResult(UIView *view1, UIView *view2) &#123; &#x2F;&#x2F; NSString *top1 &#x3D; [NSString stringWithFormat:@&quot;%f&quot;, view1.frame.origin.y]; &#x2F;&#x2F; NSString *top2 &#x3D; [NSString stringWithFormat:@&quot;%f&quot;, view2.frame.origin.y]; &#x2F;&#x2F; NSComparisonResult result &#x3D; [top1 compare:top2 options:NSNumericSearch]; &#x2F;&#x2F; NSLog(@&quot;^^^：：%ld&quot;, (long)result); &#x2F;&#x2F; &#x2F;&#x2F; return result &#x3D;&#x3D; NSOrderedDescending; &#x2F;&#x2F; &#125;];NSArray *views &#x3D; self.contentView.subviews;UIView * bottomView &#x3D; views.firstObject;CGFloat height &#x3D; bottomView.frame.origin.y+bottomView.frame.size.height;_model.cellHeight &#x3D; height + 10;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 获取屏幕最上层window以及响应者]]></title>
    <url>%2F2019%2F02%2F27%2FiOS%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E6%9C%80%E4%B8%8A%E5%B1%82window%E4%BB%A5%E5%8F%8A%E5%93%8D%E5%BA%94%E8%80%85%2F</url>
    <content type="text"><![CDATA[1. 通过UIApplication获取123UIWindow *window &#x3D; [UIApplication sharedApplication].keyWindow;或者UIWindow *window &#x3D; [[UIApplication sharedApplication].windows lastObject];2. 比较严谨的获取方法：123456789- (UIWindow *)lastWindow&#123; NSArray *windows &#x3D; [UIApplication sharedApplication].windows; for (UIWindow *window in [windows reverseObjectEnumerator]) &#123; if ([window isKindOfClass:[UIWindow class]] &amp;&amp; CGRectEqualToRect(window.bounds, [UIScreen mainScreen].bounds)) &#123; return window; &#125; &#125; return [UIApplication sharedApplication].keyWindow;&#125;3. 查找响应者1234567891011&#x2F;&#x2F; 新建一个UIView的类目，把这个方法放进去，以后就可以直接通过view.findResponderViewController来获取视图的控制器了。- (UIViewController *)findResponderViewController&#123; UIResponder *next &#x3D; self.nextResponder; do &#123; if ([next isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)next; &#125; next &#x3D; next.nextResponder; &#125; while (next !&#x3D; nil); return nil;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git SourceTree配置]]></title>
    <url>%2F2019%2F02%2F26%2FGitSourceTree%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[创建SSH Key，因为本地的Git仓库与Github远程仓库之间是通过SSH加密的。首先，需要到主目录上查看是否有.ssh目录，再查看.ssh目录下有没有id_rsa和id_rsa.pub文件，如下 发现没有上述的两个文件，这时需要创建：1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 出现上述描述，就证明你成功了，然后到主目录下找到.ssh目录，查看id_rsa和id_rsa.pub文件，id_rsa是私钥，需要自己保留好，id_rsa.pub是公钥，别人知道也无妨。登录Github账户，打开Account settings，SSH Keys页面,添加id_rsa.pub文件的内容。]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 面试题汇总]]></title>
    <url>%2F2019%2F02%2F25%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. 简单介绍下NSURLConnection类及+ sendSynchronousRequest:returningResponse:error:与– initWithRequest:delegate:两个方法的区别? 答: NSURLConnection主要用于网络访问，其中+ sendSynchronousRequest:returningResponse:error:是同步访问数据，即当前线程会阻塞，并等待request的返回的response，而– initWithRequest:delegate:使用的是异步加载，当其完成网络访问后，会通过delegate回到主线程，并其委托的对象。 2. 在项目什么时候选择使用GCD，什么时候选择NSOperation 答: 项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。 3. ViewController的didReceiveMemoryWarning怎么被调用 答:[supper didReceiveMemoryWarning]; 4. 写一个setter方法用于完成@property(nonatomic, retain) NSString *name,写一个setter方法用于完成@property(nonatomic, copy) NSString *name12345678910- (void)setName:(NSString *)str&#123; [str retain]; [_name release]; _name &#x3D; str;&#125;- (void)setName:(NSString *)str&#123; id t &#x3D; [str copy]; [_name release]; _name &#x3D; t;&#125;5. 对于语句NSString *obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象? 答： 编译时是NSString的类型;运行时是NSData类型的对象 6. Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么? 答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone: 7. 浅复制和深复制的区别? 答：浅层复制：只复制指向对象的指针，而不复制引用对象本身。深层复制：复制引用对象本身。 8. PerformSelecter 当调用 NSObject 的performSelecter:afterDelay:后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用performSelector:onThread:时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 9. 优化你是从哪几方面着手？ 一、首页启动速度 启动过程中做的事情越少越好（尽可能将多个接口合并） 不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新节目）在合适的时机开始后台任务（例如在用户指引节目就可以开始准备加载的数据）二、页面浏览速度json的处理（iOS 自带的NSJSONSerialization，Jsonkit，SBJson）数据的分页（后端数据多的话，就要分页返回，例如网易新闻，或者 微博记录）数据压缩（大数据也可以压缩返回，减少流量，加快反应速度）内容缓存（例如网易新闻的最新新闻列表都是要缓存到本地，从本地加载，可以缓存到内存，或者数据库，根据情况而定）延时加载tab（比如app有5个tab，可以先加载第一个要显示的tab，其他的在显示时候加载，按需加载）算法的优化（核心算法的优化，例如有些app 有个 联系人姓名用汉语拼音的首字母排序）三、操作流畅度优化Tableview 优化（tableview cell的加载优化）ViewController加载优化（不同view之间的跳转，可以提前准备好数据）四、数据库的优化数据库设计上面的重构查询语句的优化分库分表（数据太多的时候，可以分不同的表或者库）五、服务器端和客户端的交互优化客户端尽量减少请求服务端尽量做多的逻辑处理服务器端和客户端采取推拉结合的方式（可以利用一些同步机制）通信协议的优化（减少报文的大小）电量使用优化（尽量不要使用后台运行）六、非技术性能优化产品设计的逻辑性（产品的设计一定要符合逻辑，或者逻辑尽量简单，否则会让程序员抓狂，有时候用了好大力气，才可以完成一个小小的逻辑设计问题）界面交互的规范（每个模块的界面的交互尽量统一，符合操作习惯）代码规范（这个可以隐形带来app 性能的提高，比如 用if else 还是switch ，或者是用！还是 ＝＝）code review（坚持code Review 持续重构代码。减少代码的逻辑复杂度） 10. 什么情况使用 weak 关键字，相比 assign 有什么不同？ 1.在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,如自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。IBOutlet连出来的视图属性为什么可以被设置成weak?答：因为父控件的subViews数组已经对它有一个强引用。不同点assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil) 11. 用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？ 答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。1.因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。2.如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。 12. runtime如何实现weak变量的自动置nil？ runtime对注册的类，会进行布局，会将 weak 对象放入一个 hash 表中。用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会调用对象的 dealloc 方法，假设 weak 指向的对象内存地址是a，那么就会以a为key，在这个 weak hash表中搜索，找到所有以a为key的 weak 对象，从而设置为nil 13. runloop是什么／runloop的概念？ runloop是线程相关的基础框架的一部分。一个runloop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其实内部就是do－while循环，这个循环内部不断地处理各种任务（比如Source，Timer，Observer）。使用runloop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。 14. UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？ 这是否刷新取决于timer加入到Run Loop中的Mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为 NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态 UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode UIInitializationRunLoopMode：run loop启动时，会切换到该mode NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合苹果公开提供的Mode有两个 NSDefaultRunLoopMode（kCFRunLoopDefaultMode） NSRunLoopCommonModes（kCFRunLoopCommonModes）在编程中：如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用common mode。 15. NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer? 不准；不准的原因如下1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。方法：1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果-(void)timerMethod2 { NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil]; [thread start];}-(void)newThread{ @autoreleasepool{ [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] run]; }} 16. NSOperation 相比于 GCD 有哪些优势？ GCD是基于c的底层api，NSOperation属于object-c类。ios 首先引入的是NSOperation，IOS4之后引入了GCD和NSOperationQueue并且其内部是用gcd实现的。相对于GCD：1、NSOperation拥有更多的函数可用，具体查看api。2、在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。3、有kvo可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）。4、NSOperationQueue可以方便的管理并发、NSOperation之间的优先级。GCD主要与block结合使用。代码简洁高效。GCD也可以实现复杂的多线程应用，主要是建立个个线程时间的依赖关系这类的情况，但是需要自己实现相比NSOperation要复杂。具体使用哪个，依需求而定。 从个人使用的感觉来看，比较合适的用法是：除了依赖关系尽量使用GCD，因为苹果专门为GCD做了性能上面的优化。 17. 如何访问并修改一个类的私有属性? 有两种方法可以访问私有属性,一种是通过KVC获取,一种是通过runtime访问并修改私有属性。 18. 如何捕获异常？123456789101112131415161718192021222324251. 在app启动时(didFinishLaunchingWithOptions)，添加一个异常捕获的监听NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);2. 实现捕获异常日志并保存到本地的方法void UncaughtExceptionHandler(NSException *exception)&#123; &#x2F;&#x2F;异常日志获取 NSArray *excpArr &#x3D; [exception callStackSymbols]; NSString *reason &#x3D; [exception reason]; NSString *name &#x3D; [exception name]; NSString *excpCnt &#x3D; [NSString stringWithFormat:@&quot;exceptionType: %@ \n reason: %@ \n stackSymbols: %@&quot;,name,reason,excpArr]; &#x2F;&#x2F;日常日志保存（可以将此功能单独提炼到一个方法中） NSArray *dirArr &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *dirPath &#x3D; dirArr[0]; NSString *logDir &#x3D; [dirPath stringByAppendingString:@&quot;&#x2F;CrashLog&quot;]; BOOL isExistLogDir &#x3D; YES; NSFileManager *fileManager &#x3D; [NSFileManager defaultManager]; if (![fileManager fileExistsAtPath:logDir]) &#123; isExistLogDir &#x3D; [fileManager createDirectoryAtPath:logDir withIntermediateDirectories:YES attributes:nil error:nil]; &#125; if (isExistLogDir) &#123; &#x2F;&#x2F;此处可扩展 NSString *logPath &#x3D; [logDir stringByAppendingString:@&quot;&#x2F;crashLog.txt&quot;]; [excpCnt writeToFile:logPath atomically:YES encoding:NSUTF8StringEncoding error:nil]; &#125;&#125;19. Object-c的类可以多重继承么?可以实现多个接口么?Category是什么?重写一个类的方式用继承好还是分类好?为什么? 答：Object-c的类不可以多重继承;可以实现多个接口，通过实现多个接口可以完成C++的多重继承;Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。 20. Category(分类)，Extension(扩展)和继承的区别 答：1.分类category原则上只能在现有类基础上添加新的方法（能添加属性的原因只是通过runtime解决无setter/getter的问题而已），类别中的方法没被实现编译器是不会有任何警告的，这是因为类别是在运行时添加到类中的2.扩展iOS中的extension就是匿名的分类，只有头文件没有实现文件。类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（使用范围只能在自身类，而不是子类或其他地方），类扩展中声明的方法没被实现，编译器会报警，这是因为类扩展是在编译阶段被添加到类中的3.继承在iOS中继承是单继承，既只能有一个父类。在继承中，子类可以使用父类的方法和变量，当子类想对本类或者父类的变量进行初始化，那么需要重写init()方法 。父类也可以访问子类的方法和成员变量 21. 简述内存分区情况 1).代码区：存放函数二进制代码 2).数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量 3).堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放 4).栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数 22. 直接调用_objc_msgForward函数将会发生什么？ _objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。直接调用_objc_msgForward是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。一旦调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend：“我没有在这个对象里找到这个方法的实现” 23. 对于Run Loop的理解 RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的； 每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动； 在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop； NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式； 实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。 24. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法） 1.每一个类对象中都一个对象方法列表（对象方法缓存） 2.类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存） 3.方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现. 4.当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找 5.当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找 25. runtime 中，SEL 和 IMP 的区别 方法名 SEL – 表示该方法的名称； IMP – 指向该方法的具体实现的函数指针，说白了IMP就是实现方法。 26.block底层实现 block本质是指向一个结构体的一个指针运行时机制 比较高级的特性 纯C语言平时写的OC代码 转换成C语言运行时的代码指令:clang -rewrite-objc main.m(可以打印验证)默认情况下,任何block都是在栈里面的,随时可能被回收只要对其做一次copy操作 block的内存就会放在堆里面 不会释放只有copy才能产生一个新的内存地址 所有地址会发生改变 27. TCP协议三次握手 TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN(synchronize)和ACK(acknowledgement)。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 28. @property 的本质是什么？ @property = ivar + getter + setter;“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法） 29. KVC的底层实现？ 当一个对象调用setValue方法时，方法内部会做以下操作：1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。 30. ViewController生命周期 按照执行顺序排列：1). initWithCoder：通过nib文件初始化时触发。2). awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。3). loadView：开始加载视图控制器自带的view。4). viewDidLoad：视图控制器的view被加载完成。5). viewWillAppear：视图控制器的view将要显示在window上。6). updateViewConstraints：视图控制器的view开始更新AutoLayout约束。7). viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。8). viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。9). viewDidAppear：视图控制器的view已经展示到window上。10). viewWillDisappear：视图控制器的view将要从window上消失。11). viewDidDisappear：视图控制器的view已经从window上消失。 31. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）123456789101112&#x2F;&#x2F; 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。&#x2F;&#x2F; 创建队列组dispatch_group_t group &#x3D; dispatch_group_create();&#x2F;&#x2F; 获取全局并发队列dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_async(group, queue, ^&#123; &#x2F;*加载图片1 *&#x2F; &#125;);dispatch_group_async(group, queue, ^&#123; &#x2F;*加载图片2 *&#x2F; &#125;);dispatch_group_async(group, queue, ^&#123; &#x2F;*加载图片3 *&#x2F; &#125;); &#x2F;&#x2F; 当并发队列组中的任务执行完毕后才会执行这里的代码dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; &#x2F;&#x2F; 合并图片&#125;);32. dispatch_barrier_async（栅栏函数）的作用是什么？12345678910111213141516171819202122232425262728函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);作用： 1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。 2.避免数据竞争&#x2F;&#x2F; 1.创建并发队列dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);&#x2F;&#x2F; 2.向队列中添加任务dispatch_async(queue, ^&#123; &#x2F;&#x2F; 1.2是并行的 NSLog(@&quot;任务1, %@&quot;,[NSThread currentThread]);&#125;);dispatch_async(queue, ^&#123; NSLog(@&quot;任务2, %@&quot;,[NSThread currentThread]);&#125;);dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;任务 barrier, %@&quot;, [NSThread currentThread]);&#125;);dispatch_async(queue, ^&#123; &#x2F;&#x2F; 这两个是同时执行的 NSLog(@&quot;任务3, %@&quot;,[NSThread currentThread]);&#125;);dispatch_async(queue, ^&#123; NSLog(@&quot;任务4, %@&quot;,[NSThread currentThread]);&#125;);&#x2F;&#x2F; 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 &#x2F;&#x2F; 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 数组升序排列方法]]></title>
    <url>%2F2019%2F02%2F22%2FiOS%E6%95%B0%E7%BB%84%E5%8D%87%E5%BA%8F%E6%8E%92%E5%88%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1234567891011NSArray *orignalArr &#x3D; @[@&quot;3&quot;, @&quot;12&quot;, @&quot;4&quot;, @&quot;1&quot;, @&quot;4&quot;, @&quot;8&quot;];NSArray *resultArr &#x3D; [orignalArr sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) &#123; if ([obj1 integerValue] &gt; [obj2 integerValue]) &#123; return NSOrderedDescending; &#125;else if ([obj1 integerValue] &lt; [obj2 integerValue])&#123; return NSOrderedAscending; &#125;else&#123; return NSOrderedSame; &#125;&#125;];NSLog(@&quot;升序排列的数组:%@&quot;, resultArr);]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 证书转换相关命令]]></title>
    <url>%2F2019%2F02%2F21%2FiOS%E8%AF%81%E4%B9%A6%E8%BD%AC%E6%8D%A2%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[证书有效期：1openssl x509 -in xxx.pem -noout -dates生成pem格式的证书：1openssl pkcs12 -in CertificateName.p12 -out CertificateName.pem -nodes]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS TouchID and FaceID]]></title>
    <url>%2F2019%2F02%2F20%2FiOSTouchID%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&#x2F;*** .h 继承自 LAContext* TouchID&#x2F;FaceID 状态*&#x2F;typedef NS_ENUM(NSUInteger, XyAuthIDState)&#123; &#x2F;** * 当前设备不支持TouchID&#x2F;FaceID *&#x2F; XyAuthIDStateNotSupport &#x3D; 0, &#x2F;** * TouchID&#x2F;FaceID 验证成功 *&#x2F; XyAuthIDStateSuccess &#x3D; 1, &#x2F;** * TouchID&#x2F;FaceID 验证失败 *&#x2F; XyAuthIDStateFail &#x3D; 2, &#x2F;** * TouchID&#x2F;FaceID 被用户手动取消 *&#x2F; XyAuthIDStateUserCancel &#x3D; 3, &#x2F;** * 用户不使用TouchID&#x2F;FaceID,选择手动输入密码 *&#x2F; XyAuthIDStateInputPassword &#x3D; 4, &#x2F;** * TouchID&#x2F;FaceID 被系统取消 (如遇到来电,锁屏,按了Home键等) *&#x2F; XyAuthIDStateSystemCancel &#x3D; 5, &#x2F;** * TouchID&#x2F;FaceID 无法启动,因为用户没有设置密码 *&#x2F; XyAuthIDStatePasswordNotSet &#x3D; 6, &#x2F;** * TouchID&#x2F;FaceID 无法启动,因为用户没有设置TouchID&#x2F;FaceID *&#x2F; XyAuthIDStateTouchIDNotSet &#x3D; 7, &#x2F;** * TouchID&#x2F;FaceID 无效 *&#x2F; XyAuthIDStateTouchIDNotAvailable &#x3D; 8, &#x2F;** * TouchID&#x2F;FaceID 被锁定(连续多次验证TouchID&#x2F;FaceID失败,系统需要用户手动输入密码) *&#x2F; XyAuthIDStateTouchIDLockout &#x3D; 9, &#x2F;** * 当前软件被挂起并取消了授权 (如App进入了后台等) *&#x2F; XyAuthIDStateAppCancel &#x3D; 10, &#x2F;** * 当前软件被挂起并取消了授权 (LAContext对象无效) *&#x2F; XyAuthIDStateInvalidContext &#x3D; 11, &#x2F;** * 系统版本不支持TouchID&#x2F;FaceID (必须高于iOS 8.0才能使用) *&#x2F; XyAuthIDStateVersionNotSupport &#x3D; 12&#125;;@interface XyAuthID : LAContexttypedef void (^XyAuthIDStateBlock)(XyAuthIDState state, NSError *error);&#x2F;*** 启动TouchID&#x2F;FaceID进行验证* @param describe TouchID&#x2F;FaceID显示的描述* @param block 回调状态的block*&#x2F;- (void)xy_showAuthIDWithDescribe:(NSString *)describe block:(XyAuthIDStateBlock)block;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#import &lt;UIKit&#x2F;UIKit.h&gt;#define iPhoneX (UIScreen.mainScreen.bounds.size.width &#x3D;&#x3D; 375.f &amp;&amp; UIScreen.mainScreen.bounds.size.height &#x3D;&#x3D; 812.f)@implementation XyAuthID+ (instancetype)sharedInstance &#123; static XyAuthID *instance &#x3D; nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance &#x3D; [[XyAuthID alloc] init]; &#125;); return instance;&#125;- (void)xy_showAuthIDWithDescribe:(NSString *)describe block:(XyAuthIDStateBlock)block &#123; if(!describe) &#123; if(iPhoneX)&#123; describe &#x3D; @&quot;验证已有面容&quot;; &#125;else&#123; describe &#x3D; @&quot;通过Home键验证已有指纹&quot;; &#125; &#125; if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_iOS_8_0) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;系统版本不支持TouchID&#x2F;FaceID (必须高于iOS 8.0才能使用)&quot;); block(XyAuthIDStateVersionNotSupport, nil); &#125;); return; &#125; LAContext *context &#x3D; [[LAContext alloc] init]; &#x2F;&#x2F; 认证失败提示信息，为 @&quot;&quot; 则不提示 context.localizedFallbackTitle &#x3D; @&quot;输入密码&quot;; NSError *error &#x3D; nil; &#x2F;&#x2F; LAPolicyDeviceOwnerAuthenticationWithBiometrics: 用TouchID&#x2F;FaceID验证 &#x2F;&#x2F; LAPolicyDeviceOwnerAuthentication: 用TouchID&#x2F;FaceID或密码验证, 默认是错误两次或锁定后, 弹出输入密码界面（本案例使用） if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:&amp;error]) &#123; [context evaluatePolicy:LAPolicyDeviceOwnerAuthentication localizedReason:describe reply:^(BOOL success, NSError * _Nullable error) &#123; if (success) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID&#x2F;FaceID 验证成功&quot;); block(XyAuthIDStateSuccess, error); &#125;); &#125;else if(error)&#123; if (@available(iOS 11.0, *)) &#123; switch (error.code) &#123; case LAErrorAuthenticationFailed:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID&#x2F;FaceID 验证失败&quot;); block(XyAuthIDStateFail, error); &#125;); &#125; break; case LAErrorUserCancel:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID&#x2F;FaceID 被用户手动取消&quot;); block(XyAuthIDStateUserCancel, error); &#125;); &#125; break; case LAErrorUserFallback:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;用户不使用TouchID&#x2F;FaceID,选择手动输入密码&quot;); block(XyAuthIDStateInputPassword, error); &#125;); &#125; break; case LAErrorSystemCancel:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID&#x2F;FaceID 被系统取消 (如遇到来电,锁屏,按了Home键等)&quot;); block(XyAuthIDStateSystemCancel, error); &#125;); &#125; break; case LAErrorPasscodeNotSet:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID&#x2F;FaceID 无法启动,因为用户没有设置密码&quot;); block(XyAuthIDStatePasswordNotSet, error); &#125;); &#125; break; &#x2F;&#x2F;case LAErrorTouchIDNotEnrolled:&#123; case LAErrorBiometryNotEnrolled:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID&#x2F;FaceID 无法启动,因为用户没有设置TouchID&#x2F;FaceID&quot;); block(XyAuthIDStateTouchIDNotSet, error); &#125;); &#125; break; &#x2F;&#x2F;case LAErrorTouchIDNotAvailable:&#123; case LAErrorBiometryNotAvailable:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID&#x2F;FaceID 无效&quot;); block(XyAuthIDStateTouchIDNotAvailable, error); &#125;); &#125; break; &#x2F;&#x2F;case LAErrorTouchIDLockout:&#123; case LAErrorBiometryLockout:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID&#x2F;FaceID 被锁定(连续多次验证TouchID&#x2F;FaceID失败,系统需要用户手动输入密码)&quot;); block(XyAuthIDStateTouchIDLockout, error); &#125;); &#125; break; case LAErrorAppCancel:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;当前软件被挂起并取消了授权 (如App进入了后台等)&quot;); block(XyAuthIDStateAppCancel, error); &#125;); &#125; break; case LAErrorInvalidContext:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;当前软件被挂起并取消了授权 (LAContext对象无效)&quot;); block(XyAuthIDStateInvalidContext, error); &#125;); &#125; break; default: break; &#125; &#125; else &#123; &#x2F;&#x2F; iOS 11.0以下的版本只有 TouchID 认证 switch (error.code) &#123; case LAErrorAuthenticationFailed:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID 验证失败&quot;); block(XyAuthIDStateFail, error); &#125;); &#125; break; case LAErrorUserCancel:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID 被用户手动取消&quot;); block(XyAuthIDStateUserCancel, error); &#125;); &#125; break; case LAErrorUserFallback:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;用户不使用TouchID,选择手动输入密码&quot;); block(XyAuthIDStateInputPassword, error); &#125;); &#125; break; case LAErrorSystemCancel:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID 被系统取消 (如遇到来电,锁屏,按了Home键等)&quot;); block(XyAuthIDStateSystemCancel, error); &#125;); &#125; break; case LAErrorPasscodeNotSet:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID 无法启动,因为用户没有设置密码&quot;); block(XyAuthIDStatePasswordNotSet, error); &#125;); &#125; break; case LAErrorTouchIDNotEnrolled:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID 无法启动,因为用户没有设置TouchID&quot;); block(XyAuthIDStateTouchIDNotSet, error); &#125;); &#125; break; case LAErrorTouchIDNotAvailable:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID 无效&quot;); block(XyAuthIDStateTouchIDNotAvailable, error); &#125;); &#125; break; case LAErrorTouchIDLockout:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;TouchID 被锁定(连续多次验证TouchID失败,系统需要用户手动输入密码)&quot;); block(XyAuthIDStateTouchIDLockout, error); &#125;); &#125; break; case LAErrorAppCancel:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;当前软件被挂起并取消了授权 (如App进入了后台等)&quot;); block(XyAuthIDStateAppCancel, error); &#125;); &#125; break; case LAErrorInvalidContext:&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;当前软件被挂起并取消了授权 (LAContext对象无效)&quot;); block(XyAuthIDStateInvalidContext, error); &#125;); &#125; break; default: break; &#125; &#125; &#125; &#125;]; &#125;else&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;当前设备不支持TouchID&#x2F;FaceID&quot;); block(XyAuthIDStateNotSupport, error); &#125;); &#125;&#125;@end]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 悬浮按钮]]></title>
    <url>%2F2019%2F02%2F19%2FiOS%E6%82%AC%E6%B5%AE%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[新建继承于UIWindow的类.h文件如下123456789101112131415typedef void(^ClickBlock)(NSInteger i);@interface GSLFloatingView : UIWindow@property (nonatomic, copy) ClickBlock clickBlock;&#x2F;&#x2F;重要：所有图片都要是圆形的，程序里并没有自动处理成圆形&#x2F;&#x2F; warning: frame的长宽必须相等- (instancetype)initWithFrame:(CGRect)frame mainImageName:(NSString *)mainImageName imagesAndTitle:(NSDictionary *)imagesAndTitle backgroundColor:(UIColor *)bgColor;&#x2F;&#x2F; 显示（默认）- (void)showWindow;&#x2F;&#x2F; 隐藏- (void)dissmissWindow;.m 实现文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308#import &quot;GSLFloatingView.h&quot;#define WIDTH self.frame.size.width#define HEIGHT self.frame.size.height#define kScreenWidth [UIScreen mainScreen].bounds.size.width#define kScreenHeight [UIScreen mainScreen].bounds.size.height#define animateDuration 0.3 &#x2F;&#x2F;位置改变动画时间#define showDuration 0.1 &#x2F;&#x2F;展开动画时间#define statusChangeDuration 3.0 &#x2F;&#x2F;状态改变时间#define normalAlpha 0.8 &#x2F;&#x2F;正常状态时背景alpha值#define sleepAlpha 0.3 &#x2F;&#x2F;隐藏到边缘时的背景alpha值#define myBorderWidth 1.0 &#x2F;&#x2F;外框宽度#define marginWith 5 &#x2F;&#x2F;间隔@interface GSLFloatingView ()@property (nonatomic, assign) CGFloat frameWidth;@property (nonatomic, assign) BOOL isShowTab;@property (nonatomic, strong) UIPanGestureRecognizer *panGesture;@property (nonatomic, strong) UITapGestureRecognizer *tapGesture;@property (nonatomic, strong) UIButton *mainImageButton;@property (nonatomic, strong) UIView *contentView;@property (nonatomic, strong) NSDictionary *imagesAndTitle;@property (nonatomic, strong) UIColor *bgColor;@end@implementation GSLFloatingView- (instancetype)initWithFrame:(CGRect)frame mainImageName:(NSString *)mainImageName imagesAndTitle:(NSDictionary *)imagesAndTitle backgroundColor:(UIColor *)bgColor&#123; if (self &#x3D; [super initWithFrame:frame]) &#123; &#x2F;&#x2F; 断言NSAssert()是一个宏，用于开发阶段调试程序中的Bug，通过为NSAssert()传递条件表达式来断定是否属于Bug，满足条件返回真值，程序继续运行，如果返回假值，则抛出异常，并且可以自定义异常描述。 &#x2F;&#x2F; Xcode 已经默认将release环境下的断言取消了, 免除了忘记关闭断言造成的程序不稳定. 所以不用担心 在开发时候大胆使用。 NSAssert(mainImageName !&#x3D; nil, @&quot;mainImageName can&#39;t be nil !&quot;); NSAssert(imagesAndTitle !&#x3D; nil, @&quot;imagesAndTitle can&#39;t be nil !&quot;); _isShowTab &#x3D; NO; self.backgroundColor &#x3D; [UIColor clearColor]; self.windowLevel &#x3D; UIWindowLevelAlert + 1; self.rootViewController &#x3D; [[UIViewController alloc] init]; [self makeKeyAndVisible]; _bgColor &#x3D; bgColor; _frameWidth &#x3D; frame.size.width; _imagesAndTitle &#x3D; imagesAndTitle; _contentView &#x3D; [[UIView alloc] initWithFrame:CGRectMake(_frameWidth, 0, imagesAndTitle.count * (_frameWidth + 5), _frameWidth)]; _contentView.alpha &#x3D; 0; [self addSubview:_contentView]; &#x2F;&#x2F;添加按钮 [self setButtons]; _mainImageButton &#x3D; [UIButton buttonWithType:UIButtonTypeCustom]; _mainImageButton.frame &#x3D; CGRectMake(0, 0, frame.size.width, frame.size.height); [_mainImageButton setImage:[UIImage imageNamed:mainImageName] forState:UIControlStateNormal]; _mainImageButton.alpha &#x3D; sleepAlpha; [_mainImageButton addTarget:self action:@selector(mainButtonDidClicked:) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:_mainImageButton]; [self doBorderWidth:myBorderWidth color:nil cornerRadius:_frameWidth&#x2F;2]; _panGesture &#x3D; [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(locationChange:)]; _panGesture.delaysTouchesBegan &#x3D; NO; [self addGestureRecognizer:_panGesture]; _tapGesture &#x3D; [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(mainButtonDidClicked:)]; [self addGestureRecognizer:_tapGesture]; &#x2F;&#x2F;设备旋转的时候收回按钮 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(orientChange:) name:UIApplicationDidChangeStatusBarOrientationNotification object:nil]; &#125; return self;&#125;&#x2F;&#x2F; 显示（默认）- (void)showWindow&#123; self.hidden &#x3D; NO;&#125;&#x2F;&#x2F; 隐藏- (void)dissmissWindow&#123; self.hidden &#x3D; YES;&#125;- (void)setButtons&#123; int i &#x3D; 0; for (NSString *key in _imagesAndTitle) &#123; UIButton *button &#x3D; [UIButton buttonWithType:UIButtonTypeCustom]; button.frame &#x3D; CGRectMake(self.frameWidth * i, 0, self.frameWidth, self.frameWidth); button.backgroundColor &#x3D; [UIColor clearColor]; UIImage *image &#x3D; [UIImage imageNamed:key]; [button setTitle:_imagesAndTitle[key] forState:UIControlStateNormal]; [button setImage:image forState:UIControlStateNormal]; button.tag &#x3D; i; &#x2F;&#x2F; 则默认image在左，title在右 &#x2F;&#x2F; 改成image在上，title在下 button.titleEdgeInsets &#x3D; UIEdgeInsetsMake(self.frameWidth&#x2F;2, -image.size.width, 0.f, 0.f); button.imageEdgeInsets &#x3D; UIEdgeInsetsMake(2.f, 8.f, 16.f, -button.titleLabel.bounds.size.width + 8); button.titleLabel.font &#x3D; [UIFont systemFontOfSize:self.frameWidth&#x2F;5]; [button addTarget:self action:@selector(itemsDidClicked:) forControlEvents:UIControlEventTouchUpInside]; [self.contentView addSubview:button]; i++; &#125;&#125;#pragma mark ------- 绘图操作 ----------- (void)drawRect:(CGRect)rect &#123; [self drawDash];&#125;&#x2F;&#x2F;分割线- (void)drawDash&#123; CGContextRef context &#x3D; UIGraphicsGetCurrentContext(); CGContextBeginPath(context); CGContextSetLineWidth(context, 0.1); CGContextSetStrokeColorWithColor(context, [UIColor whiteColor].CGColor); CGFloat lengths[] &#x3D; &#123;2, 1&#125;; CGContextSetLineDash(context, 0, lengths, 2); for (int i &#x3D; 1; i &lt; _imagesAndTitle.count; i++) &#123; CGContextMoveToPoint(context, self.contentView.frame.origin.x + i * self.frameWidth, marginWith * 2); CGContextAddLineToPoint(context, self.contentView.frame.origin.x + i * self.frameWidth, self.frameWidth - marginWith * 2); &#125; CGContextStrokePath(context);&#125;#pragma mark ------- contentview 操作 --------------------&#x2F;&#x2F;按钮在屏幕右边时，左移contentview- (void)moveContentviewLeft&#123; _contentView.frame &#x3D; CGRectMake(self.frameWidth&#x2F;3, 0, _contentView.frame.size.width, _contentView.frame.size.height);&#125;&#x2F;&#x2F;按钮在屏幕左边时，contentview恢复默认- (void)resetContentview&#123; _contentView.frame &#x3D; CGRectMake(self.frameWidth + marginWith, 0, _contentView.frame.size.width, _contentView.frame.size.height);&#125;&#x2F;&#x2F;改变位置- (void)locationChange:(UIPanGestureRecognizer*)panGesture&#123; CGPoint panPoint &#x3D; [panGesture locationInView:[UIApplication sharedApplication].keyWindow]; if (panGesture.state &#x3D;&#x3D; UIGestureRecognizerStateBegan) &#123; [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(changeStatus) object:nil]; _mainImageButton.alpha &#x3D; normalAlpha; &#125;else if (panGesture.state &#x3D;&#x3D; UIGestureRecognizerStateChanged) &#123; self.center &#x3D; CGPointMake(panPoint.x, panPoint.y); &#125;else if (panGesture.state &#x3D;&#x3D; UIGestureRecognizerStateEnded)&#123; [self performSelector:@selector(changeStatus) withObject:nil afterDelay:statusChangeDuration]; if (panPoint.x &lt;&#x3D; kScreenWidth&#x2F;2) &#123; if (panPoint.y &lt;&#x3D; 40 + HEIGHT&#x2F;2 &amp;&amp; panPoint.x &gt;&#x3D; 20 + WIDTH&#x2F;2) &#123; [UIView animateWithDuration:animateDuration animations:^&#123; self.center &#x3D; CGPointMake(panPoint.x, HEIGHT&#x2F;2); &#125;]; &#125;else if (panPoint.y &gt;&#x3D; kScreenHeight - HEIGHT&#x2F;2 - 40 &amp;&amp; panPoint.x &gt;&#x3D; 20 +WIDTH&#x2F;2)&#123; [UIView animateWithDuration:animateDuration animations:^&#123; self.center &#x3D; CGPointMake(panPoint.x, kScreenHeight-HEIGHT&#x2F;2); &#125;]; &#125;else if (panPoint.x &lt; WIDTH&#x2F;2 + 20 &amp;&amp; panPoint.y &gt; kScreenHeight - HEIGHT&#x2F;2)&#123; [UIView animateWithDuration:animateDuration animations:^&#123; self.center &#x3D; CGPointMake(WIDTH&#x2F;2, kScreenHeight-HEIGHT&#x2F;2); &#125;]; &#125;else&#123; CGFloat pointy &#x3D; panPoint.y &lt; HEIGHT&#x2F;2 ? HEIGHT&#x2F;2 :panPoint.y; [UIView animateWithDuration:animateDuration animations:^&#123; self.center &#x3D; CGPointMake(WIDTH&#x2F;2, pointy); &#125;]; &#125; &#125;else if (panPoint.x &gt; kScreenWidth&#x2F;2)&#123; if (panPoint.y &lt;&#x3D; 40 + HEIGHT&#x2F;2 &amp;&amp; panPoint.x &lt; kScreenWidth - WIDTH&#x2F;2 - 20) &#123; [UIView animateWithDuration:animateDuration animations:^&#123; self.center &#x3D; CGPointMake(panPoint.x, HEIGHT&#x2F;2); &#125;]; &#125;else if (panPoint.y &gt;&#x3D; kScreenHeight - 40 - HEIGHT&#x2F;2 &amp;&amp; panPoint.x &lt; kScreenWidth - WIDTH&#x2F;2 - 20)&#123; [UIView animateWithDuration:animateDuration animations:^&#123; self.center &#x3D; CGPointMake(panPoint.x, kScreenHeight-HEIGHT&#x2F;2); &#125;]; &#125;else if (panPoint.x &gt; kScreenWidth - WIDTH&#x2F;2 - 20 &amp;&amp; panPoint.y &lt; HEIGHT&#x2F;2)&#123; [UIView animateWithDuration:animateDuration animations:^&#123; self.center &#x3D; CGPointMake(kScreenWidth-WIDTH&#x2F;2, HEIGHT&#x2F;2); &#125;]; &#125;else&#123; CGFloat pointy &#x3D; panPoint.y &gt; kScreenHeight-HEIGHT&#x2F;2 ? kScreenHeight-HEIGHT&#x2F;2 :panPoint.y; [UIView animateWithDuration:animateDuration animations:^&#123; self.center &#x3D; CGPointMake(kScreenWidth-WIDTH&#x2F;2, pointy); &#125;]; &#125; &#125; &#125;&#125;&#x2F;&#x2F;点击事件- (void)mainButtonDidClicked:(UITapGestureRecognizer*)tapGesture&#123; _mainImageButton.alpha &#x3D; normalAlpha; &#x2F;&#x2F;拉出悬浮窗 if (self.center.x &#x3D;&#x3D; 0) &#123; self.center &#x3D; CGPointMake(WIDTH&#x2F;2, self.center.y); &#125;else if (self.center.x &#x3D;&#x3D; kScreenWidth)&#123; self.center &#x3D; CGPointMake(kScreenWidth - WIDTH&#x2F;2, self.center.y); &#125;else if (self.center.y &#x3D;&#x3D; 0)&#123; self.center &#x3D; CGPointMake(self.center.x, HEIGHT&#x2F;2); &#125;else if (self.center.y &#x3D;&#x3D; kScreenHeight)&#123; self.center &#x3D; CGPointMake(self.center.x, kScreenHeight - HEIGHT&#x2F;2); &#125; &#x2F;&#x2F;展示按钮列表 if (!self.isShowTab) &#123; self.isShowTab &#x3D; YES; &#x2F;&#x2F;为了主按钮点击动画 self.layer.masksToBounds &#x3D; YES; [UIView animateWithDuration:showDuration animations:^&#123; _contentView.alpha &#x3D; 1; if (self.frame.origin.x &lt;&#x3D; kScreenWidth&#x2F;2) &#123; [self resetContentview]; self.frame &#x3D; CGRectMake(self.frame.origin.x, self.frame.origin.y, WIDTH + _imagesAndTitle.count * (self.frameWidth + marginWith), self.frameWidth); &#125;else&#123; [self moveContentviewLeft]; self.mainImageButton.frame &#x3D; CGRectMake((_imagesAndTitle.count * (self.frameWidth + marginWith)), 0, self.frameWidth, self.frameWidth); self.frame &#x3D; CGRectMake(self.frame.origin.x - _imagesAndTitle.count * (self.frameWidth + marginWith), self.frame.origin.y, (WIDTH + _imagesAndTitle.count * (self.frameWidth + marginWith)), self.frameWidth); &#125; if (_bgColor) &#123; self.backgroundColor &#x3D; _bgColor; &#125;else&#123; self.backgroundColor &#x3D; [UIColor grayColor]; &#125; &#125;]; &#x2F;&#x2F;移除pan手势 if (_panGesture) &#123; [self removeGestureRecognizer:_panGesture]; &#125; [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(changeStatus) object:nil]; &#125;else&#123; self.isShowTab &#x3D; NO; &#x2F;&#x2F;为主按钮点击动画 self.layer.masksToBounds &#x3D; NO; &#x2F;&#x2F;添加pan手势 if (_panGesture) &#123; [self addGestureRecognizer:_panGesture]; &#125; [UIView animateWithDuration:showDuration animations:^&#123; _contentView.alpha &#x3D; 0; if (self.frame.origin.x + self.mainImageButton.frame.origin.x &lt;&#x3D; kScreenWidth&#x2F;2) &#123; self.frame &#x3D; CGRectMake(self.frame.origin.x, self.frame.origin.y, self.frameWidth, self.frameWidth); &#125;else&#123; self.mainImageButton.frame &#x3D; CGRectMake(0, 0, self.frameWidth, self.frameWidth); self.frame &#x3D; CGRectMake(self.frame.origin.x + _imagesAndTitle.count * (self.frameWidth + marginWith), self.frame.origin.y, self.frameWidth, self.frameWidth); &#125; self.backgroundColor &#x3D; [UIColor clearColor]; &#125;]; [self performSelector:@selector(changeStatus) withObject:nil afterDelay:statusChangeDuration]; &#125;&#125;- (void)changeStatus&#123; [UIView animateWithDuration:1.0 animations:^&#123; _mainImageButton.alpha &#x3D; sleepAlpha; &#125;]; [UIView animateWithDuration:0.5 animations:^&#123; CGFloat x &#x3D; self.center.x &lt; 20+WIDTH&#x2F;2 ? 0 : self.center.x &gt; kScreenWidth - 20 -WIDTH&#x2F;2 ? kScreenWidth : self.center.x; CGFloat y &#x3D; self.center.y &lt; 40 + HEIGHT&#x2F;2 ? 0 : self.center.y &gt; kScreenHeight - 40 - HEIGHT&#x2F;2 ? kScreenHeight : self.center.y; &#x2F;&#x2F;禁止停留在4个角 if((x &#x3D;&#x3D; 0 &amp;&amp; y &#x3D;&#x3D;0) || (x &#x3D;&#x3D; kScreenWidth &amp;&amp; y &#x3D;&#x3D; 0) || (x &#x3D;&#x3D; 0 &amp;&amp; y &#x3D;&#x3D; kScreenHeight) || (x &#x3D;&#x3D; kScreenWidth &amp;&amp; y &#x3D;&#x3D; kScreenHeight))&#123; y &#x3D; self.center.y; &#125; self.center &#x3D; CGPointMake(x, y); &#125;];&#125;- (void)doBorderWidth:(CGFloat)width color:(UIColor *)color cornerRadius:(CGFloat)cornerRadius&#123; self.layer.cornerRadius &#x3D; cornerRadius; self.layer.borderWidth &#x3D; width; if (!color) &#123; self.layer.borderColor &#x3D; [UIColor whiteColor].CGColor; &#125;else&#123; self.layer.borderColor &#x3D; color.CGColor; &#125;&#125;#pragma mark ------- button事件 ---------- (void)itemsDidClicked:(id)sender&#123; if (self.isShowTab)&#123; [self mainButtonDidClicked:nil]; &#125; UIButton *button &#x3D; (UIButton *)sender; if (self.clickBlock) &#123; self.clickBlock(button.tag); &#125;&#125;#pragma mark ------- 设备旋转 ------------ (void)orientChange:(NSNotification *)notification&#123; &#x2F;&#x2F;不设置的话,长按动画那块有问题 self.layer.masksToBounds &#x3D; YES; &#x2F;&#x2F;旋转前要先改变frame，否则坐标有问题（临时办法） self.frame &#x3D; CGRectMake(0, kScreenHeight - self.frame.origin.y - self.frame.size.height, self.frame.size.width,self.frame.size.height); if (self.isShowTab) &#123; [self mainButtonDidClicked:nil]; &#125;&#125;@end]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 瀑布流布局实现详解]]></title>
    <url>%2F2019%2F02%2F18%2FiOS%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[新建文件继承自UICollectionViewLayout.h内容如下：1234567891011121314151617181920@class WaterFlowLayout;@protocol WaterFlowLayoutDelegate &lt;NSObject&gt;&#x2F;&#x2F;使用delegate取得每一个Cell的高度- (CGFloat)waterFlow:(WaterFlowLayout *)layout heightForCellAtIndexPath:(NSIndexPath *)indexPath;@end@interface WaterFlowLayout : UICollectionViewLayout&#x2F;&#x2F;声明协议@property (nonatomic, weak) id &lt;WaterFlowLayoutDelegate&gt; delegate;&#x2F;&#x2F;确定列数@property (nonatomic, assign) NSInteger colum;&#x2F;&#x2F;确定内边距@property (nonatomic, assign) UIEdgeInsets insetSpace;&#x2F;&#x2F;确定每个cell之间的距离@property (nonatomic, assign) NSInteger distance;@end.m实现内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157@interface WaterFlowLayout ()&#x2F;&#x2F;存储列高的数组@property (nonatomic, strong) NSMutableArray *columHeightArr;&#x2F;&#x2F;存储所有cell的尺寸信息@property (nonatomic, strong) NSMutableArray *cellFrameArr;@end@implementation WaterFlowLayout&#x2F;&#x2F;colum的set方法- (void)setColum:(NSInteger)colum&#123; if (_colum !&#x3D; colum) &#123; _colum &#x3D; colum; &#x2F;&#x2F;将之前的布局信息失效，重新布局 [self invalidateLayout]; &#125;&#125;&#x2F;&#x2F;distance的set方法- (void)setDistance:(NSInteger)distance&#123; if (_distance !&#x3D; distance) &#123; _distance &#x3D; distance; [self invalidateLayout]; &#125;&#125;&#x2F;&#x2F;insetSpace的set方法- (void)setInsetSpace:(UIEdgeInsets)insetSpace&#123; if (!UIEdgeInsetsEqualToEdgeInsets(_insetSpace, insetSpace)) &#123; _insetSpace &#x3D; insetSpace; [self invalidateLayout]; &#125;&#125;&#x2F;&#x2F;自定义layout需要重写下面的几个方法&#x2F;&#x2F;准备布局，将item的位置信息计算出来- (void)prepareLayout&#123; &#x2F;&#x2F;将位置信息和高度信息的数组实例化 [self initDataArray]; &#x2F;&#x2F;初始化每一列的初始高度 [self initColumHeightArray]; &#x2F;&#x2F;初始化计算出全部cell的高度，并且存入数组 [self initAllCellHeight];&#125;&#x2F;&#x2F;将位置信息和高度信息的数组实例化- (void)initDataArray&#123; &#x2F;&#x2F;记录当前每一列的高度，所以我们只需要列数的空间就够了。 _columHeightArr &#x3D; [NSMutableArray arrayWithCapacity:_colum]; &#x2F;&#x2F;记录所有cell的尺寸信息 _cellFrameArr &#x3D; [NSMutableArray arrayWithCapacity:0];&#125;&#x2F;&#x2F;初始化每一列的初始高度- (void)initColumHeightArray&#123; for (int i &#x3D; 0; i &lt; _colum; i++) &#123; [_columHeightArr addObject:@(_insetSpace.top)]; &#125;&#125;&#x2F;&#x2F;初始化计算出全部cell的高度，并且存入数组- (void)initAllCellHeight&#123; &#x2F;&#x2F;拿出第一组的全部cell的数量 NSInteger allCellNumber &#x3D; [self.collectionView numberOfItemsInSection:0]; &#x2F;&#x2F;取得整个collectionView的宽度 CGFloat totalWidth &#x3D; self.collectionView.frame.size.width; &#x2F;&#x2F;取得一行中Cell的总宽度 CGFloat itemAllWidth &#x3D; totalWidth - _insetSpace.left - _insetSpace.right - _distance * (_colum - 1); &#x2F;&#x2F;取得每一个cell的宽度 CGFloat width &#x3D; itemAllWidth&#x2F;_colum; &#x2F;&#x2F;循环计算每一个cell的高度并且将位置信息添加到数组中 for (int i &#x3D; 0; i &lt; allCellNumber; i++) &#123; &#x2F;&#x2F;拿到当前的列的信息 NSInteger currentColum &#x3D; [self getShortColum]; &#x2F;&#x2F;x偏移就是用当前的列去乘以宽度和间距，并且加上内边距 CGFloat xOffset &#x3D; _insetSpace.left + currentColum * (width + _distance); &#x2F;&#x2F;制造索引路径 NSIndexPath *indexPath &#x3D; [NSIndexPath indexPathForItem:i inSection:0]; &#x2F;&#x2F;取得y偏移 CGFloat yOffset &#x3D; [[_columHeightArr objectAtIndex:currentColum] floatValue] + _distance; &#x2F;&#x2F;取得高度，由实现协议者提供 CGFloat height &#x3D; 0.f; if (_delegate &amp;&amp; [_delegate respondsToSelector:@selector(waterFlow:heightForCellAtIndexPath:)]) &#123; height &#x3D; [_delegate waterFlow:self heightForCellAtIndexPath:indexPath]; &#125; &#x2F;&#x2F;整理cell的尺寸信息 CGRect frame &#x3D; CGRectMake(xOffset, yOffset, width, height); &#x2F;&#x2F;attributes是用来存储当前indexPath的cell的位置信息的 UICollectionViewLayoutAttributes *attributes &#x3D; [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; attributes.frame &#x3D; frame; &#x2F;&#x2F;将位置信息添加到cell尺寸数组中 [_cellFrameArr addObject:attributes]; &#x2F;&#x2F;改变当前列的高度 _columHeightArr[currentColum] &#x3D; @(frame.size.height + frame.origin.y); &#125;&#125;&#x2F;&#x2F;取得当前cell的尺寸-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; return [_cellFrameArr objectAtIndex:indexPath.item];&#125;&#x2F;&#x2F;根据rect去找出需要布局的cell的位置信息- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; &#x2F;&#x2F;用来存储可以展示的cell的位置信息 NSMutableArray *temp &#x3D; [NSMutableArray arrayWithCapacity:0]; for (UICollectionViewLayoutAttributes *attributes in _cellFrameArr) &#123; &#x2F;&#x2F;如果取出的位置信息，在rect的范围内，就将这个位置信息，装入数组中。 if (CGRectIntersectsRect(attributes.frame, rect)) &#123; [temp addObject:attributes]; &#125; &#125; return temp;&#125;&#x2F;&#x2F;指定collection的contentSize- (CGSize)collectionViewContentSize&#123; &#x2F;&#x2F;内容宽度指定为collectionView的宽度(横向不发生滚动) CGFloat width &#x3D; self.collectionView.frame.size.width; &#x2F;&#x2F;取出最长的列，将其高度定位长度 CGFloat height &#x3D; [self getLongColum]; return CGSizeMake(width, height);&#125;- (CGFloat)getLongColum&#123; &#x2F;&#x2F;记录当前最长的列号 __block NSInteger currentColum &#x3D; 0; &#x2F;&#x2F;假设最长的列高度为0 __block CGFloat longHeight &#x3D; 0; &#x2F;&#x2F;枚举数组中的元素 [_columHeightArr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([obj floatValue] &gt; longHeight) &#123; longHeight &#x3D; [obj floatValue]; currentColum &#x3D; idx; &#125; &#125;]; return longHeight + _insetSpace.bottom;&#125;&#x2F;&#x2F;取得最短的列- (NSInteger)getShortColum&#123; &#x2F;&#x2F;记录当前最短的列号 __block NSInteger currentColum &#x3D; 0; &#x2F;&#x2F;假设最短的列高度为float的最大值 __block CGFloat shortHeight &#x3D; MAXFLOAT; &#x2F;&#x2F;枚举数组中的元素 [_columHeightArr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; if ([obj floatValue] &lt; shortHeight) &#123; shortHeight &#x3D; [obj floatValue]; currentColum &#x3D; idx; &#125; &#125;]; return currentColum;&#125;@end]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 动画-购物车动画为例]]></title>
    <url>%2F2019%2F02%2F15%2FiOS%E5%8A%A8%E7%94%BB-%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%A8%E7%94%BB%E4%B8%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[设定动画设定动画的属性和说明 属性 说明 duration 动画的时长 repeatCount 重复的次数。不停重复设置为 HUGE_VALF repeatDuration 设置动画的时间。在该时间内动画一直执行，不计次数。 beginTime 指定动画开始的时间。从开始延迟几秒的话，设置为【CACurrentMediaTime() + 秒数】 的方式 timingFunction 设置动画的速度变化 autoreverses 动画结束时是否执行逆动画 fromValue 所改变属性的起始值 toValue 所改变属性的结束时的值 byValue 所改变属性相同起始值的改变量 123456transformAnima.fromValue &#x3D; @(M_PI_2);transformAnima.toValue &#x3D; @(M_PI);transformAnima.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];transformAnima.autoreverses &#x3D; YES;transformAnima.repeatCount &#x3D; HUGE_VALF;transformAnima.beginTime &#x3D; CACurrentMediaTime() + 2; 防止动画结束后回到初始状态只需设置removedOnCompletion、fillMode两个属性就可以了12transformAnima.removedOnCompletion &#x3D; NO;transformAnima.fillMode &#x3D; kCAFillModeForwards; 一些常用的animationWithKeyPath值的总结 值 说明 使用形式 transform.scale 比例转化 @(0.8) transform.scale.x 宽的比例 @(0.8) transform.scale.y 高的比例 @(0.8) transform.rotation.x 围绕x轴旋转 @(M_PI) transform.rotation.y 围绕y轴旋转 @(M_PI) transform.rotation.z 围绕z轴旋转 @(M_PI) cornerRadius 圆角的设置 @(50) backgroundColor 背景颜色的变化 (id)[UIColor purpleColor].CGColor bounds 大小，中心不变 [NSValue valueWithCGRect:CGRectMake(0, 0, 200, 200)]; position 位置(中心点的改变) [NSValue valueWithCGPoint:CGPointMake(300, 300)]; contents 内容，比如UIImageView的图片 imageAnima.toValue = (id)[UIImage imageNamed:@”to”].CGImage; opacity 透明度 @(0.7) contentsRect.size.width 横向拉伸缩放 @(0.4)最好是0~1之间的 购物车动画ShoppingCarAnimationTool.h定义屏幕信息和block回传12345678910111213141516171819202122#define ScreenWidth [UIScreen mainScreen].bounds.size.width#define ScreenHeight [UIScreen mainScreen].bounds.size.heighttypedef void(^AnimationFinishBlock)(BOOL finishBlock);&#x2F;&#x2F; 添加属性@property (nonatomic, strong) CALayer *layer;@property (nonatomic, copy) AnimationFinishBlock animationFinishBlock;&#x2F;&#x2F; 暴露出来的方法&#x2F;&#x2F; 初始化+ (instancetype)shareTool;&#x2F;*** 开始动画* @param view 添加动画的view* @param rect view 的绝对frame* @param finishPoint 下落的位置* @param completion 动画完成回调*&#x2F;- (void)startAnimationandView:(UIView *)view andRect:(CGRect)rect andFinisnRect:(CGPoint)finishPoint andFinishBlock:(AnimationFinishBlock)completion;&#x2F;&#x2F; 摇晃动画+ (void)shakeAnimation:(UIView *)shakeView;ShoppingCarAnimationTool.m实现方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364+ (instancetype)shareTool&#123; return [[ShoppingCarAnimationTool alloc] init];&#125;- (void)startAnimationandView:(UIView *)view andRect:(CGRect)rect andFinisnRect:(CGPoint)finishPoint andFinishBlock:(AnimationFinishBlock)completion&#123; &#x2F;&#x2F;------- 创建CALayer -------&#x2F;&#x2F; _layer &#x3D; [CALayer layer]; _layer.contents &#x3D; view.layer.contents; _layer.contentsGravity &#x3D; kCAGravityResizeAspectFill; rect.size.width &#x3D; 60; rect.size.height &#x3D; 60; &#x2F;&#x2F;重置图层尺寸 _layer.bounds &#x3D; rect; _layer.cornerRadius &#x3D; rect.size.width&#x2F;2; _layer.masksToBounds &#x3D; YES; &#x2F;&#x2F;圆角 &#x2F;&#x2F; 添加layer到顶层视图控制器上 [[UIApplication sharedApplication].delegate.window.layer addSublayer:_layer]; _layer.position &#x3D; CGPointMake(rect.origin.x + view.frame.size.width&#x2F;2, CGRectGetMidY(rect)); &#x2F;&#x2F;a 点 &#x2F;&#x2F;------- 创建移动轨迹 -------&#x2F; UIBezierPath *path &#x3D; [UIBezierPath bezierPath]; [path moveToPoint:_layer.position]; [path addQuadCurveToPoint:finishPoint controlPoint:CGPointMake(ScreenWidth&#x2F;2, rect.origin.y - 80)]; &#x2F;&#x2F;关键帧动画 CAKeyframeAnimation *pathAnimation &#x3D; [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;]; pathAnimation.path &#x3D; path.CGPath; &#x2F;&#x2F; 旋转动画 CABasicAnimation *rotateAnimation &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation&quot;]; rotateAnimation.removedOnCompletion &#x3D; YES; rotateAnimation.fromValue &#x3D; [NSNumber numberWithFloat:0]; rotateAnimation.toValue &#x3D; [NSNumber numberWithFloat:12]; rotateAnimation.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn]; CAAnimationGroup *groups &#x3D; [CAAnimationGroup animation]; groups.animations &#x3D; @[pathAnimation, rotateAnimation]; groups.duration &#x3D; 1.2f; groups.removedOnCompletion &#x3D; NO; groups.fillMode &#x3D; kCAFillModeForwards; groups.delegate &#x3D; self; [_layer addAnimation:groups forKey:@&quot;group&quot;]; if (completion) &#123; _animationFinishBlock &#x3D; completion; &#125;&#125;&#x2F;&#x2F; 动画结束代理- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123; if (anim &#x3D;&#x3D; [_layer animationForKey:@&quot;group&quot;]) &#123; [_layer removeFromSuperlayer]; _layer &#x3D; nil; if (_animationFinishBlock) &#123; _animationFinishBlock(YES); &#125; &#125;&#125;&#x2F;&#x2F; 上下晃动动画+ (void)shakeAnimation:(UIView *)shakeView&#123; CABasicAnimation *shakeAnimation &#x3D; [CABasicAnimation animationWithKeyPath:@&quot;transform.translation.y&quot;]; shakeAnimation.duration &#x3D; 0.25; shakeAnimation.fromValue &#x3D; [NSNumber numberWithFloat:-5]; shakeAnimation.toValue &#x3D; [NSNumber numberWithFloat:5]; shakeAnimation.autoreverses &#x3D; YES; [shakeView.layer addAnimation:shakeAnimation forKey:nil];&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中UIWebView与WKWebView]]></title>
    <url>%2F2019%2F02%2F14%2FiOS%E4%B8%ADUIWebView%E4%B8%8EWKWebView%2F</url>
    <content type="text"><![CDATA[1. UIWebViewUIWebView 适用于iOS8.0以下的系统版本iOS原生没有提供js直接调用OC的方式，只能通过UIWebView的UIWebViewDelegate协议方法来做拦截，并在这个方法中，根据url来调用OC方法；1-(BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType UIWebViewDelegate代理协议使用： 1234567891011121314151617181920212223242526272829&#x2F;&#x2F; 是否允许加载网页，也可获取js要打开的url，通过截取此url可与js交互- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; NSString *urlString &#x3D; [[request URL] absoluteString]; urlString &#x3D; [urlString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; NSArray *urlComps &#x3D; [urlString componentsSeparatedByString:@&quot;:&#x2F;&#x2F;&quot;]; NSLog(@&quot;urlString&#x3D;%@---urlComps&#x3D;%@&quot;,urlString,urlComps); return YES;&#125;&#x2F;&#x2F; 开始加载网页- (void)webViewDidStartLoad:(UIWebView *)webView &#123; NSURLRequest *request &#x3D; webView.request; NSLog(@&quot;webViewDidStartLoad-url&#x3D;%@--%@&quot;,[request URL],[request HTTPBody]);&#125;&#x2F;&#x2F; 网页加载完成- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; NSURLRequest *request &#x3D; webView.request; NSURL *url &#x3D; [request URL]; if ([url.path isEqualToString:@&quot;&#x2F;normal.html&quot;]) &#123; NSLog(@&quot;isEqualToString&quot;); &#125; NSLog(@&quot;webViewDidFinishLoad-url&#x3D;%@--%@&quot;,[request URL],[request HTTPBody]); NSLog(@&quot;%@&quot;,[self.webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;]);&#125;&#x2F;&#x2F; 网页加载错误- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error &#123; NSURLRequest *request &#x3D; webView.request; NSLog(@&quot;didFailLoadWithError-url&#x3D;%@--%@&quot;,[request URL],[request HTTPBody]);&#125; 2. WKWebView 引入WebKit库#import &lt;WebKit/WebKit.h&gt; 在文档中可以看出，WKWebView的初始化方法有两种：12- (instancetype)initWithFrame:(CGRect)frame- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration 我们大多使用第一种方式，这也是文档中默认的一种方式。 WKWebView 代理协议方法如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#x2F;&#x2F;页面开始加载时调用- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation&#123; NSLog(@&quot;页面开始加载时调用。 2&quot;);&#125;&#x2F;&#x2F;内容返回时调用，得到请求内容时调用(内容开始加载) -&gt; view的过渡动画可在此方法中加载- (void)webView:(WKWebView *)webView didCommitNavigation:( WKNavigation *)navigation&#123; NSLog(@&quot;内容返回时调用，得到请求内容时调用。 4&quot;);&#125;&#x2F;&#x2F;页面加载完成时调用- (void)webView:(WKWebView *)webView didFinishNavigation:( WKNavigation *)navigation&#123; NSLog(@&quot;页面加载完成时调用。 5&quot;);&#125;&#x2F;&#x2F;请求失败时调用- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error&#123; NSLog(@&quot;error1:%@&quot;,error);&#125;-(void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error&#123; NSLog(@&quot;error2:%@&quot;,error);&#125;&#x2F;&#x2F;在请求发送之前，决定是否跳转 -&gt; 该方法如果不实现，系统默认跳转。如果实现该方法，则需要设置允许跳转，不设置则报错。&#x2F;&#x2F;该方法执行在加载界面之前&#x2F;&#x2F;Terminating app due to uncaught exception &#39;NSInternalInconsistencyException&#39;, reason: &#39;Completion handler passed to -[ViewController webView:decidePolicyForNavigationAction:decisionHandler:] was not called&#39;- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123; &#x2F;&#x2F;允许跳转 decisionHandler(WKNavigationActionPolicyAllow); &#x2F;&#x2F;不允许跳转 &#x2F;&#x2F; decisionHandler(WKNavigationActionPolicyCancel); NSLog(@&quot;在请求发送之前，决定是否跳转。 1&quot;);&#125;&#x2F;&#x2F;在收到响应后，决定是否跳转（同上）&#x2F;&#x2F;该方法执行在内容返回之前- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler&#123; &#x2F;&#x2F;允许跳转 decisionHandler(WKNavigationResponsePolicyAllow); &#x2F;&#x2F;不允许跳转 &#x2F;&#x2F; decisionHandler(WKNavigationResponsePolicyCancel); NSLog(@&quot;在收到响应后，决定是否跳转。 3&quot;);&#125;&#x2F;&#x2F;接收到服务器跳转请求之后调用- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation&#123; NSLog(@&quot;接收到服务器跳转请求之后调用&quot;);&#125;-(void)webViewWebContentProcessDidTerminate:(WKWebView *)webView&#123; NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);&#125; 3. OC调用JS传递参数 UIWebView方法1NSString *str &#x3D; [self.webview stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@&quot;postStr(&#39;%@&#39;,&#39;%@&#39;);&quot;,str1,str2]]; WKWebView方法123[self.wkWebView evaluateJavaScript:[NSString stringWithFormat:@&quot;postStr(&#39;%@&#39;)&quot;, @&quot;true&quot;] completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSLog(@&quot;&#x3D;&#x3D;%@----%@&quot;, result, error);&#125;]; 在需要接受参数值的js界面实现如下方法:1234function postStr(str1, str2)&#123; alert(str1, str2); &#x2F;&#x2F;接收到的值”; &#x2F;&#x2F;...code&#125; 4. JS调用OC传递参数js是不能执行oc代码的，但是可以变相的执行，js可以将要执行的操作封装到网络请求里面，然后oc拦截这个请求，获取url里面的字符串解析即可。（拦截URL）比如darkangel://。方法是在html或者js中，点击某个按钮触发事件时，跳转到自定义URL Scheme构成的链接，而OC中捕获该链接，从中解析必要的参数，实现JS到OC的一次交互。比如页面中一个a标签，链接如下：&lt;a href=&quot;darkangel: smslogin?username=&quot;12323123&amp;code=892845&quot;&quot;&gt;短信验证登录&lt;/a href=&quot;darkangel:&gt;在该方法中，捕获该链接，并且返回NO（阻止本次跳转），从而执行对应的OC方法。 UIWebView方法12345678910111213141516&#x2F;** 方法的返回值是BOOL值。* 返回YES：表示让浏览器执行默认操作，比如某个a链接跳转* 返回NO：表示不执行浏览器的默认操作，这里因为通过url协议来判断js执行native的操作，肯定不是浏览器默认操作，故返回NO*&#x2F;- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; &#x2F;&#x2F;标准的URL包含scheme、host、port、path、query、fragment等 NSURL *URL &#x3D; request.URL; if ([URL.scheme isEqualToString:@&quot;darkangel&quot;]) &#123; if ([URL.host isEqualToString:@&quot;smsLogin&quot;]) &#123; NSLog(@&quot;短信验证码登录，参数为 %@&quot;, URL.query); return NO; &#125; &#125; return YES;&#125; WKWebView方法123456789101112131415161718- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; &#x2F;&#x2F;可以通过navigationAction.navigationType获取跳转类型，如新链接、后退等 NSURL *URL &#x3D; navigationAction.request.URL; &#x2F;&#x2F;判断URL是否符合自定义的URL Scheme if ([URL.scheme isEqualToString:@&quot;darkangel&quot;]) &#123; &#x2F;&#x2F;根据不同的业务，来执行对应的操作，且获取参数 if ([URL.host isEqualToString:@&quot;smsLogin&quot;]) &#123; NSString *param &#x3D; URL.query; NSLog(@&quot;短信验证码登录, 参数为%@&quot;, param); &#x2F;&#x2F;不允许跳转 decisionHandler(WKNavigationActionPolicyCancel); return; &#125; &#125; &#x2F;&#x2F;允许跳转 decisionHandler(WKNavigationActionPolicyAllow); NSLog(@&quot;%@&quot;, NSStringFromSelector(_cmd));&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 每隔一段时间执行一次代码]]></title>
    <url>%2F2019%2F02%2F02%2FiOS%E6%AF%8F%E9%9A%94%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021&#x2F;&#x2F;每隔一分钟执行一次打印&#x2F;&#x2F; GCD定时器static dispatch_source_t _timer;&#x2F;&#x2F;设置时间间隔NSTimeInterval period &#x3D; 60.f;dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);_timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0);&#x2F;&#x2F; 事件回调dispatch_source_set_event_handler(_timer, ^&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;Count&quot;); &#x2F;&#x2F;网络请求 doSomeThing... &#125;);&#125;);&#x2F;&#x2F; 开启定时器dispatch_resume(_timer);&#x2F;&#x2F; 关闭定时器&#x2F;&#x2F; dispatch_source_cancel(_timer);]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 快速定位到系统设置界面]]></title>
    <url>%2F2019%2F02%2F01%2FiOS%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425&#x2F;&#x2F;定位服务设置界面NSURL * url &#x3D; [NSURL URLWithString:@&quot;prefs:root&#x3D;LOCATION_SERVICES&quot;];if ([[UIApplication sharedApplication] canOpenURL:url]) &#123; [[UIApplication sharedApplication] openURL:url];&#125;&#x2F;&#x2F;定位服务设置界面@&quot;prefs:root&#x3D;LOCATION_SERVICES&quot;&#x2F;&#x2F;GameCenter设置界面@&quot;prefs:root&#x3D;GAME_CENTER&quot;&#x2F;&#x2F;WIFI设置界面@&quot;prefs:root&#x3D;WIFI&quot;&#x2F;&#x2F;通知设置界面@&quot;prefs:root&#x3D;NOTIFICATIONS_ID&quot;&#x2F;&#x2F;蓝牙设置界面@&quot;prefs:root&#x3D;Bluetooth&quot;&#x2F;&#x2F;iCloud设置界面@&quot;prefs:root&#x3D;CASTLE&quot;&#x2F;&#x2F;调用系统邮件发邮件- (void)gotoEmail:(NSString *)emailAccount&#123; NSString * recipients &#x3D; [NSString stringWithFormat:@&quot;mailto:%@&quot;, emailAccount]; NSString * email &#x3D; [recipients stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:email]];&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 防止离屏渲染绘制圆角图片方法]]></title>
    <url>%2F2019%2F01%2F31%2FiOS%E7%BB%98%E5%88%B6%E5%9C%86%E8%A7%92%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是离屏渲染离屏渲染就是在当前屏幕缓冲区以外，新开辟一个缓冲区进行操作 离屏渲染触发的场景 圆角（同时设置layer.masksToBounds = YES、layer.cornerRadius大于0） 图层蒙版 阴影，layer.shadowXXX，如果设置了layer.shadowPath就不会产生离屏渲染 遮罩，layer.mask 光栅化，layer.shouldRasterize = YES 离屏渲染消耗性能的原因需要创建新的缓冲区，离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕 以下两种绘制圆角图片方法，可以防止离屏渲染 贝塞尔曲线方法12345678910111213141516171819- (void)drawCornerPicture&#123; UIImageView *imageView &#x3D; [[UIImageView alloc] initWithFrame:CGRectMake(200, 400, 200, 200)]; imageView.image &#x3D; [UIImage imageNamed:@&quot;1&quot;]; &#x2F;&#x2F; 开启图片上下文 &#x2F;&#x2F; UIGraphicsBeginImageContext(imageView.bounds.size); &#x2F;&#x2F; 一般使用下面的方法 UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 0); &#x2F;&#x2F; 绘制贝塞尔曲线 UIBezierPath *bezierPath &#x3D; [UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:100]; &#x2F;&#x2F; 按绘制的贝塞尔曲线剪切 [bezierPath addClip]; &#x2F;&#x2F; 画图 [imageView drawRect:imageView.bounds]; &#x2F;&#x2F; 获取上下文中的图片 imageView.image &#x3D; UIGraphicsGetImageFromCurrentImageContext(); &#x2F;&#x2F; 关闭图片上下文 UIGraphicsEndImageContext(); [self.view addSubview:imageView];&#125; Graphics绘制方法1234567891011121314151617181920- (void)circleImage&#123; UIImageView *imageView &#x3D; [[UIImageView alloc] initWithFrame:CGRectMake(200, 400, 200, 200)]; imageView.image &#x3D; [UIImage imageNamed:@&quot;001.jpeg&quot;]; &#x2F;&#x2F; NO代表透明 UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 0.0); &#x2F;&#x2F; 获得上下文 CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext(); &#x2F;&#x2F; 添加一个圆 CGRect rect &#x3D; CGRectMake(0, 0, imageView.bounds.size.width, imageView.bounds.size.height); CGContextAddEllipseInRect(ctx, rect); &#x2F;&#x2F; 裁剪 CGContextClip(ctx); &#x2F;&#x2F; 将图片画上去 &#x2F;&#x2F; [imageView drawRect:rect]; [imageView.image drawInRect:rect]; imageView.image &#x3D; UIGraphicsGetImageFromCurrentImageContext(); &#x2F;&#x2F; 关闭上下文 UIGraphicsEndImageContext(); [self.view addSubview:imageView];&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 给图片加水印]]></title>
    <url>%2F2019%2F01%2F30%2FiOS%E7%BB%99%E5%9B%BE%E7%89%87%E5%8A%A0%E6%B0%B4%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425&#x2F;&#x2F; 给图片加水印- (void)addWatermarkToPicture&#123; &#x2F;&#x2F; 获取原图片 UIImage *image &#x3D; [UIImage imageNamed:@&quot;FZSDKLib.bundle&#x2F;001.jpg&quot;]; &#x2F;&#x2F; 计算图片的size CGSize imageSize &#x3D; CGSizeMake(image.size.width, image.size.height); &#x2F;&#x2F; 开启图片类型的图形上下文 UIGraphicsBeginImageContextWithOptions(imageSize, NO, 0); &#x2F;&#x2F; 绘制图片 [image drawAtPoint:CGPointZero]; &#x2F;&#x2F; 水印的文字 NSString *str &#x3D; @&quot;水印文字&quot;; &#x2F;&#x2F; 绘制文字水印 [str drawAtPoint:CGPointMake(30, 30) withAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20], NSForegroundColorAttributeName:[UIColor redColor]&#125;]; &#x2F;&#x2F; 水印的图片 UIImage *logoImage &#x3D; [UIImage imageNamed:@&quot;FZSDKLib.bundle&#x2F;companyLogo&quot;]; &#x2F;&#x2F; 绘制图片水印 [logoImage drawAtPoint:CGPointMake(imageSize.width - logoImage.size.width - 30, imageSize.height - logoImage.size.height - 30)]; &#x2F;&#x2F; 取图片 image &#x3D; UIGraphicsGetImageFromCurrentImageContext(); &#x2F;&#x2F; 关闭图片类型的图形上下文 UIGraphicsEndImageContext(); &#x2F;&#x2F; 保存到相册中 UIImageWriteToSavedPhotosAlbum(image, NULL, NULL, NULL);&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 屏幕截图总结]]></title>
    <url>%2F2019%2F01%2F29%2FiOS%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[按屏幕截图，即全屏截图12345678910111213141516- (void)doScreenShot&#123; &#x2F;&#x2F; 开启图片上下文 UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, NO, 0); &#x2F;&#x2F; 获取当前上下文 CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext(); &#x2F;&#x2F; 截图:实际是把layer上面的东西绘制到上下文中 [self.view.layer renderInContext:ctx]; &#x2F;&#x2F;iOS7+ 推荐使用的方法，代替上述方法 &#x2F;&#x2F; [self.view drawViewHierarchyInRect:self.view.frame afterScreenUpdates:YES]; &#x2F;&#x2F; 获取截图 UIImage *image &#x3D; UIGraphicsGetImageFromCurrentImageContext(); &#x2F;&#x2F; 关闭图片上下文 UIGraphicsEndImageContext(); &#x2F;&#x2F; 保存相册 UIImageWriteToSavedPhotosAlbum(image, NULL, NULL, NULL);&#125; 按内容截屏，即截全图1234567891011121314151617181920212223242526272829- (void)screenShots&#123; UICollectionView *shadowView &#x3D; self.collectionView; &#x2F;&#x2F; 开启图片上下文 UIGraphicsBeginImageContextWithOptions(shadowView.contentSize, NO, 0.f); &#x2F;&#x2F; 保存现在视图的位置偏移信息 CGPoint saveContentOffset &#x3D; shadowView.contentOffset; &#x2F;&#x2F; 保存现在视图的frame信息 CGRect saveFrame &#x3D; shadowView.frame; &#x2F;&#x2F; 把要截图的视图偏移量设置为0 shadowView.contentOffset &#x3D; CGPointZero; &#x2F;&#x2F; 设置要截图的视图的frame为内容尺寸大小 shadowView.frame &#x3D; CGRectMake(0, 0, shadowView.contentSize.width, shadowView.contentSize.height); &#x2F;&#x2F; 获取当前上下文 CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext(); &#x2F;&#x2F; 截图:实际是把layer上面的东西绘制到上下文中 [shadowView.layer renderInContext:ctx]; &#x2F;&#x2F;iOS7+ 推荐使用的方法，代替上述方法 &#x2F;&#x2F; [shadowView drawViewHierarchyInRect:shadowView.frame afterScreenUpdates:YES]; &#x2F;&#x2F; 获取截图 UIImage *image &#x3D; UIGraphicsGetImageFromCurrentImageContext(); &#x2F;&#x2F; 关闭图片上下文 UIGraphicsEndImageContext(); &#x2F;&#x2F; 将视图的偏移量设置回原来的状态 shadowView.contentOffset &#x3D; saveContentOffset; &#x2F;&#x2F; 将视图的frame信息设置回原来的状态 shadowView.frame &#x3D; saveFrame; &#x2F;&#x2F; 保存相册 UIImageWriteToSavedPhotosAlbum(image, NULL, NULL, NULL);&#125; 视频截图1234567891011121314151617181920212223242526&#x2F;&#x2F; 需要导入AVFoundation头文件#import &lt;AVFoundation&#x2F;AVFoundation.h&gt;&#x2F;&#x2F; videoURL 视频的URL地址；frameTime 要截取的视频图片帧数+ (UIImage *)imageWithVideo:(NSURL *)videoURL withVideoCaptureFrame:(NSInteger)frameTime&#123; &#x2F;&#x2F; 根据视频的URL创建AVURLAsset AVURLAsset *asset &#x3D; [[AVURLAsset alloc] initWithURL:videoURL options:nil]; &#x2F;&#x2F; 根据AVURLAsset创建AVAssetImageGenerator对象 AVAssetImageGenerator *gen &#x3D; [[AVAssetImageGenerator alloc] initWithAsset:asset]; gen.appliesPreferredTrackTransform &#x3D; YES; &#x2F;&#x2F; 定义获取第几帧处的视频截图 &#x2F;&#x2F; CMTime halfSecond &#x3D; CMTimeMake(1, 2); &#x2F;&#x2F;0.5秒 CMTime time &#x3D; CMTimeMake(frameTime, 10); CMTime actualTime; NSError *error &#x3D; nil; &#x2F;&#x2F; 尝试获取time处的视频截图（实际截屏的时间点保存在actualTime变量中） CGImageRef image &#x3D; [gen copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error]; if (error &#x3D;&#x3D; nil) &#123; &#x2F;&#x2F; 将CGImageRef转换为UIImage UIImage *thumb &#x3D; [[UIImage alloc] initWithCGImage:image]; CGImageRelease(image); return thumb; &#125;else&#123; NSLog(@&quot;对视频截图时出现错误: %@&quot;, error); return nil; &#125;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 报错Attempt to present...whose view is not in the window hierarchy!]]></title>
    <url>%2F2019%2F01%2F23%2FiOSAttempttopresent...whoseviewisnotinthewindowhierarchy%2F</url>
    <content type="text"><![CDATA[Attempt to present &lt;*ViewController: 0x**&gt; on &lt;ViewController: 0x**&gt; whose view is not in the window hierarchy!12345678910111213141516171819202122232425#简单来说，就是当前的ViewController还没有被加载完，就调用了另外一个ViewController，这显然是不允许的。事例：- (void)viewDidLoad &#123; [super viewDidLoad]; TestVC *vc &#x3D; [[TestVC alloc]init]; [self presentViewController:vc animated:NO completion:nil];&#125;第一种：在-(void)viewDidAppear:(BOOL)animated；里实现新的控制器跳转。第二种：延时跳转：- (void)viewDidLoad &#123; [super viewDidLoad]; [NSTimer scheduledTimerWithTimeInterval:2.0f target:self selector:@selector(jump) userInfo:nil repeats:NO];&#125;这种方法可以用，但是不推荐，因为这个延时有可能太长了。第三种：在主线程上执行指定的方法- (void)viewDidLoad &#123; [super viewDidLoad]; [self performSelectorOnMainThread:@selector(jump) withObject:nil waitUntilDone:NO]; &#125;或[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;&#125;];]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS ImageView加载多图动画]]></title>
    <url>%2F2019%2F01%2F10%2FiOSImageView%E5%8A%A0%E8%BD%BD%E5%A4%9A%E5%9B%BE%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031- (void)startAnimationView&#123; &#x2F;&#x2F;创建UIImageView，添加到界面 UIImage *image &#x3D; [UIImage imageNamed:[NSString stringWithFormat:@&quot;fzg_anim_splash_1&quot;]]; CGSize imageSize &#x3D; CGSizeMake(image.size.width, image.size.height); UIImageView *imageView &#x3D; [[UIImageView alloc] initWithFrame:CGRectMake(30, 0, self.view.bounds.size.width - 60, ((self.view.bounds.size.width - 60)*imageSize.height)&#x2F;imageSize.width)]; imageView.center &#x3D; self.view.center; imageView.contentMode &#x3D; UIViewContentModeScaleAspectFit; [self.view addSubview:imageView]; &#x2F;&#x2F;创建一个数组，数组中按顺序添加要播放的图片（图片为静态的图片） NSMutableArray *imageArr &#x3D; [NSMutableArray array]; for (int i &#x3D; 1; i &lt; 32; i++) &#123; UIImage *image &#x3D; [UIImage imageNamed:[NSString stringWithFormat:@&quot;fzg_anim_splash_%d&quot;, i]]; [imageArr addObject:image]; &#125; &#x2F;&#x2F;把存有UIImage的数组赋给动画图片数组 imageView.animationImages &#x3D; imageArr; &#x2F;&#x2F;设置执行一次完整动画的时长 imageView.animationDuration &#x3D; 3.5; &#x2F;&#x2F;动画重复次数 （0为重复播放） imageView.animationRepeatCount &#x3D; 1; &#x2F;&#x2F;开始播放动画 [imageView startAnimating]; &#x2F;&#x2F;自动移除动画图层，延迟4秒执行 [self performSelector:@selector(removeAnimationView) withObject:nil afterDelay:4.f];&#125;- (void)removeAnimationView&#123; NSLog(@&quot;移除动画&quot;); [self.view removeFromSuperview];&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 不用中间变量,用两种方法交换A和B的值1234567891011121314151617181920&#x2F;&#x2F; 1.中间变量void swap(int a, int b) &#123; int temp &#x3D; a; a &#x3D; b; b &#x3D; temp;&#125;&#x2F;&#x2F; 2.加法void swap(int a, int b) &#123; a &#x3D; a + b; b &#x3D; a - b; a &#x3D; (a - b)&#x2F;2;&#125;&#x2F;&#x2F; 3.异或（相同为0，不同为1. 可以理解为不进位加法）void swap(int a, int b) &#123; a &#x3D; a ^ b; b &#x3D; a ^ b; a &#x3D; a ^ b;&#125;2. 求最大公约数123456789101112131415161718192021&#x2F;** 1.直接遍历法 *&#x2F;int maxCommonDivisor(int a, int b) &#123; int max &#x3D; 0; for (int i &#x3D; 1; i &lt;&#x3D; b; i++) &#123; if (a % i &#x3D;&#x3D; 0 &amp;&amp; b % i &#x3D;&#x3D; 0) &#123; max &#x3D; i; &#125; &#125; return max;&#125;&#x2F;** 2.辗转相除法 *&#x2F;int maxCommonDivisor(int a, int b) &#123; int r; while(a % b &gt; 0) &#123; r &#x3D; a % b; a &#x3D; b; b &#x3D; r; &#125; return b;&#125;&#x2F;&#x2F; 扩展：最小公倍数 &#x3D; (a * b)&#x2F;最大公约数3. 排序算法 选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：都将数组分为已排序部分和未排序部分。1). 选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。2). 冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。3). 插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。 选择排序1234567891011121314151617181920212223NSMutableArray *selectArr &#x3D; [NSMutableArray arrayWithArray:@[@&quot;13&quot;,@&quot;5&quot;,@&quot;89&quot;,@&quot;20&quot;,@&quot;40&quot;,@&quot;18&quot;,@&quot;120&quot;]];for (int i &#x3D; 0; i &lt; selectArr.count - 1; i++) &#123; for (int j &#x3D; i + 1; j &lt; selectArr.count; j++) &#123; if ([selectArr[i] integerValue] &gt; [selectArr[j] integerValue]) &#123; NSString *temp &#x3D; selectArr[i]; selectArr[i] &#x3D; selectArr[j]; selectArr[j] &#x3D; temp; &#125; &#125;&#125;&#x2F;&#x2F;【选择排序】最值出现在起始端void selectSort(int *arr, int length) &#123; for (int i &#x3D; 0; i &lt; length - 1; i++) &#123; &#x2F;&#x2F;趟数 for (int j &#x3D; i + 1; j &lt; length; j++) &#123; &#x2F;&#x2F;比较次数 if (arr[i] &gt; arr[j]) &#123; int temp &#x3D; arr[i]; arr[i] &#x3D; arr[j]; arr[j] &#x3D; temp; &#125; &#125; &#125;&#125; 冒泡排序1234567891011121314151617181920212223NSMutableArray *dataArr &#x3D; [NSMutableArray arrayWithArray:@[@&quot;13&quot;,@&quot;5&quot;,@&quot;89&quot;,@&quot;20&quot;,@&quot;40&quot;,@&quot;18&quot;,@&quot;120&quot;]];for (int i &#x3D; 0; i &lt; dataArr.count - 1; i++) &#123; for (int j &#x3D; 0; j &lt; dataArr.count - 1 - i; j++) &#123; if ([dataArr[j] integerValue] &gt; [dataArr[j+1] integerValue]) &#123; NSString *temp &#x3D; dataArr[j]; dataArr[j] &#x3D; dataArr[j+1]; dataArr[j+1] &#x3D; temp; &#125; &#125;&#125;&#x2F;&#x2F;【冒泡排序】相邻元素两两比较，比较完一趟，最值出现在末尾void bublleSort(int *arr, int length) &#123; for(int i &#x3D; 0; i &lt; length - 1; i++) &#123; &#x2F;&#x2F;趟数 for(int j &#x3D; 0; j &lt; length - i - 1; j++) &#123; &#x2F;&#x2F;比较次数 if(arr[j] &gt; arr[j+1]) &#123; int temp &#x3D; arr[j]; arr[j] &#x3D; arr[j+1]; arr[j+1] &#x3D; temp; &#125; &#125; &#125;&#125; 插入排序1234567891011&#x2F;&#x2F; 第一步我们取出第二数 然后让 第二个数与第一个数比较 如果 第二个数&lt; 第一个数 那么我们就将数组第二个数的位子换成第一个数的值 然后 j--NSMutableArray *insertArr &#x3D; [NSMutableArray arrayWithArray:@[@&quot;13&quot;,@&quot;5&quot;,@&quot;89&quot;,@&quot;20&quot;,@&quot;40&quot;,@&quot;18&quot;,@&quot;120&quot;]];for (int i &#x3D; 1; i &lt; insertArr.count; i++) &#123; int j &#x3D; i; NSString *temp &#x3D; insertArr[i]; while (j &gt; 0 &amp;&amp; [insertArr[j] integerValue] &lt; [insertArr[j-1] integerValue]) &#123; [insertArr replaceObjectAtIndex:j withObject:insertArr[j-1]]; j--; &#125; [insertArr replaceObjectAtIndex:j withObject:temp];&#125; 希尔排序123456789101112131415&#x2F;&#x2F; 类似于对半查找 但又不一样NSMutableArray * hillArr &#x3D; [NSMutableArray arrayWithArray:@[@&quot;13&quot;,@&quot;5&quot;,@&quot;89&quot;,@&quot;20&quot;,@&quot;40&quot;,@&quot;18&quot;,@&quot;120&quot;]];int gap &#x3D; hillArr.count&#x2F;2;while (gap &gt;&#x3D; 1) &#123; for (int i &#x3D; gap; i &lt; hillArr.count; i++) &#123; NSString *temp &#x3D; hillArr[i]; int j &#x3D; i; while (j &gt;&#x3D; gap &amp;&amp; [temp integerValue] &lt; [hillArr[j-gap] integerValue]) &#123; [hillArr replaceObjectAtIndex:j withObject:hillArr[j-gap]]; j -&#x3D;gap; &#125; [hillArr replaceObjectAtIndex:j withObject:temp]; &#125; gap &#x3D; gap&#x2F;2;&#125; 快排12345678910111213141516171819202122232425- (void)qkSortArr:(NSMutableArray *)kArr low:(NSInteger)low hight:(NSInteger)hight&#123; if (low &gt;&#x3D; hight) &#123; return; &#125; NSInteger i &#x3D; low; NSInteger j &#x3D; hight; NSString *temp &#x3D; kArr[low]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; [temp integerValue] &lt;&#x3D; [kArr[j] integerValue]) &#123; j--; &#125; kArr[i] &#x3D; kArr[j]; while (i &lt; j &amp;&amp; [temp integerValue] &gt;&#x3D; [kArr[i] integerValue]) &#123; i++; &#125; kArr[j] &#x3D; kArr[i]; &#125; kArr[i] &#x3D; temp; [self qkSortArr:kArr low:low hight:i-1]; [self qkSortArr:kArr low:i+1 hight:hight];&#125; 4. 折半查找（二分查找） 折半查找：优化查找时间（不用遍历全部数据）折半查找的原理：1). 数组必须是有序的2). 必须已知min和max（知道范围）3). 动态计算mid的值，取出mid对应的值进行比较4). 如果mid对应的值大于要查找的值，那么max要变小为mid-15). 如果mid对应的值小于要查找的值，那么min要变大为mid+1 12345678910111213141516171819202122232425262728293031- (NSInteger)binarySearchArr:(NSArray *)arr withLow:(NSInteger)low withHight:(NSInteger)hight withSelcetID:(NSString *)key&#123; if (low &lt; hight) &#123; NSInteger mid &#x3D; (low + hight)&#x2F;2; if ([key integerValue] &#x3D;&#x3D; [arr[mid] integerValue]) &#123; return mid; &#125;else if ([key integerValue] &lt; [arr[mid] integerValue])&#123; return [self binarySearchArr:arr withLow:low withHight:mid-1 withSelcetID:key]; &#125;else&#123; return [self binarySearchArr:arr withLow:mid+1 withHight:hight withSelcetID:key]; &#125; &#125;else&#123; NSLog(@&quot;参数错误&quot;); return -1; &#125;&#125;&#x2F;&#x2F; 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 int findKey(int *arr, int length, int key) &#123; int min &#x3D; 0, max &#x3D; length - 1, mid; while (min &lt;&#x3D; max) &#123; mid &#x3D; (min + max) &#x2F; 2; &#x2F;&#x2F;计算中间值 if (key &gt; arr[mid]) &#123; min &#x3D; mid + 1; &#125; else if (key &lt; arr[mid]) &#123; max &#x3D; mid - 1; &#125; else &#123; return mid; &#125; &#125; return -1;&#125;]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 多线程]]></title>
    <url>%2F2019%2F01%2F08%2FiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 线程与进程 进程：进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源 线程：线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源 2. 进程和线程的区别 进程是CPU分配资源的最小单位，线程是CPU调用（执行任务）的最小单位 一个进程中至少要有一个线程 同一个进程内的线程共享进程的资源 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间 3. 多线程的原理同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象思考：如果线程非常非常多，会发生什么情况？*CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源每条线程被调度执行的频次会降低（线程的执行效率降低） 4. NSThread、GCD和NSOperation的区别 NSThread1234使用更加面向对象OC语言简单易用，可直接操作线程对象线程生命周期程序员管理 GCD1234旨在替代NSThread等线程技术充分利用设备的多核C语言线程生命周期自动管理 NSOperation12345使用更加面向对象OC语言基于GCD（底层是GCD）比GCD多了一些更简单实用的功能线程生命周期自动管理 5. 创建和启动线程创建、启动线程12NSThread *thread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];[thread start]; 创建线程后自动启动线程[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil]; 隐式创建并启动线程[self performSelectorInBackground:@selector(run) withObject:nil]; 阻塞（暂停）线程12+ (void)sleepUntilDate:(NSDate *)date;+ (void)sleepForTimeInterval:(NSTimeInterval)ti; 6. 多线程的安全隐患资源共享1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源比如多个线程访问同一个对象、同一个变量、同一个文件当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题 7. 安全隐患解决 – 互斥锁互斥锁使用格式@synchronized(锁对象) &#123; 需要锁定的代码 &#125;注意：锁定1份代码只用1把锁，用多把锁是无效的1234567互斥锁的优缺点优点：能有效防止因多线程抢夺资源造成的数据安全问题缺点：需要消耗大量的CPU资源互斥锁的使用前提：多条线程抢夺同一块资源相关专业术语：线程同步线程同步的意思是：多条线程在同一条线上执行（按顺序地执行任务）互斥锁，就是使用了线程同步技术 8. 线程间通信常用方法12- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; 9. 并发和并行的区别 并发：指的是多个事情，在同一时间段内同时发生了 并行：指的是多个事情，在同一时间点上同时发生了 并发的多个任务之间是互相抢占资源的 并行的多个任务之间是不互相抢占资源的 只有在多CPU的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS ARC下block的循环引用问题样例探究]]></title>
    <url>%2F2019%2F01%2F02%2FiOSARC%E4%B8%8Bblock%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%E6%A0%B7%E4%BE%8B%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[下面的六种情况，是否会产生内存泄漏。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#x2F;&#x2F;情况一- (void)case1 &#123; NSLog(@&quot;case 1 Click&quot;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; self.name &#x3D; @&quot;case 1&quot;; &#125;);&#125;&#x2F;&#x2F;情况二- (void)case2 &#123; NSLog(@&quot;case 2 Click&quot;); __weak typeof(self) weakSelf &#x3D; self; [self.teacher requestData:^(NSData *data) &#123; typeof(weakSelf) strongSelf &#x3D; weakSelf; strongSelf.name &#x3D; @&quot;case 2&quot;; &#125;];&#125;&#x2F;&#x2F;情况三- (void)case3 &#123; NSLog(@&quot;case 3 Click&quot;); [self.teacher requestData:^(NSData *data) &#123; self.name &#x3D; @&quot;case 3&quot;; &#125;];&#125;&#x2F;&#x2F;情况四- (void)case4 &#123; NSLog(@&quot;case 4 Click&quot;); [self.teacher requestData:^(NSData *data) &#123; self.name &#x3D; @&quot;case 4&quot;; self.teacher &#x3D; nil; &#125;];&#125;&#x2F;&#x2F;情况五- (void)case5 &#123; NSLog(@&quot;case 5 Click&quot;); Teacher *t &#x3D; [[Teacher alloc] init]; [t requestData:^(NSData *data) &#123; self.name &#x3D; @&quot;case 5&quot;; &#125;];&#125;&#x2F;&#x2F;情况六- (void)case6 &#123; NSLog(@&quot;case 6 Click&quot;); [self.teacher callCase6BlackEvent]; self.teacher.case6Block &#x3D; ^(NSData *data) &#123; self.name &#x3D; @&quot;case 6&quot;; &#x2F;&#x2F;下面两句代码任选其一 self.teacher &#x3D; nil; &#x2F;&#x2F; self.teacher.case6Block &#x3D; nil; &#125;;&#125; 分析：情况一：执行了dealloc，不泄露，此情况虽然是block，但未形成保留环block -&gt; self情况二：执行了dealloc，不泄露，此情况就是内存泄漏后的一般处理了 self -&gt;teacher -&gt;block -&gt;strongSelf，后面那个strongSelf和原来的self并没有直接关系，因为strongSelf是通过weakSelf得来的，而weakSelf又没有强引用原来的self情况三：未执行dealloc，内存泄漏，此情况就是最典型的循环引用了，形成保留环无法释放，self -&gt;teacher -&gt;block -&gt;self情况四：执行了dealloc，不泄露，虽然也是保留环，但通过最后一句，使self不再强引用teacher，打破了保留环情况五：执行了dealloc，不泄露，未形成保留环 t -&gt;block -&gt;self情况六：执行了dealloc，不泄露，最后两句代码任选其一即可防止内存泄漏，self.teacher 或者 case6Block 置为空都可以打破 retain cyclePS: 虽然情况四、情况六的写法都可以防止内存泄漏，不过为了统一，个人建议最好还是按照普通写法即情况二的写法。]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 单例篇]]></title>
    <url>%2F2018%2F12%2F26%2FiOS%E5%8D%95%E4%BE%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1. 单例在ARC中的实现ARC中单例实现步骤 在类的内部提供一个static修饰的全局变量 提供一个类方法，方便外界访问 重写+allocWithZone方法，保证永远都只为单例对象分配一次内存空间 严谨起见，重写-copyWithZone方法和-MutableCopyWithZone方法 ARC中单例代码实现123456789101112131415161718192021222324252627282930313233343536#import &quot;Tools.h&quot;@implementation Tools&#x2F;&#x2F; 创建静态对象 防止外部访问static Tools *_instance &#x3D; nil;+(instancetype)allocWithZone:(struct _NSZone *)zone&#123; &#x2F;&#x2F; @synchronized (self) &#123; &#x2F;&#x2F; &#x2F;&#x2F; 为了防止多线程同时访问对象，造成多次分配内存空间，所以要加上线程锁 &#x2F;&#x2F; if (_instance &#x3D;&#x3D; nil) &#123; &#x2F;&#x2F; _instance &#x3D; [super allocWithZone:zone]; &#x2F;&#x2F; &#125; &#x2F;&#x2F; return _instance; &#x2F;&#x2F; &#125; &#x2F;&#x2F; 也可以使用一次性代码 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if (_instance &#x3D;&#x3D; nil) &#123; _instance &#x3D; [super allocWithZone:zone]; &#125; &#125;); return _instance;&#125;&#x2F;&#x2F; 为了使实例易于外界访问 我们一般提供一个类方法&#x2F;&#x2F; 类方法命名规范 share类名|default类名|类名+(instancetype)shareTools&#123; &#x2F;&#x2F;return _instance; &#x2F;&#x2F; 最好用self 用Tools他的子类调用时会出现错误 return [[self alloc] init];&#125;&#x2F;&#x2F; 为了严谨，也要重写copyWithZone 和 mutableCopyWithZone-(id)copyWithZone:(NSZone *)zone&#123; return _instance;&#125;-(id)mutableCopyWithZone:(NSZone *)zone&#123; return _instance;&#125; 2. 单例在MRC中的实现MRC单例实现步骤 在类的内部提供一个static修饰的全局变量 提供一个类方法，方便外界访问 重写+allocWithZone方法，保证永远都只为单例对象分配一次内存空间 严谨起见，重写-copyWithZone方法和-MutableCopyWithZone方法 重写release方法 重写retain方法 建议在retainCount方法中返回一个最大值 配置MRC环境 注意ARC不是垃圾回收机制，是编译器特性 配置MRC环境：build setting -&gt;搜索automatic ref-&gt;修改为N0MRC中单例代码实现 配置好MRC环境之后，在ARC代码基础上重写下面的三个方法即可123456789-(oneway void)release&#123;&#125;-(instancetype)retain&#123; return _instance;&#125;-(NSUInteger)retainCount&#123; return MAXFLOAT;&#125; 3. 单例的另一种实现直接告诉外面 alloc、new、copy、mutableCopy方法不可以直接调用，否则编译不过。1234+ (instancetype)alloc __attribute__((unavailable(&quot;call sharedInstance instead&quot;)));+ (instancetype)new __attribute__((unavailable(&quot;call sharedInstance instead&quot;)));- (instancetype)copy __attribute__((unavailable(&quot;call sharedInstance instead&quot;)));- (instancetype)mutableCopy __attribute__((unavailable(&quot;call sharedInstance instead&quot;)));]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 终端常用命令]]></title>
    <url>%2F2018%2F12%2F25%2FMac%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[目录操作 命令 功能描述 示例 pwd 显示当前路径 pwd cd / 跳转到根路径下 cd / cd .. 跳转到上级路径 cd .. cd 或 ~ 跳转到当前登录用户的家目录 cd 或 cd ~ ls 可以列出当前路径下的所有可见文件和文件夹 ls ls -a 列出当前路径下的所有文件和文件夹 ls -a mkdir 在当前路径下新建一个文件夹 mkdir new_dir mkdir 新建多个文件夹 mkdir dir1 dir2 dir3 rm -r 删除一个文件夹 rm -r dir rm -r 删除多个文件夹 rm -r dir1 dir2 dir3 文件操作 命令 功能描述 示例 touch 在当前路径下新建一个文件 touch file_name rm 删除一个文件 rm file_name rm 删除多个文件 rm file1 file2 file3 cat 显示或连接文件 cat /路径/libiPhone-lib.a strings 在对象文件或者二进制文件中查找可打印的字符串，与grep配合使用，输入strings -h查看strings命令的用法 strings /路径/libiPhone-lib.a \ grep “UIWebView” 其他命令 命令 功能描述 示例 date 显示系统的当前日期和时间 date cal 显示日历 cal clear 或 Ctrl + L 清除屏幕或窗口内容 clear 或 Ctrl + L env 显示当前所有设置过的环境变量 env say 朗读一段文字 say guan curl Mac 查看本机公网IP 命令 curl ipinfo.io/json curl Mac 查看本机公网IP 命令 curl http://members.3322.org/dyndns/getip ifconfig Mac 查看本机内网IP 命令 ifconfig en0]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我的第一条博客“Hello World”My first blog “Hello World”圣诞节快乐…我的博客上线试运行中…]]></content>
      <tags>
        <tag>代码库</tag>
      </tags>
  </entry>
</search>
